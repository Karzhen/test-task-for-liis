/*! For license information please see index.js.LICENSE.txt */
(() => {
    var A = {
        365: (A, e, t) => {
            "use strict";
            t.d(e, {A: () => s});
            var n = t(601), r = t.n(n), i = t(314), a = t.n(i)()(r());
            a.push([A.id, ":root {\n    --black-color: #000000;\n    --white-color: #ffffff;\n    --main-blue: #1ec1ea;\n    --secondary-blue: #1e83c1;\n    --main-gray: #b9b9b9;\n    --secondary-gray: #e1e1e1;\n}\n\n.weather-gradient-1000 {\n    background: linear-gradient(to bottom, #ffdb58, #ff8c00);\n}\n\n.weather-gradient-1003 {\n    background: linear-gradient(to bottom, #87cefa, #4682b4);\n}\n\n.weather-gradient-1006 {\n    background: linear-gradient(to bottom, #a9a9a9, #808080);\n}\n\n.weather-gradient-1009 {\n    background: linear-gradient(to bottom, #d3d3d3, #808080);\n}\n\n* {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n}\n\nhtml {\n    scroll-behavior: smooth;\n}\n\nbody {\n    height: 100vh;\n    width: 100vw;\n    font-family: \"Comic Sans MS\", sans-serif;\n    background-color: var(--secondary-gray);\n}\n\n.header {\n    background: linear-gradient(to right, var(--secondary-blue), var(--main-blue));\n    color: var(--white-color);\n    padding: 20px;\n    text-align: center;\n    border-top-left-radius: 10px;\n    border-top-right-radius: 10px;\n}\n\nh1 {\n    text-transform: uppercase;\n}\n\n.content {\n    max-width: 80%;\n    margin: 20px auto;\n    background-color: var(--white-color);\n    border-radius: 10px;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    display: flex;\n    flex-direction: column;\n    gap: 20px;\n    padding: 20px;\n    justify-content: center;\n}\n\n.current-weather {\n    text-align: center;\n    width: 50%;\n    border-radius: 10px;\n    align-self: center;\n}\n\nli {\n    padding: 10px;\n    border-bottom: 1px solid #eee;\n}\n\n.hourly-forecast {\n    text-align: center;\n}\n\n.hourly-forecast-slider {\n    overflow-x: auto;\n    white-space: nowrap;\n    display: flex;\n}\n\n.hourly__list {\n    list-style-type: none;\n}\n\n.hourly__list-item {\n    display: inline-block;\n    margin-right: 10px;\n    vertical-align: top;\n}\n\n.hourly__item-time {\n    font-size: 1em;\n}\n\n.daily__item-time {\n    color: linear-gradient(to right, var(--secondary-blue), var(--main-blue));\n}\n\n.hourly__item-image {\n    width: 40px;\n    height: auto;\n}\n\n.daily__item-image {\n    width: 50%;\n    height: 50%;\n}\n\n.hourly__item-text {\n    font-size: 0.8em;\n}\n\n.daily__item-text {\n    font-size: 1em;\n}\n\n.daily-forecast {\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n    gap: 10px;\n}\n\n.daily__list {\n    list-style-type: none;\n    display: flex;\n    justify-content: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.daily__list-item {\n    width: 200px;\n    height: 200px;\n    border: 1px solid var(--main-blue);\n    border-radius: 10px;\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n    text-align: center;\n}\n\n.canvas-container {\n    width: 100%;\n    height: 500px;\n    border-radius: 10px;\n    border: 1px solid var(--main-blue);\n    position: relative;\n}\n\ncanvas {\n    border-radius: 10px;\n}\n\nfooter {\n    background-color: #3f3f3f;\n    height: 50px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n}\nfooter .copyright {\n    font-size: 14px;\n    color: #6b6b6b;\n    text-align: center;\n}\nfooter .copyright a {\n    color: #6b6b6b;\n}\nfooter .copyright a:hover {\n    color: #ffc4c4;\n}\nfooter .copyright:before {\n    content: '©';\n}\n\n.floor__2 {\n    width: 100%;\n    height: 30px;\n    display: flex;\n    justify-content: space-between;\n    color: #fff;\n}\n\n.floor__2 a {\n    color: #fff;\n}\n\n.floor__2 a:hover {\n    color: #ffc4c4;\n}\n\n#cubeContainer {\n    position: relative;\n    width: 300px;\n    height: 300px;\n}\n#cube {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    transform-style: preserve-3d;\n}\n.cube-face {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    border: 1px solid black;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    font-size: 20px;\n    background-color: white;\n}", ""]);
            const s = a
        }, 314: A => {
            "use strict";
            A.exports = function (A) {
                var e = [];
                return e.toString = function () {
                    return this.map((function (e) {
                        var t = "", n = void 0 !== e[5];
                        return e[4] && (t += "@supports (".concat(e[4], ") {")), e[2] && (t += "@media ".concat(e[2], " {")), n && (t += "@layer".concat(e[5].length > 0 ? " ".concat(e[5]) : "", " {")), t += A(e), n && (t += "}"), e[2] && (t += "}"), e[4] && (t += "}"), t
                    })).join("")
                }, e.i = function (A, t, n, r, i) {
                    "string" == typeof A && (A = [[null, A, void 0]]);
                    var a = {};
                    if (n) for (var s = 0; s < this.length; s++) {
                        var o = this[s][0];
                        null != o && (a[o] = !0)
                    }
                    for (var l = 0; l < A.length; l++) {
                        var c = [].concat(A[l]);
                        n && a[c[0]] || (void 0 !== i && (void 0 === c[5] || (c[1] = "@layer".concat(c[5].length > 0 ? " ".concat(c[5]) : "", " {").concat(c[1], "}")), c[5] = i), t && (c[2] ? (c[1] = "@media ".concat(c[2], " {").concat(c[1], "}"), c[2] = t) : c[2] = t), r && (c[4] ? (c[1] = "@supports (".concat(c[4], ") {").concat(c[1], "}"), c[4] = r) : c[4] = "".concat(r)), e.push(c))
                    }
                }, e
            }
        }, 601: A => {
            "use strict";
            A.exports = function (A) {
                return A[1]
            }
        }, 385: A => {
            "use strict";
            A.exports = function (A, e) {
                return e || (e = {}), A ? (A = String(A.__esModule ? A.default : A), e.hash && (A += e.hash), e.maybeNeedQuotes && /[\t\n\f\r "'=<>`]/.test(A) ? '"'.concat(A, '"') : A) : A
            }
        }, 354: function (A) {
            A.exports = function () {
                "use strict";
                var A = function (e, t) {
                    return A = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (A, e) {
                        A.__proto__ = e
                    } || function (A, e) {
                        for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (A[t] = e[t])
                    }, A(e, t)
                };

                function e(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

                    function n() {
                        this.constructor = e
                    }

                    A(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
                }

                var t = function () {
                    return t = Object.assign || function (A) {
                        for (var e, t = 1, n = arguments.length; t < n; t++) for (var r in e = arguments[t]) Object.prototype.hasOwnProperty.call(e, r) && (A[r] = e[r]);
                        return A
                    }, t.apply(this, arguments)
                };

                function n(A, e, t, n) {
                    return new (t || (t = Promise))((function (r, i) {
                        function a(A) {
                            try {
                                o(n.next(A))
                            } catch (A) {
                                i(A)
                            }
                        }

                        function s(A) {
                            try {
                                o(n.throw(A))
                            } catch (A) {
                                i(A)
                            }
                        }

                        function o(A) {
                            var e;
                            A.done ? r(A.value) : (e = A.value, e instanceof t ? e : new t((function (A) {
                                A(e)
                            }))).then(a, s)
                        }

                        o((n = n.apply(A, e || [])).next())
                    }))
                }

                function r(A, e) {
                    var t, n, r, i, a = {
                        label: 0, sent: function () {
                            if (1 & r[0]) throw r[1];
                            return r[1]
                        }, trys: [], ops: []
                    };
                    return i = {
                        next: s(0),
                        throw: s(1),
                        return: s(2)
                    }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
                        return this
                    }), i;

                    function s(i) {
                        return function (s) {
                            return function (i) {
                                if (t) throw new TypeError("Generator is already executing.");
                                for (; a;) try {
                                    if (t = 1, n && (r = 2 & i[0] ? n.return : i[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, i[1])).done) return r;
                                    switch (n = 0, r && (i = [2 & i[0], r.value]), i[0]) {
                                        case 0:
                                        case 1:
                                            r = i;
                                            break;
                                        case 4:
                                            return a.label++, {value: i[1], done: !1};
                                        case 5:
                                            a.label++, n = i[1], i = [0];
                                            continue;
                                        case 7:
                                            i = a.ops.pop(), a.trys.pop();
                                            continue;
                                        default:
                                            if (!((r = (r = a.trys).length > 0 && r[r.length - 1]) || 6 !== i[0] && 2 !== i[0])) {
                                                a = 0;
                                                continue
                                            }
                                            if (3 === i[0] && (!r || i[1] > r[0] && i[1] < r[3])) {
                                                a.label = i[1];
                                                break
                                            }
                                            if (6 === i[0] && a.label < r[1]) {
                                                a.label = r[1], r = i;
                                                break
                                            }
                                            if (r && a.label < r[2]) {
                                                a.label = r[2], a.ops.push(i);
                                                break
                                            }
                                            r[2] && a.ops.pop(), a.trys.pop();
                                            continue
                                    }
                                    i = e.call(A, a)
                                } catch (A) {
                                    i = [6, A], n = 0
                                } finally {
                                    t = r = 0
                                }
                                if (5 & i[0]) throw i[1];
                                return {value: i[0] ? i[1] : void 0, done: !0}
                            }([i, s])
                        }
                    }
                }

                function i(A, e, t) {
                    if (t || 2 === arguments.length) for (var n, r = 0, i = e.length; r < i; r++) !n && r in e || (n || (n = Array.prototype.slice.call(e, 0, r)), n[r] = e[r]);
                    return A.concat(n || e)
                }

                for (var a = function () {
                    function A(A, e, t, n) {
                        this.left = A, this.top = e, this.width = t, this.height = n
                    }

                    return A.prototype.add = function (e, t, n, r) {
                        return new A(this.left + e, this.top + t, this.width + n, this.height + r)
                    }, A.fromClientRect = function (e, t) {
                        return new A(t.left + e.windowBounds.left, t.top + e.windowBounds.top, t.width, t.height)
                    }, A.fromDOMRectList = function (e, t) {
                        var n = Array.from(t).find((function (A) {
                            return 0 !== A.width
                        }));
                        return n ? new A(n.left + e.windowBounds.left, n.top + e.windowBounds.top, n.width, n.height) : A.EMPTY
                    }, A.EMPTY = new A(0, 0, 0, 0), A
                }(), s = function (A, e) {
                    return a.fromClientRect(A, e.getBoundingClientRect())
                }, o = function (A) {
                    for (var e = [], t = 0, n = A.length; t < n;) {
                        var r = A.charCodeAt(t++);
                        if (r >= 55296 && r <= 56319 && t < n) {
                            var i = A.charCodeAt(t++);
                            56320 == (64512 & i) ? e.push(((1023 & r) << 10) + (1023 & i) + 65536) : (e.push(r), t--)
                        } else e.push(r)
                    }
                    return e
                }, l = function () {
                    for (var A = [], e = 0; e < arguments.length; e++) A[e] = arguments[e];
                    if (String.fromCodePoint) return String.fromCodePoint.apply(String, A);
                    var t = A.length;
                    if (!t) return "";
                    for (var n = [], r = -1, i = ""; ++r < t;) {
                        var a = A[r];
                        a <= 65535 ? n.push(a) : (a -= 65536, n.push(55296 + (a >> 10), a % 1024 + 56320)), (r + 1 === t || n.length > 16384) && (i += String.fromCharCode.apply(String, n), n.length = 0)
                    }
                    return i
                }, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", u = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), h = 0; h < 64; h++) u[c.charCodeAt(h)] = h;
                for (var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", p = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), f = 0; f < 64; f++) p[d.charCodeAt(f)] = f;
                for (var g = function (A, e, t) {
                    return A.slice ? A.slice(e, t) : new Uint16Array(Array.prototype.slice.call(A, e, t))
                }, m = function () {
                    function A(A, e, t, n, r, i) {
                        this.initialValue = A, this.errorValue = e, this.highStart = t, this.highValueIndex = n, this.index = r, this.data = i
                    }

                    return A.prototype.get = function (A) {
                        var e;
                        if (A >= 0) {
                            if (A < 55296 || A > 56319 && A <= 65535) return e = ((e = this.index[A >> 5]) << 2) + (31 & A), this.data[e];
                            if (A <= 65535) return e = ((e = this.index[2048 + (A - 55296 >> 5)]) << 2) + (31 & A), this.data[e];
                            if (A < this.highStart) return e = 2080 + (A >> 11), e = this.index[e], e += A >> 5 & 63, e = ((e = this.index[e]) << 2) + (31 & A), this.data[e];
                            if (A <= 1114111) return this.data[this.highValueIndex]
                        }
                        return this.errorValue
                    }, A
                }(), B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", w = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), v = 0; v < 64; v++) w[B.charCodeAt(v)] = v;
                var _ = 10, C = 13, E = 15, U = 17, y = 18, x = 19, M = 20, F = 21, S = 22, b = 24, Q = 25, T = 26,
                    I = 27, L = 28, R = 30, H = 32, D = 33, P = 34, N = 35, O = 37, G = 38, V = 39, K = 40, k = 42,
                    z = [9001, 65288], W = "×", X = "÷", Y = function (A, e) {
                        var t, n, r, i = function (A) {
                                var e, t, n, r, i, a = .75 * A.length, s = A.length, o = 0;
                                "=" === A[A.length - 1] && (a--, "=" === A[A.length - 2] && a--);
                                var l = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && void 0 !== Uint8Array.prototype.slice ? new ArrayBuffer(a) : new Array(a),
                                    c = Array.isArray(l) ? l : new Uint8Array(l);
                                for (e = 0; e < s; e += 4) t = p[A.charCodeAt(e)], n = p[A.charCodeAt(e + 1)], r = p[A.charCodeAt(e + 2)], i = p[A.charCodeAt(e + 3)], c[o++] = t << 2 | n >> 4, c[o++] = (15 & n) << 4 | r >> 2, c[o++] = (3 & r) << 6 | 63 & i;
                                return l
                            }(A), a = Array.isArray(i) ? function (A) {
                                for (var e = A.length, t = [], n = 0; n < e; n += 4) t.push(A[n + 3] << 24 | A[n + 2] << 16 | A[n + 1] << 8 | A[n]);
                                return t
                            }(i) : new Uint32Array(i), s = Array.isArray(i) ? function (A) {
                                for (var e = A.length, t = [], n = 0; n < e; n += 2) t.push(A[n + 1] << 8 | A[n]);
                                return t
                            }(i) : new Uint16Array(i), o = g(s, 12, a[4] / 2),
                            l = 2 === a[5] ? g(s, (24 + a[4]) / 2) : (t = a, n = Math.ceil((24 + a[4]) / 4), t.slice ? t.slice(n, r) : new Uint32Array(Array.prototype.slice.call(t, n, r)));
                        return new m(a[0], a[1], a[2], a[3], o, l)
                    }("KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA=="),
                    J = [R, 36], j = [1, 2, 3, 5], Z = [_, 8], q = [I, T], $ = j.concat(Z), AA = [G, V, K, P, N],
                    eA = [E, C], tA = function (A, e, t, n) {
                        var r = n[t];
                        if (Array.isArray(A) ? -1 !== A.indexOf(r) : A === r) for (var i = t; i <= n.length;) {
                            if ((o = n[++i]) === e) return !0;
                            if (o !== _) break
                        }
                        if (r === _) for (i = t; i > 0;) {
                            var a = n[--i];
                            if (Array.isArray(A) ? -1 !== A.indexOf(a) : A === a) for (var s = t; s <= n.length;) {
                                var o;
                                if ((o = n[++s]) === e) return !0;
                                if (o !== _) break
                            }
                            if (a !== _) break
                        }
                        return !1
                    }, nA = function (A, e) {
                        for (var t = A; t >= 0;) {
                            var n = e[t];
                            if (n !== _) return n;
                            t--
                        }
                        return 0
                    }, rA = function (A, e, t, n, r) {
                        if (0 === t[n]) return W;
                        var i = n - 1;
                        if (Array.isArray(r) && !0 === r[i]) return W;
                        var a = i - 1, s = i + 1, o = e[i], l = a >= 0 ? e[a] : 0, c = e[s];
                        if (2 === o && 3 === c) return W;
                        if (-1 !== j.indexOf(o)) return "!";
                        if (-1 !== j.indexOf(c)) return W;
                        if (-1 !== Z.indexOf(c)) return W;
                        if (8 === nA(i, e)) return X;
                        if (11 === Y.get(A[i])) return W;
                        if ((o === H || o === D) && 11 === Y.get(A[s])) return W;
                        if (7 === o || 7 === c) return W;
                        if (9 === o) return W;
                        if (-1 === [_, C, E].indexOf(o) && 9 === c) return W;
                        if (-1 !== [U, y, x, b, L].indexOf(c)) return W;
                        if (nA(i, e) === S) return W;
                        if (tA(23, S, i, e)) return W;
                        if (tA([U, y], F, i, e)) return W;
                        if (tA(12, 12, i, e)) return W;
                        if (o === _) return X;
                        if (23 === o || 23 === c) return W;
                        if (16 === c || 16 === o) return X;
                        if (-1 !== [C, E, F].indexOf(c) || 14 === o) return W;
                        if (36 === l && -1 !== eA.indexOf(o)) return W;
                        if (o === L && 36 === c) return W;
                        if (c === M) return W;
                        if (-1 !== J.indexOf(c) && o === Q || -1 !== J.indexOf(o) && c === Q) return W;
                        if (o === I && -1 !== [O, H, D].indexOf(c) || -1 !== [O, H, D].indexOf(o) && c === T) return W;
                        if (-1 !== J.indexOf(o) && -1 !== q.indexOf(c) || -1 !== q.indexOf(o) && -1 !== J.indexOf(c)) return W;
                        if (-1 !== [I, T].indexOf(o) && (c === Q || -1 !== [S, E].indexOf(c) && e[s + 1] === Q) || -1 !== [S, E].indexOf(o) && c === Q || o === Q && -1 !== [Q, L, b].indexOf(c)) return W;
                        if (-1 !== [Q, L, b, U, y].indexOf(c)) for (var u = i; u >= 0;) {
                            if ((h = e[u]) === Q) return W;
                            if (-1 === [L, b].indexOf(h)) break;
                            u--
                        }
                        if (-1 !== [I, T].indexOf(c)) for (u = -1 !== [U, y].indexOf(o) ? a : i; u >= 0;) {
                            var h;
                            if ((h = e[u]) === Q) return W;
                            if (-1 === [L, b].indexOf(h)) break;
                            u--
                        }
                        if (G === o && -1 !== [G, V, P, N].indexOf(c) || -1 !== [V, P].indexOf(o) && -1 !== [V, K].indexOf(c) || -1 !== [K, N].indexOf(o) && c === K) return W;
                        if (-1 !== AA.indexOf(o) && -1 !== [M, T].indexOf(c) || -1 !== AA.indexOf(c) && o === I) return W;
                        if (-1 !== J.indexOf(o) && -1 !== J.indexOf(c)) return W;
                        if (o === b && -1 !== J.indexOf(c)) return W;
                        if (-1 !== J.concat(Q).indexOf(o) && c === S && -1 === z.indexOf(A[s]) || -1 !== J.concat(Q).indexOf(c) && o === y) return W;
                        if (41 === o && 41 === c) {
                            for (var d = t[i], p = 1; d > 0 && 41 === e[--d];) p++;
                            if (p % 2 != 0) return W
                        }
                        return o === H && c === D ? W : X
                    }, iA = function (A, e) {
                        e || (e = {lineBreak: "normal", wordBreak: "normal"});
                        var t = function (A, e) {
                            void 0 === e && (e = "strict");
                            var t = [], n = [], r = [];
                            return A.forEach((function (A, i) {
                                var a = Y.get(A);
                                if (a > 50 ? (r.push(!0), a -= 50) : r.push(!1), -1 !== ["normal", "auto", "loose"].indexOf(e) && -1 !== [8208, 8211, 12316, 12448].indexOf(A)) return n.push(i), t.push(16);
                                if (4 === a || 11 === a) {
                                    if (0 === i) return n.push(i), t.push(R);
                                    var s = t[i - 1];
                                    return -1 === $.indexOf(s) ? (n.push(n[i - 1]), t.push(s)) : (n.push(i), t.push(R))
                                }
                                return n.push(i), 31 === a ? t.push("strict" === e ? F : O) : a === k || 29 === a ? t.push(R) : 43 === a ? A >= 131072 && A <= 196605 || A >= 196608 && A <= 262141 ? t.push(O) : t.push(R) : void t.push(a)
                            })), [n, t, r]
                        }(A, e.lineBreak), n = t[0], r = t[1], i = t[2];
                        "break-all" !== e.wordBreak && "break-word" !== e.wordBreak || (r = r.map((function (A) {
                            return -1 !== [Q, R, k].indexOf(A) ? O : A
                        })));
                        var a = "keep-all" === e.wordBreak ? i.map((function (e, t) {
                            return e && A[t] >= 19968 && A[t] <= 40959
                        })) : void 0;
                        return [n, r, a]
                    }, aA = function () {
                        function A(A, e, t, n) {
                            this.codePoints = A, this.required = "!" === e, this.start = t, this.end = n
                        }

                        return A.prototype.slice = function () {
                            return l.apply(void 0, this.codePoints.slice(this.start, this.end))
                        }, A
                    }(), sA = 45, oA = 43, lA = -1, cA = function (A) {
                        return A >= 48 && A <= 57
                    }, uA = function (A) {
                        return cA(A) || A >= 65 && A <= 70 || A >= 97 && A <= 102
                    }, hA = function (A) {
                        return 10 === A || 9 === A || 32 === A
                    }, dA = function (A) {
                        return function (A) {
                            return function (A) {
                                return A >= 97 && A <= 122
                            }(A) || function (A) {
                                return A >= 65 && A <= 90
                            }(A)
                        }(A) || function (A) {
                            return A >= 128
                        }(A) || 95 === A
                    }, pA = function (A) {
                        return dA(A) || cA(A) || A === sA
                    }, fA = function (A) {
                        return A >= 0 && A <= 8 || 11 === A || A >= 14 && A <= 31 || 127 === A
                    }, gA = function (A, e) {
                        return 92 === A && 10 !== e
                    }, mA = function (A, e, t) {
                        return A === sA ? dA(e) || gA(e, t) : !!dA(A) || !(92 !== A || !gA(A, e))
                    }, BA = function (A, e, t) {
                        return A === oA || A === sA ? !!cA(e) || 46 === e && cA(t) : cA(46 === A ? e : A)
                    }, wA = function (A) {
                        var e = 0, t = 1;
                        A[e] !== oA && A[e] !== sA || (A[e] === sA && (t = -1), e++);
                        for (var n = []; cA(A[e]);) n.push(A[e++]);
                        var r = n.length ? parseInt(l.apply(void 0, n), 10) : 0;
                        46 === A[e] && e++;
                        for (var i = []; cA(A[e]);) i.push(A[e++]);
                        var a = i.length, s = a ? parseInt(l.apply(void 0, i), 10) : 0;
                        69 !== A[e] && 101 !== A[e] || e++;
                        var o = 1;
                        A[e] !== oA && A[e] !== sA || (A[e] === sA && (o = -1), e++);
                        for (var c = []; cA(A[e]);) c.push(A[e++]);
                        var u = c.length ? parseInt(l.apply(void 0, c), 10) : 0;
                        return t * (r + s * Math.pow(10, -a)) * Math.pow(10, o * u)
                    }, vA = {type: 2}, _A = {type: 3}, CA = {type: 4}, EA = {type: 13}, UA = {type: 8}, yA = {type: 21},
                    xA = {type: 9}, MA = {type: 10}, FA = {type: 11}, SA = {type: 12}, bA = {type: 14}, QA = {type: 23},
                    TA = {type: 1}, IA = {type: 25}, LA = {type: 24}, RA = {type: 26}, HA = {type: 27}, DA = {type: 28},
                    PA = {type: 29}, NA = {type: 31}, OA = {type: 32}, GA = function () {
                        function A() {
                            this._value = []
                        }

                        return A.prototype.write = function (A) {
                            this._value = this._value.concat(o(A))
                        }, A.prototype.read = function () {
                            for (var A = [], e = this.consumeToken(); e !== OA;) A.push(e), e = this.consumeToken();
                            return A
                        }, A.prototype.consumeToken = function () {
                            var A = this.consumeCodePoint();
                            switch (A) {
                                case 34:
                                    return this.consumeStringToken(34);
                                case 35:
                                    var e = this.peekCodePoint(0), t = this.peekCodePoint(1), n = this.peekCodePoint(2);
                                    if (pA(e) || gA(t, n)) {
                                        var r = mA(e, t, n) ? 2 : 1;
                                        return {type: 5, value: this.consumeName(), flags: r}
                                    }
                                    break;
                                case 36:
                                    if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), EA;
                                    break;
                                case 39:
                                    return this.consumeStringToken(39);
                                case 40:
                                    return vA;
                                case 41:
                                    return _A;
                                case 42:
                                    if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), bA;
                                    break;
                                case oA:
                                    if (BA(A, this.peekCodePoint(0), this.peekCodePoint(1))) return this.reconsumeCodePoint(A), this.consumeNumericToken();
                                    break;
                                case 44:
                                    return CA;
                                case sA:
                                    var i = A, a = this.peekCodePoint(0), s = this.peekCodePoint(1);
                                    if (BA(i, a, s)) return this.reconsumeCodePoint(A), this.consumeNumericToken();
                                    if (mA(i, a, s)) return this.reconsumeCodePoint(A), this.consumeIdentLikeToken();
                                    if (a === sA && 62 === s) return this.consumeCodePoint(), this.consumeCodePoint(), LA;
                                    break;
                                case 46:
                                    if (BA(A, this.peekCodePoint(0), this.peekCodePoint(1))) return this.reconsumeCodePoint(A), this.consumeNumericToken();
                                    break;
                                case 47:
                                    if (42 === this.peekCodePoint(0)) for (this.consumeCodePoint(); ;) {
                                        var o = this.consumeCodePoint();
                                        if (42 === o && 47 === (o = this.consumeCodePoint())) return this.consumeToken();
                                        if (o === lA) return this.consumeToken()
                                    }
                                    break;
                                case 58:
                                    return RA;
                                case 59:
                                    return HA;
                                case 60:
                                    if (33 === this.peekCodePoint(0) && this.peekCodePoint(1) === sA && this.peekCodePoint(2) === sA) return this.consumeCodePoint(), this.consumeCodePoint(), IA;
                                    break;
                                case 64:
                                    var c = this.peekCodePoint(0), u = this.peekCodePoint(1), h = this.peekCodePoint(2);
                                    if (mA(c, u, h)) return {type: 7, value: this.consumeName()};
                                    break;
                                case 91:
                                    return DA;
                                case 92:
                                    if (gA(A, this.peekCodePoint(0))) return this.reconsumeCodePoint(A), this.consumeIdentLikeToken();
                                    break;
                                case 93:
                                    return PA;
                                case 61:
                                    if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), UA;
                                    break;
                                case 123:
                                    return FA;
                                case 125:
                                    return SA;
                                case 117:
                                case 85:
                                    var d = this.peekCodePoint(0), p = this.peekCodePoint(1);
                                    return d !== oA || !uA(p) && 63 !== p || (this.consumeCodePoint(), this.consumeUnicodeRangeToken()), this.reconsumeCodePoint(A), this.consumeIdentLikeToken();
                                case 124:
                                    if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), xA;
                                    if (124 === this.peekCodePoint(0)) return this.consumeCodePoint(), yA;
                                    break;
                                case 126:
                                    if (61 === this.peekCodePoint(0)) return this.consumeCodePoint(), MA;
                                    break;
                                case lA:
                                    return OA
                            }
                            return hA(A) ? (this.consumeWhiteSpace(), NA) : cA(A) ? (this.reconsumeCodePoint(A), this.consumeNumericToken()) : dA(A) ? (this.reconsumeCodePoint(A), this.consumeIdentLikeToken()) : {
                                type: 6,
                                value: l(A)
                            }
                        }, A.prototype.consumeCodePoint = function () {
                            var A = this._value.shift();
                            return void 0 === A ? -1 : A
                        }, A.prototype.reconsumeCodePoint = function (A) {
                            this._value.unshift(A)
                        }, A.prototype.peekCodePoint = function (A) {
                            return A >= this._value.length ? -1 : this._value[A]
                        }, A.prototype.consumeUnicodeRangeToken = function () {
                            for (var A = [], e = this.consumeCodePoint(); uA(e) && A.length < 6;) A.push(e), e = this.consumeCodePoint();
                            for (var t = !1; 63 === e && A.length < 6;) A.push(e), e = this.consumeCodePoint(), t = !0;
                            if (t) return {
                                type: 30, start: parseInt(l.apply(void 0, A.map((function (A) {
                                    return 63 === A ? 48 : A
                                }))), 16), end: parseInt(l.apply(void 0, A.map((function (A) {
                                    return 63 === A ? 70 : A
                                }))), 16)
                            };
                            var n = parseInt(l.apply(void 0, A), 16);
                            if (this.peekCodePoint(0) === sA && uA(this.peekCodePoint(1))) {
                                this.consumeCodePoint(), e = this.consumeCodePoint();
                                for (var r = []; uA(e) && r.length < 6;) r.push(e), e = this.consumeCodePoint();
                                return {type: 30, start: n, end: parseInt(l.apply(void 0, r), 16)}
                            }
                            return {type: 30, start: n, end: n}
                        }, A.prototype.consumeIdentLikeToken = function () {
                            var A = this.consumeName();
                            return "url" === A.toLowerCase() && 40 === this.peekCodePoint(0) ? (this.consumeCodePoint(), this.consumeUrlToken()) : 40 === this.peekCodePoint(0) ? (this.consumeCodePoint(), {
                                type: 19,
                                value: A
                            }) : {type: 20, value: A}
                        }, A.prototype.consumeUrlToken = function () {
                            var A = [];
                            if (this.consumeWhiteSpace(), this.peekCodePoint(0) === lA) return {type: 22, value: ""};
                            var e = this.peekCodePoint(0);
                            if (39 === e || 34 === e) {
                                var t = this.consumeStringToken(this.consumeCodePoint());
                                return 0 === t.type && (this.consumeWhiteSpace(), this.peekCodePoint(0) === lA || 41 === this.peekCodePoint(0)) ? (this.consumeCodePoint(), {
                                    type: 22,
                                    value: t.value
                                }) : (this.consumeBadUrlRemnants(), QA)
                            }
                            for (; ;) {
                                var n = this.consumeCodePoint();
                                if (n === lA || 41 === n) return {type: 22, value: l.apply(void 0, A)};
                                if (hA(n)) return this.consumeWhiteSpace(), this.peekCodePoint(0) === lA || 41 === this.peekCodePoint(0) ? (this.consumeCodePoint(), {
                                    type: 22,
                                    value: l.apply(void 0, A)
                                }) : (this.consumeBadUrlRemnants(), QA);
                                if (34 === n || 39 === n || 40 === n || fA(n)) return this.consumeBadUrlRemnants(), QA;
                                if (92 === n) {
                                    if (!gA(n, this.peekCodePoint(0))) return this.consumeBadUrlRemnants(), QA;
                                    A.push(this.consumeEscapedCodePoint())
                                } else A.push(n)
                            }
                        }, A.prototype.consumeWhiteSpace = function () {
                            for (; hA(this.peekCodePoint(0));) this.consumeCodePoint()
                        }, A.prototype.consumeBadUrlRemnants = function () {
                            for (; ;) {
                                var A = this.consumeCodePoint();
                                if (41 === A || A === lA) return;
                                gA(A, this.peekCodePoint(0)) && this.consumeEscapedCodePoint()
                            }
                        }, A.prototype.consumeStringSlice = function (A) {
                            for (var e = ""; A > 0;) {
                                var t = Math.min(5e4, A);
                                e += l.apply(void 0, this._value.splice(0, t)), A -= t
                            }
                            return this._value.shift(), e
                        }, A.prototype.consumeStringToken = function (A) {
                            for (var e = "", t = 0; ;) {
                                var n = this._value[t];
                                if (n === lA || void 0 === n || n === A) return {
                                    type: 0,
                                    value: e += this.consumeStringSlice(t)
                                };
                                if (10 === n) return this._value.splice(0, t), TA;
                                if (92 === n) {
                                    var r = this._value[t + 1];
                                    r !== lA && void 0 !== r && (10 === r ? (e += this.consumeStringSlice(t), t = -1, this._value.shift()) : gA(n, r) && (e += this.consumeStringSlice(t), e += l(this.consumeEscapedCodePoint()), t = -1))
                                }
                                t++
                            }
                        }, A.prototype.consumeNumber = function () {
                            var A = [], e = 4, t = this.peekCodePoint(0);
                            for (t !== oA && t !== sA || A.push(this.consumeCodePoint()); cA(this.peekCodePoint(0));) A.push(this.consumeCodePoint());
                            t = this.peekCodePoint(0);
                            var n = this.peekCodePoint(1);
                            if (46 === t && cA(n)) for (A.push(this.consumeCodePoint(), this.consumeCodePoint()), e = 8; cA(this.peekCodePoint(0));) A.push(this.consumeCodePoint());
                            t = this.peekCodePoint(0), n = this.peekCodePoint(1);
                            var r = this.peekCodePoint(2);
                            if ((69 === t || 101 === t) && ((n === oA || n === sA) && cA(r) || cA(n))) for (A.push(this.consumeCodePoint(), this.consumeCodePoint()), e = 8; cA(this.peekCodePoint(0));) A.push(this.consumeCodePoint());
                            return [wA(A), e]
                        }, A.prototype.consumeNumericToken = function () {
                            var A = this.consumeNumber(), e = A[0], t = A[1], n = this.peekCodePoint(0),
                                r = this.peekCodePoint(1), i = this.peekCodePoint(2);
                            return mA(n, r, i) ? {
                                type: 15,
                                number: e,
                                flags: t,
                                unit: this.consumeName()
                            } : 37 === n ? (this.consumeCodePoint(), {type: 16, number: e, flags: t}) : {
                                type: 17,
                                number: e,
                                flags: t
                            }
                        }, A.prototype.consumeEscapedCodePoint = function () {
                            var A = this.consumeCodePoint();
                            if (uA(A)) {
                                for (var e = l(A); uA(this.peekCodePoint(0)) && e.length < 6;) e += l(this.consumeCodePoint());
                                hA(this.peekCodePoint(0)) && this.consumeCodePoint();
                                var t = parseInt(e, 16);
                                return 0 === t || function (A) {
                                    return A >= 55296 && A <= 57343
                                }(t) || t > 1114111 ? 65533 : t
                            }
                            return A === lA ? 65533 : A
                        }, A.prototype.consumeName = function () {
                            for (var A = ""; ;) {
                                var e = this.consumeCodePoint();
                                if (pA(e)) A += l(e); else {
                                    if (!gA(e, this.peekCodePoint(0))) return this.reconsumeCodePoint(e), A;
                                    A += l(this.consumeEscapedCodePoint())
                                }
                            }
                        }, A
                    }(), VA = function () {
                        function A(A) {
                            this._tokens = A
                        }

                        return A.create = function (e) {
                            var t = new GA;
                            return t.write(e), new A(t.read())
                        }, A.parseValue = function (e) {
                            return A.create(e).parseComponentValue()
                        }, A.parseValues = function (e) {
                            return A.create(e).parseComponentValues()
                        }, A.prototype.parseComponentValue = function () {
                            for (var A = this.consumeToken(); 31 === A.type;) A = this.consumeToken();
                            if (32 === A.type) throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
                            this.reconsumeToken(A);
                            var e = this.consumeComponentValue();
                            do {
                                A = this.consumeToken()
                            } while (31 === A.type);
                            if (32 === A.type) return e;
                            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one")
                        }, A.prototype.parseComponentValues = function () {
                            for (var A = []; ;) {
                                var e = this.consumeComponentValue();
                                if (32 === e.type) return A;
                                A.push(e), A.push()
                            }
                        }, A.prototype.consumeComponentValue = function () {
                            var A = this.consumeToken();
                            switch (A.type) {
                                case 11:
                                case 28:
                                case 2:
                                    return this.consumeSimpleBlock(A.type);
                                case 19:
                                    return this.consumeFunction(A)
                            }
                            return A
                        }, A.prototype.consumeSimpleBlock = function (A) {
                            for (var e = {type: A, values: []}, t = this.consumeToken(); ;) {
                                if (32 === t.type || ZA(t, A)) return e;
                                this.reconsumeToken(t), e.values.push(this.consumeComponentValue()), t = this.consumeToken()
                            }
                        }, A.prototype.consumeFunction = function (A) {
                            for (var e = {name: A.value, values: [], type: 18}; ;) {
                                var t = this.consumeToken();
                                if (32 === t.type || 3 === t.type) return e;
                                this.reconsumeToken(t), e.values.push(this.consumeComponentValue())
                            }
                        }, A.prototype.consumeToken = function () {
                            var A = this._tokens.shift();
                            return void 0 === A ? OA : A
                        }, A.prototype.reconsumeToken = function (A) {
                            this._tokens.unshift(A)
                        }, A
                    }(), KA = function (A) {
                        return 15 === A.type
                    }, kA = function (A) {
                        return 17 === A.type
                    }, zA = function (A) {
                        return 20 === A.type
                    }, WA = function (A) {
                        return 0 === A.type
                    }, XA = function (A, e) {
                        return zA(A) && A.value === e
                    }, YA = function (A) {
                        return 31 !== A.type
                    }, JA = function (A) {
                        return 31 !== A.type && 4 !== A.type
                    }, jA = function (A) {
                        var e = [], t = [];
                        return A.forEach((function (A) {
                            if (4 === A.type) {
                                if (0 === t.length) throw new Error("Error parsing function args, zero tokens for arg");
                                return e.push(t), void (t = [])
                            }
                            31 !== A.type && t.push(A)
                        })), t.length && e.push(t), e
                    }, ZA = function (A, e) {
                        return 11 === e && 12 === A.type || 28 === e && 29 === A.type || 2 === e && 3 === A.type
                    }, qA = function (A) {
                        return 17 === A.type || 15 === A.type
                    }, $A = function (A) {
                        return 16 === A.type || qA(A)
                    }, Ae = function (A) {
                        return A.length > 1 ? [A[0], A[1]] : [A[0]]
                    }, ee = {type: 17, number: 0, flags: 4}, te = {type: 16, number: 50, flags: 4},
                    ne = {type: 16, number: 100, flags: 4}, re = function (A, e, t) {
                        var n = A[0], r = A[1];
                        return [ie(n, e), ie(void 0 !== r ? r : n, t)]
                    }, ie = function (A, e) {
                        if (16 === A.type) return A.number / 100 * e;
                        if (KA(A)) switch (A.unit) {
                            case"rem":
                            case"em":
                                return 16 * A.number;
                            default:
                                return A.number
                        }
                        return A.number
                    }, ae = "grad", se = "turn", oe = function (A, e) {
                        if (15 === e.type) switch (e.unit) {
                            case"deg":
                                return Math.PI * e.number / 180;
                            case ae:
                                return Math.PI / 200 * e.number;
                            case"rad":
                                return e.number;
                            case se:
                                return 2 * Math.PI * e.number
                        }
                        throw new Error("Unsupported angle type")
                    }, le = function (A) {
                        return 15 === A.type && ("deg" === A.unit || A.unit === ae || "rad" === A.unit || A.unit === se)
                    }, ce = function (A) {
                        switch (A.filter(zA).map((function (A) {
                            return A.value
                        })).join(" ")) {
                            case"to bottom right":
                            case"to right bottom":
                            case"left top":
                            case"top left":
                                return [ee, ee];
                            case"to top":
                            case"bottom":
                                return ue(0);
                            case"to bottom left":
                            case"to left bottom":
                            case"right top":
                            case"top right":
                                return [ee, ne];
                            case"to right":
                            case"left":
                                return ue(90);
                            case"to top left":
                            case"to left top":
                            case"right bottom":
                            case"bottom right":
                                return [ne, ne];
                            case"to bottom":
                            case"top":
                                return ue(180);
                            case"to top right":
                            case"to right top":
                            case"left bottom":
                            case"bottom left":
                                return [ne, ee];
                            case"to left":
                            case"right":
                                return ue(270)
                        }
                        return 0
                    }, ue = function (A) {
                        return Math.PI * A / 180
                    }, he = function (A, e) {
                        if (18 === e.type) {
                            var t = ve[e.name];
                            if (void 0 === t) throw new Error('Attempting to parse an unsupported color function "' + e.name + '"');
                            return t(A, e.values)
                        }
                        if (5 === e.type) {
                            if (3 === e.value.length) {
                                var n = e.value.substring(0, 1), r = e.value.substring(1, 2), i = e.value.substring(2, 3);
                                return fe(parseInt(n + n, 16), parseInt(r + r, 16), parseInt(i + i, 16), 1)
                            }
                            if (4 === e.value.length) {
                                n = e.value.substring(0, 1), r = e.value.substring(1, 2), i = e.value.substring(2, 3);
                                var a = e.value.substring(3, 4);
                                return fe(parseInt(n + n, 16), parseInt(r + r, 16), parseInt(i + i, 16), parseInt(a + a, 16) / 255)
                            }
                            if (6 === e.value.length) return n = e.value.substring(0, 2), r = e.value.substring(2, 4), i = e.value.substring(4, 6), fe(parseInt(n, 16), parseInt(r, 16), parseInt(i, 16), 1);
                            if (8 === e.value.length) return n = e.value.substring(0, 2), r = e.value.substring(2, 4), i = e.value.substring(4, 6), a = e.value.substring(6, 8), fe(parseInt(n, 16), parseInt(r, 16), parseInt(i, 16), parseInt(a, 16) / 255)
                        }
                        if (20 === e.type) {
                            var s = Ce[e.value.toUpperCase()];
                            if (void 0 !== s) return s
                        }
                        return Ce.TRANSPARENT
                    }, de = function (A) {
                        return 0 == (255 & A)
                    }, pe = function (A) {
                        var e = 255 & A, t = 255 & A >> 8, n = 255 & A >> 16, r = 255 & A >> 24;
                        return e < 255 ? "rgba(" + r + "," + n + "," + t + "," + e / 255 + ")" : "rgb(" + r + "," + n + "," + t + ")"
                    }, fe = function (A, e, t, n) {
                        return (A << 24 | e << 16 | t << 8 | Math.round(255 * n) << 0) >>> 0
                    }, ge = function (A, e) {
                        if (17 === A.type) return A.number;
                        if (16 === A.type) {
                            var t = 3 === e ? 1 : 255;
                            return 3 === e ? A.number / 100 * t : Math.round(A.number / 100 * t)
                        }
                        return 0
                    }, me = function (A, e) {
                        var t = e.filter(JA);
                        if (3 === t.length) {
                            var n = t.map(ge), r = n[0], i = n[1], a = n[2];
                            return fe(r, i, a, 1)
                        }
                        if (4 === t.length) {
                            var s = t.map(ge), o = (r = s[0], i = s[1], a = s[2], s[3]);
                            return fe(r, i, a, o)
                        }
                        return 0
                    };

                function Be(A, e, t) {
                    return t < 0 && (t += 1), t >= 1 && (t -= 1), t < 1 / 6 ? (e - A) * t * 6 + A : t < .5 ? e : t < 2 / 3 ? 6 * (e - A) * (2 / 3 - t) + A : A
                }

                var we = function (A, e) {
                        var t = e.filter(JA), n = t[0], r = t[1], i = t[2], a = t[3],
                            s = (17 === n.type ? ue(n.number) : oe(A, n)) / (2 * Math.PI), o = $A(r) ? r.number / 100 : 0,
                            l = $A(i) ? i.number / 100 : 0, c = void 0 !== a && $A(a) ? ie(a, 1) : 1;
                        if (0 === o) return fe(255 * l, 255 * l, 255 * l, 1);
                        var u = l <= .5 ? l * (o + 1) : l + o - l * o, h = 2 * l - u, d = Be(h, u, s + 1 / 3),
                            p = Be(h, u, s), f = Be(h, u, s - 1 / 3);
                        return fe(255 * d, 255 * p, 255 * f, c)
                    }, ve = {hsl: we, hsla: we, rgb: me, rgba: me}, _e = function (A, e) {
                        return he(A, VA.create(e).parseComponentValue())
                    }, Ce = {
                        ALICEBLUE: 4042850303,
                        ANTIQUEWHITE: 4209760255,
                        AQUA: 16777215,
                        AQUAMARINE: 2147472639,
                        AZURE: 4043309055,
                        BEIGE: 4126530815,
                        BISQUE: 4293182719,
                        BLACK: 255,
                        BLANCHEDALMOND: 4293643775,
                        BLUE: 65535,
                        BLUEVIOLET: 2318131967,
                        BROWN: 2771004159,
                        BURLYWOOD: 3736635391,
                        CADETBLUE: 1604231423,
                        CHARTREUSE: 2147418367,
                        CHOCOLATE: 3530104575,
                        CORAL: 4286533887,
                        CORNFLOWERBLUE: 1687547391,
                        CORNSILK: 4294499583,
                        CRIMSON: 3692313855,
                        CYAN: 16777215,
                        DARKBLUE: 35839,
                        DARKCYAN: 9145343,
                        DARKGOLDENROD: 3095837695,
                        DARKGRAY: 2846468607,
                        DARKGREEN: 6553855,
                        DARKGREY: 2846468607,
                        DARKKHAKI: 3182914559,
                        DARKMAGENTA: 2332068863,
                        DARKOLIVEGREEN: 1433087999,
                        DARKORANGE: 4287365375,
                        DARKORCHID: 2570243327,
                        DARKRED: 2332033279,
                        DARKSALMON: 3918953215,
                        DARKSEAGREEN: 2411499519,
                        DARKSLATEBLUE: 1211993087,
                        DARKSLATEGRAY: 793726975,
                        DARKSLATEGREY: 793726975,
                        DARKTURQUOISE: 13554175,
                        DARKVIOLET: 2483082239,
                        DEEPPINK: 4279538687,
                        DEEPSKYBLUE: 12582911,
                        DIMGRAY: 1768516095,
                        DIMGREY: 1768516095,
                        DODGERBLUE: 512819199,
                        FIREBRICK: 2988581631,
                        FLORALWHITE: 4294635775,
                        FORESTGREEN: 579543807,
                        FUCHSIA: 4278255615,
                        GAINSBORO: 3705462015,
                        GHOSTWHITE: 4177068031,
                        GOLD: 4292280575,
                        GOLDENROD: 3668254975,
                        GRAY: 2155905279,
                        GREEN: 8388863,
                        GREENYELLOW: 2919182335,
                        GREY: 2155905279,
                        HONEYDEW: 4043305215,
                        HOTPINK: 4285117695,
                        INDIANRED: 3445382399,
                        INDIGO: 1258324735,
                        IVORY: 4294963455,
                        KHAKI: 4041641215,
                        LAVENDER: 3873897215,
                        LAVENDERBLUSH: 4293981695,
                        LAWNGREEN: 2096890111,
                        LEMONCHIFFON: 4294626815,
                        LIGHTBLUE: 2916673279,
                        LIGHTCORAL: 4034953471,
                        LIGHTCYAN: 3774873599,
                        LIGHTGOLDENRODYELLOW: 4210742015,
                        LIGHTGRAY: 3553874943,
                        LIGHTGREEN: 2431553791,
                        LIGHTGREY: 3553874943,
                        LIGHTPINK: 4290167295,
                        LIGHTSALMON: 4288707327,
                        LIGHTSEAGREEN: 548580095,
                        LIGHTSKYBLUE: 2278488831,
                        LIGHTSLATEGRAY: 2005441023,
                        LIGHTSLATEGREY: 2005441023,
                        LIGHTSTEELBLUE: 2965692159,
                        LIGHTYELLOW: 4294959359,
                        LIME: 16711935,
                        LIMEGREEN: 852308735,
                        LINEN: 4210091775,
                        MAGENTA: 4278255615,
                        MAROON: 2147483903,
                        MEDIUMAQUAMARINE: 1724754687,
                        MEDIUMBLUE: 52735,
                        MEDIUMORCHID: 3126187007,
                        MEDIUMPURPLE: 2473647103,
                        MEDIUMSEAGREEN: 1018393087,
                        MEDIUMSLATEBLUE: 2070474495,
                        MEDIUMSPRINGGREEN: 16423679,
                        MEDIUMTURQUOISE: 1221709055,
                        MEDIUMVIOLETRED: 3340076543,
                        MIDNIGHTBLUE: 421097727,
                        MINTCREAM: 4127193855,
                        MISTYROSE: 4293190143,
                        MOCCASIN: 4293178879,
                        NAVAJOWHITE: 4292783615,
                        NAVY: 33023,
                        OLDLACE: 4260751103,
                        OLIVE: 2155872511,
                        OLIVEDRAB: 1804477439,
                        ORANGE: 4289003775,
                        ORANGERED: 4282712319,
                        ORCHID: 3664828159,
                        PALEGOLDENROD: 4008225535,
                        PALEGREEN: 2566625535,
                        PALETURQUOISE: 2951671551,
                        PALEVIOLETRED: 3681588223,
                        PAPAYAWHIP: 4293907967,
                        PEACHPUFF: 4292524543,
                        PERU: 3448061951,
                        PINK: 4290825215,
                        PLUM: 3718307327,
                        POWDERBLUE: 2967529215,
                        PURPLE: 2147516671,
                        REBECCAPURPLE: 1714657791,
                        RED: 4278190335,
                        ROSYBROWN: 3163525119,
                        ROYALBLUE: 1097458175,
                        SADDLEBROWN: 2336560127,
                        SALMON: 4202722047,
                        SANDYBROWN: 4104413439,
                        SEAGREEN: 780883967,
                        SEASHELL: 4294307583,
                        SIENNA: 2689740287,
                        SILVER: 3233857791,
                        SKYBLUE: 2278484991,
                        SLATEBLUE: 1784335871,
                        SLATEGRAY: 1887473919,
                        SLATEGREY: 1887473919,
                        SNOW: 4294638335,
                        SPRINGGREEN: 16744447,
                        STEELBLUE: 1182971135,
                        TAN: 3535047935,
                        TEAL: 8421631,
                        THISTLE: 3636451583,
                        TOMATO: 4284696575,
                        TRANSPARENT: 0,
                        TURQUOISE: 1088475391,
                        VIOLET: 4001558271,
                        WHEAT: 4125012991,
                        WHITE: 4294967295,
                        WHITESMOKE: 4126537215,
                        YELLOW: 4294902015,
                        YELLOWGREEN: 2597139199
                    }, Ee = {
                        name: "background-clip",
                        initialValue: "border-box",
                        prefix: !1,
                        type: 1,
                        parse: function (A, e) {
                            return e.map((function (A) {
                                if (zA(A)) switch (A.value) {
                                    case"padding-box":
                                        return 1;
                                    case"content-box":
                                        return 2
                                }
                                return 0
                            }))
                        }
                    }, Ue = {name: "background-color", initialValue: "transparent", prefix: !1, type: 3, format: "color"},
                    ye = function (A, e) {
                        var t = he(A, e[0]), n = e[1];
                        return n && $A(n) ? {color: t, stop: n} : {color: t, stop: null}
                    }, xe = function (A, e) {
                        var t = A[0], n = A[A.length - 1];
                        null === t.stop && (t.stop = ee), null === n.stop && (n.stop = ne);
                        for (var r = [], i = 0, a = 0; a < A.length; a++) {
                            var s = A[a].stop;
                            if (null !== s) {
                                var o = ie(s, e);
                                o > i ? r.push(o) : r.push(i), i = o
                            } else r.push(null)
                        }
                        var l = null;
                        for (a = 0; a < r.length; a++) {
                            var c = r[a];
                            if (null === c) null === l && (l = a); else if (null !== l) {
                                for (var u = a - l, h = (c - r[l - 1]) / (u + 1), d = 1; d <= u; d++) r[l + d - 1] = h * d;
                                l = null
                            }
                        }
                        return A.map((function (A, t) {
                            return {color: A.color, stop: Math.max(Math.min(1, r[t] / e), 0)}
                        }))
                    }, Me = function (A, e, t) {
                        var n = "number" == typeof A ? A : function (A, e, t) {
                                var n = e / 2, r = t / 2, i = ie(A[0], e) - n, a = r - ie(A[1], t);
                                return (Math.atan2(a, i) + 2 * Math.PI) % (2 * Math.PI)
                            }(A, e, t), r = Math.abs(e * Math.sin(n)) + Math.abs(t * Math.cos(n)), i = e / 2, a = t / 2,
                            s = r / 2, o = Math.sin(n - Math.PI / 2) * s, l = Math.cos(n - Math.PI / 2) * s;
                        return [r, i - l, i + l, a - o, a + o]
                    }, Fe = function (A, e) {
                        return Math.sqrt(A * A + e * e)
                    }, Se = function (A, e, t, n, r) {
                        return [[0, 0], [0, e], [A, 0], [A, e]].reduce((function (A, e) {
                            var i = e[0], a = e[1], s = Fe(t - i, n - a);
                            return (r ? s < A.optimumDistance : s > A.optimumDistance) ? {
                                optimumCorner: e,
                                optimumDistance: s
                            } : A
                        }), {optimumDistance: r ? 1 / 0 : -1 / 0, optimumCorner: null}).optimumCorner
                    }, be = function (A, e) {
                        var t = ue(180), n = [];
                        return jA(e).forEach((function (e, r) {
                            if (0 === r) {
                                var i = e[0];
                                if (20 === i.type && -1 !== ["top", "left", "right", "bottom"].indexOf(i.value)) return void (t = ce(e));
                                if (le(i)) return void (t = (oe(A, i) + ue(270)) % ue(360))
                            }
                            var a = ye(A, e);
                            n.push(a)
                        })), {angle: t, stops: n, type: 1}
                    }, Qe = "closest-side", Te = "farthest-side", Ie = "closest-corner", Le = "farthest-corner",
                    Re = "circle", He = "ellipse", De = "cover", Pe = "contain", Ne = function (A, e) {
                        var t = 0, n = 3, r = [], i = [];
                        return jA(e).forEach((function (e, a) {
                            var s = !0;
                            if (0 === a ? s = e.reduce((function (A, e) {
                                if (zA(e)) switch (e.value) {
                                    case"center":
                                        return i.push(te), !1;
                                    case"top":
                                    case"left":
                                        return i.push(ee), !1;
                                    case"right":
                                    case"bottom":
                                        return i.push(ne), !1
                                } else if ($A(e) || qA(e)) return i.push(e), !1;
                                return A
                            }), s) : 1 === a && (s = e.reduce((function (A, e) {
                                if (zA(e)) switch (e.value) {
                                    case Re:
                                        return t = 0, !1;
                                    case He:
                                        return t = 1, !1;
                                    case Pe:
                                    case Qe:
                                        return n = 0, !1;
                                    case Te:
                                        return n = 1, !1;
                                    case Ie:
                                        return n = 2, !1;
                                    case De:
                                    case Le:
                                        return n = 3, !1
                                } else if (qA(e) || $A(e)) return Array.isArray(n) || (n = []), n.push(e), !1;
                                return A
                            }), s)), s) {
                                var o = ye(A, e);
                                r.push(o)
                            }
                        })), {size: n, shape: t, stops: r, position: i, type: 2}
                    }, Oe = function (A, e) {
                        if (22 === e.type) {
                            var t = {url: e.value, type: 0};
                            return A.cache.addImage(e.value), t
                        }
                        if (18 === e.type) {
                            var n = Ve[e.name];
                            if (void 0 === n) throw new Error('Attempting to parse an unsupported image function "' + e.name + '"');
                            return n(A, e.values)
                        }
                        throw new Error("Unsupported image type " + e.type)
                    };
                var Ge, Ve = {
                    "linear-gradient": function (A, e) {
                        var t = ue(180), n = [];
                        return jA(e).forEach((function (e, r) {
                            if (0 === r) {
                                var i = e[0];
                                if (20 === i.type && "to" === i.value) return void (t = ce(e));
                                if (le(i)) return void (t = oe(A, i))
                            }
                            var a = ye(A, e);
                            n.push(a)
                        })), {angle: t, stops: n, type: 1}
                    },
                    "-moz-linear-gradient": be,
                    "-ms-linear-gradient": be,
                    "-o-linear-gradient": be,
                    "-webkit-linear-gradient": be,
                    "radial-gradient": function (A, e) {
                        var t = 0, n = 3, r = [], i = [];
                        return jA(e).forEach((function (e, a) {
                            var s = !0;
                            if (0 === a) {
                                var o = !1;
                                s = e.reduce((function (A, e) {
                                    if (o) if (zA(e)) switch (e.value) {
                                        case"center":
                                            return i.push(te), A;
                                        case"top":
                                        case"left":
                                            return i.push(ee), A;
                                        case"right":
                                        case"bottom":
                                            return i.push(ne), A
                                    } else ($A(e) || qA(e)) && i.push(e); else if (zA(e)) switch (e.value) {
                                        case Re:
                                            return t = 0, !1;
                                        case He:
                                            return t = 1, !1;
                                        case"at":
                                            return o = !0, !1;
                                        case Qe:
                                            return n = 0, !1;
                                        case De:
                                        case Te:
                                            return n = 1, !1;
                                        case Pe:
                                        case Ie:
                                            return n = 2, !1;
                                        case Le:
                                            return n = 3, !1
                                    } else if (qA(e) || $A(e)) return Array.isArray(n) || (n = []), n.push(e), !1;
                                    return A
                                }), s)
                            }
                            if (s) {
                                var l = ye(A, e);
                                r.push(l)
                            }
                        })), {size: n, shape: t, stops: r, position: i, type: 2}
                    },
                    "-moz-radial-gradient": Ne,
                    "-ms-radial-gradient": Ne,
                    "-o-radial-gradient": Ne,
                    "-webkit-radial-gradient": Ne,
                    "-webkit-gradient": function (A, e) {
                        var t = ue(180), n = [], r = 1;
                        return jA(e).forEach((function (e, t) {
                            var i = e[0];
                            if (0 === t) {
                                if (zA(i) && "linear" === i.value) return void (r = 1);
                                if (zA(i) && "radial" === i.value) return void (r = 2)
                            }
                            if (18 === i.type) if ("from" === i.name) {
                                var a = he(A, i.values[0]);
                                n.push({stop: ee, color: a})
                            } else if ("to" === i.name) a = he(A, i.values[0]), n.push({
                                stop: ne,
                                color: a
                            }); else if ("color-stop" === i.name) {
                                var s = i.values.filter(JA);
                                if (2 === s.length) {
                                    a = he(A, s[1]);
                                    var o = s[0];
                                    kA(o) && n.push({
                                        stop: {type: 16, number: 100 * o.number, flags: o.flags},
                                        color: a
                                    })
                                }
                            }
                        })), 1 === r ? {angle: (t + ue(180)) % ue(360), stops: n, type: r} : {
                            size: 3,
                            shape: 0,
                            stops: n,
                            position: [],
                            type: r
                        }
                    }
                }, Ke = {
                    name: "background-image", initialValue: "none", type: 1, prefix: !1, parse: function (A, e) {
                        if (0 === e.length) return [];
                        var t = e[0];
                        return 20 === t.type && "none" === t.value ? [] : e.filter((function (A) {
                            return JA(A) && function (A) {
                                return !(20 === A.type && "none" === A.value || 18 === A.type && !Ve[A.name])
                            }(A)
                        })).map((function (e) {
                            return Oe(A, e)
                        }))
                    }
                }, ke = {
                    name: "background-origin",
                    initialValue: "border-box",
                    prefix: !1,
                    type: 1,
                    parse: function (A, e) {
                        return e.map((function (A) {
                            if (zA(A)) switch (A.value) {
                                case"padding-box":
                                    return 1;
                                case"content-box":
                                    return 2
                            }
                            return 0
                        }))
                    }
                }, ze = {
                    name: "background-position",
                    initialValue: "0% 0%",
                    type: 1,
                    prefix: !1,
                    parse: function (A, e) {
                        return jA(e).map((function (A) {
                            return A.filter($A)
                        })).map(Ae)
                    }
                }, We = {
                    name: "background-repeat",
                    initialValue: "repeat",
                    prefix: !1,
                    type: 1,
                    parse: function (A, e) {
                        return jA(e).map((function (A) {
                            return A.filter(zA).map((function (A) {
                                return A.value
                            })).join(" ")
                        })).map(Xe)
                    }
                }, Xe = function (A) {
                    switch (A) {
                        case"no-repeat":
                            return 1;
                        case"repeat-x":
                        case"repeat no-repeat":
                            return 2;
                        case"repeat-y":
                        case"no-repeat repeat":
                            return 3;
                        default:
                            return 0
                    }
                };
                !function (A) {
                    A.AUTO = "auto", A.CONTAIN = "contain", A.COVER = "cover"
                }(Ge || (Ge = {}));
                var Ye, Je = {
                        name: "background-size", initialValue: "0", prefix: !1, type: 1, parse: function (A, e) {
                            return jA(e).map((function (A) {
                                return A.filter(je)
                            }))
                        }
                    }, je = function (A) {
                        return zA(A) || $A(A)
                    }, Ze = function (A) {
                        return {
                            name: "border-" + A + "-color",
                            initialValue: "transparent",
                            prefix: !1,
                            type: 3,
                            format: "color"
                        }
                    }, qe = Ze("top"), $e = Ze("right"), At = Ze("bottom"), et = Ze("left"), tt = function (A) {
                        return {
                            name: "border-radius-" + A,
                            initialValue: "0 0",
                            prefix: !1,
                            type: 1,
                            parse: function (A, e) {
                                return Ae(e.filter($A))
                            }
                        }
                    }, nt = tt("top-left"), rt = tt("top-right"), it = tt("bottom-right"), at = tt("bottom-left"),
                    st = function (A) {
                        return {
                            name: "border-" + A + "-style",
                            initialValue: "solid",
                            prefix: !1,
                            type: 2,
                            parse: function (A, e) {
                                switch (e) {
                                    case"none":
                                        return 0;
                                    case"dashed":
                                        return 2;
                                    case"dotted":
                                        return 3;
                                    case"double":
                                        return 4
                                }
                                return 1
                            }
                        }
                    }, ot = st("top"), lt = st("right"), ct = st("bottom"), ut = st("left"), ht = function (A) {
                        return {
                            name: "border-" + A + "-width",
                            initialValue: "0",
                            type: 0,
                            prefix: !1,
                            parse: function (A, e) {
                                return KA(e) ? e.number : 0
                            }
                        }
                    }, dt = ht("top"), pt = ht("right"), ft = ht("bottom"), gt = ht("left"),
                    mt = {name: "color", initialValue: "transparent", prefix: !1, type: 3, format: "color"}, Bt = {
                        name: "direction", initialValue: "ltr", prefix: !1, type: 2, parse: function (A, e) {
                            return "rtl" === e ? 1 : 0
                        }
                    }, wt = {
                        name: "display", initialValue: "inline-block", prefix: !1, type: 1, parse: function (A, e) {
                            return e.filter(zA).reduce((function (A, e) {
                                return A | vt(e.value)
                            }), 0)
                        }
                    }, vt = function (A) {
                        switch (A) {
                            case"block":
                            case"-webkit-box":
                                return 2;
                            case"inline":
                                return 4;
                            case"run-in":
                                return 8;
                            case"flow":
                                return 16;
                            case"flow-root":
                                return 32;
                            case"table":
                                return 64;
                            case"flex":
                            case"-webkit-flex":
                                return 128;
                            case"grid":
                            case"-ms-grid":
                                return 256;
                            case"ruby":
                                return 512;
                            case"subgrid":
                                return 1024;
                            case"list-item":
                                return 2048;
                            case"table-row-group":
                                return 4096;
                            case"table-header-group":
                                return 8192;
                            case"table-footer-group":
                                return 16384;
                            case"table-row":
                                return 32768;
                            case"table-cell":
                                return 65536;
                            case"table-column-group":
                                return 131072;
                            case"table-column":
                                return 262144;
                            case"table-caption":
                                return 524288;
                            case"ruby-base":
                                return 1048576;
                            case"ruby-text":
                                return 2097152;
                            case"ruby-base-container":
                                return 4194304;
                            case"ruby-text-container":
                                return 8388608;
                            case"contents":
                                return 16777216;
                            case"inline-block":
                                return 33554432;
                            case"inline-list-item":
                                return 67108864;
                            case"inline-table":
                                return 134217728;
                            case"inline-flex":
                                return 268435456;
                            case"inline-grid":
                                return 536870912
                        }
                        return 0
                    }, _t = {
                        name: "float", initialValue: "none", prefix: !1, type: 2, parse: function (A, e) {
                            switch (e) {
                                case"left":
                                    return 1;
                                case"right":
                                    return 2;
                                case"inline-start":
                                    return 3;
                                case"inline-end":
                                    return 4
                            }
                            return 0
                        }
                    }, Ct = {
                        name: "letter-spacing", initialValue: "0", prefix: !1, type: 0, parse: function (A, e) {
                            return 20 === e.type && "normal" === e.value ? 0 : 17 === e.type || 15 === e.type ? e.number : 0
                        }
                    };
                !function (A) {
                    A.NORMAL = "normal", A.STRICT = "strict"
                }(Ye || (Ye = {}));
                var Et, Ut = {
                    name: "line-break", initialValue: "normal", prefix: !1, type: 2, parse: function (A, e) {
                        return "strict" === e ? Ye.STRICT : Ye.NORMAL
                    }
                }, yt = {name: "line-height", initialValue: "normal", prefix: !1, type: 4}, xt = function (A, e) {
                    return zA(A) && "normal" === A.value ? 1.2 * e : 17 === A.type ? e * A.number : $A(A) ? ie(A, e) : e
                }, Mt = {
                    name: "list-style-image", initialValue: "none", type: 0, prefix: !1, parse: function (A, e) {
                        return 20 === e.type && "none" === e.value ? null : Oe(A, e)
                    }
                }, Ft = {
                    name: "list-style-position",
                    initialValue: "outside",
                    prefix: !1,
                    type: 2,
                    parse: function (A, e) {
                        return "inside" === e ? 0 : 1
                    }
                }, St = {
                    name: "list-style-type", initialValue: "none", prefix: !1, type: 2, parse: function (A, e) {
                        switch (e) {
                            case"disc":
                                return 0;
                            case"circle":
                                return 1;
                            case"square":
                                return 2;
                            case"decimal":
                                return 3;
                            case"cjk-decimal":
                                return 4;
                            case"decimal-leading-zero":
                                return 5;
                            case"lower-roman":
                                return 6;
                            case"upper-roman":
                                return 7;
                            case"lower-greek":
                                return 8;
                            case"lower-alpha":
                                return 9;
                            case"upper-alpha":
                                return 10;
                            case"arabic-indic":
                                return 11;
                            case"armenian":
                                return 12;
                            case"bengali":
                                return 13;
                            case"cambodian":
                                return 14;
                            case"cjk-earthly-branch":
                                return 15;
                            case"cjk-heavenly-stem":
                                return 16;
                            case"cjk-ideographic":
                                return 17;
                            case"devanagari":
                                return 18;
                            case"ethiopic-numeric":
                                return 19;
                            case"georgian":
                                return 20;
                            case"gujarati":
                                return 21;
                            case"gurmukhi":
                            case"hebrew":
                                return 22;
                            case"hiragana":
                                return 23;
                            case"hiragana-iroha":
                                return 24;
                            case"japanese-formal":
                                return 25;
                            case"japanese-informal":
                                return 26;
                            case"kannada":
                                return 27;
                            case"katakana":
                                return 28;
                            case"katakana-iroha":
                                return 29;
                            case"khmer":
                                return 30;
                            case"korean-hangul-formal":
                                return 31;
                            case"korean-hanja-formal":
                                return 32;
                            case"korean-hanja-informal":
                                return 33;
                            case"lao":
                                return 34;
                            case"lower-armenian":
                                return 35;
                            case"malayalam":
                                return 36;
                            case"mongolian":
                                return 37;
                            case"myanmar":
                                return 38;
                            case"oriya":
                                return 39;
                            case"persian":
                                return 40;
                            case"simp-chinese-formal":
                                return 41;
                            case"simp-chinese-informal":
                                return 42;
                            case"tamil":
                                return 43;
                            case"telugu":
                                return 44;
                            case"thai":
                                return 45;
                            case"tibetan":
                                return 46;
                            case"trad-chinese-formal":
                                return 47;
                            case"trad-chinese-informal":
                                return 48;
                            case"upper-armenian":
                                return 49;
                            case"disclosure-open":
                                return 50;
                            case"disclosure-closed":
                                return 51;
                            default:
                                return -1
                        }
                    }
                }, bt = function (A) {
                    return {name: "margin-" + A, initialValue: "0", prefix: !1, type: 4}
                }, Qt = bt("top"), Tt = bt("right"), It = bt("bottom"), Lt = bt("left"), Rt = {
                    name: "overflow", initialValue: "visible", prefix: !1, type: 1, parse: function (A, e) {
                        return e.filter(zA).map((function (A) {
                            switch (A.value) {
                                case"hidden":
                                    return 1;
                                case"scroll":
                                    return 2;
                                case"clip":
                                    return 3;
                                case"auto":
                                    return 4;
                                default:
                                    return 0
                            }
                        }))
                    }
                }, Ht = {
                    name: "overflow-wrap", initialValue: "normal", prefix: !1, type: 2, parse: function (A, e) {
                        return "break-word" === e ? "break-word" : "normal"
                    }
                }, Dt = function (A) {
                    return {name: "padding-" + A, initialValue: "0", prefix: !1, type: 3, format: "length-percentage"}
                }, Pt = Dt("top"), Nt = Dt("right"), Ot = Dt("bottom"), Gt = Dt("left"), Vt = {
                    name: "text-align", initialValue: "left", prefix: !1, type: 2, parse: function (A, e) {
                        switch (e) {
                            case"right":
                                return 2;
                            case"center":
                            case"justify":
                                return 1;
                            default:
                                return 0
                        }
                    }
                }, Kt = {
                    name: "position", initialValue: "static", prefix: !1, type: 2, parse: function (A, e) {
                        switch (e) {
                            case"relative":
                                return 1;
                            case"absolute":
                                return 2;
                            case"fixed":
                                return 3;
                            case"sticky":
                                return 4
                        }
                        return 0
                    }
                }, kt = {
                    name: "text-shadow", initialValue: "none", type: 1, prefix: !1, parse: function (A, e) {
                        return 1 === e.length && XA(e[0], "none") ? [] : jA(e).map((function (e) {
                            for (var t = {
                                color: Ce.TRANSPARENT,
                                offsetX: ee,
                                offsetY: ee,
                                blur: ee
                            }, n = 0, r = 0; r < e.length; r++) {
                                var i = e[r];
                                qA(i) ? (0 === n ? t.offsetX = i : 1 === n ? t.offsetY = i : t.blur = i, n++) : t.color = he(A, i)
                            }
                            return t
                        }))
                    }
                }, zt = {
                    name: "text-transform", initialValue: "none", prefix: !1, type: 2, parse: function (A, e) {
                        switch (e) {
                            case"uppercase":
                                return 2;
                            case"lowercase":
                                return 1;
                            case"capitalize":
                                return 3
                        }
                        return 0
                    }
                }, Wt = {
                    name: "transform", initialValue: "none", prefix: !0, type: 0, parse: function (A, e) {
                        if (20 === e.type && "none" === e.value) return null;
                        if (18 === e.type) {
                            var t = Xt[e.name];
                            if (void 0 === t) throw new Error('Attempting to parse an unsupported transform function "' + e.name + '"');
                            return t(e.values)
                        }
                        return null
                    }
                }, Xt = {
                    matrix: function (A) {
                        var e = A.filter((function (A) {
                            return 17 === A.type
                        })).map((function (A) {
                            return A.number
                        }));
                        return 6 === e.length ? e : null
                    }, matrix3d: function (A) {
                        var e = A.filter((function (A) {
                            return 17 === A.type
                        })).map((function (A) {
                            return A.number
                        })), t = e[0], n = e[1];
                        e[2], e[3];
                        var r = e[4], i = e[5];
                        e[6], e[7], e[8], e[9], e[10], e[11];
                        var a = e[12], s = e[13];
                        return e[14], e[15], 16 === e.length ? [t, n, r, i, a, s] : null
                    }
                }, Yt = {type: 16, number: 50, flags: 4}, Jt = [Yt, Yt], jt = {
                    name: "transform-origin",
                    initialValue: "50% 50%",
                    prefix: !0,
                    type: 1,
                    parse: function (A, e) {
                        var t = e.filter($A);
                        return 2 !== t.length ? Jt : [t[0], t[1]]
                    }
                }, Zt = {
                    name: "visible", initialValue: "none", prefix: !1, type: 2, parse: function (A, e) {
                        switch (e) {
                            case"hidden":
                                return 1;
                            case"collapse":
                                return 2;
                            default:
                                return 0
                        }
                    }
                };
                !function (A) {
                    A.NORMAL = "normal", A.BREAK_ALL = "break-all", A.KEEP_ALL = "keep-all"
                }(Et || (Et = {}));
                for (var qt = {
                    name: "word-break", initialValue: "normal", prefix: !1, type: 2, parse: function (A, e) {
                        switch (e) {
                            case"break-all":
                                return Et.BREAK_ALL;
                            case"keep-all":
                                return Et.KEEP_ALL;
                            default:
                                return Et.NORMAL
                        }
                    }
                }, $t = {
                    name: "z-index", initialValue: "auto", prefix: !1, type: 0, parse: function (A, e) {
                        if (20 === e.type) return {auto: !0, order: 0};
                        if (kA(e)) return {auto: !1, order: e.number};
                        throw new Error("Invalid z-index number parsed")
                    }
                }, An = {
                    name: "time", parse: function (A, e) {
                        if (15 === e.type) switch (e.unit.toLowerCase()) {
                            case"s":
                                return 1e3 * e.number;
                            case"ms":
                                return e.number
                        }
                        throw new Error("Unsupported time type")
                    }
                }, en = {
                    name: "opacity", initialValue: "1", type: 0, prefix: !1, parse: function (A, e) {
                        return kA(e) ? e.number : 1
                    }
                }, tn = {
                    name: "text-decoration-color",
                    initialValue: "transparent",
                    prefix: !1,
                    type: 3,
                    format: "color"
                }, nn = {
                    name: "text-decoration-line",
                    initialValue: "none",
                    prefix: !1,
                    type: 1,
                    parse: function (A, e) {
                        return e.filter(zA).map((function (A) {
                            switch (A.value) {
                                case"underline":
                                    return 1;
                                case"overline":
                                    return 2;
                                case"line-through":
                                    return 3;
                                case"none":
                                    return 4
                            }
                            return 0
                        })).filter((function (A) {
                            return 0 !== A
                        }))
                    }
                }, rn = {
                    name: "font-family", initialValue: "", prefix: !1, type: 1, parse: function (A, e) {
                        var t = [], n = [];
                        return e.forEach((function (A) {
                            switch (A.type) {
                                case 20:
                                case 0:
                                    t.push(A.value);
                                    break;
                                case 17:
                                    t.push(A.number.toString());
                                    break;
                                case 4:
                                    n.push(t.join(" ")), t.length = 0
                            }
                        })), t.length && n.push(t.join(" ")), n.map((function (A) {
                            return -1 === A.indexOf(" ") ? A : "'" + A + "'"
                        }))
                    }
                }, an = {
                    name: "font-size",
                    initialValue: "0",
                    prefix: !1,
                    type: 3,
                    format: "length"
                }, sn = {
                    name: "font-weight", initialValue: "normal", type: 0, prefix: !1, parse: function (A, e) {
                        return kA(e) ? e.number : zA(e) && "bold" === e.value ? 700 : 400
                    }
                }, on = {
                    name: "font-variant", initialValue: "none", type: 1, prefix: !1, parse: function (A, e) {
                        return e.filter(zA).map((function (A) {
                            return A.value
                        }))
                    }
                }, ln = {
                    name: "font-style", initialValue: "normal", prefix: !1, type: 2, parse: function (A, e) {
                        switch (e) {
                            case"oblique":
                                return "oblique";
                            case"italic":
                                return "italic";
                            default:
                                return "normal"
                        }
                    }
                }, cn = function (A, e) {
                    return 0 != (A & e)
                }, un = {
                    name: "content", initialValue: "none", type: 1, prefix: !1, parse: function (A, e) {
                        if (0 === e.length) return [];
                        var t = e[0];
                        return 20 === t.type && "none" === t.value ? [] : e
                    }
                }, hn = {
                    name: "counter-increment", initialValue: "none", prefix: !0, type: 1, parse: function (A, e) {
                        if (0 === e.length) return null;
                        var t = e[0];
                        if (20 === t.type && "none" === t.value) return null;
                        for (var n = [], r = e.filter(YA), i = 0; i < r.length; i++) {
                            var a = r[i], s = r[i + 1];
                            if (20 === a.type) {
                                var o = s && kA(s) ? s.number : 1;
                                n.push({counter: a.value, increment: o})
                            }
                        }
                        return n
                    }
                }, dn = {
                    name: "counter-reset", initialValue: "none", prefix: !0, type: 1, parse: function (A, e) {
                        if (0 === e.length) return [];
                        for (var t = [], n = e.filter(YA), r = 0; r < n.length; r++) {
                            var i = n[r], a = n[r + 1];
                            if (zA(i) && "none" !== i.value) {
                                var s = a && kA(a) ? a.number : 0;
                                t.push({counter: i.value, reset: s})
                            }
                        }
                        return t
                    }
                }, pn = {
                    name: "duration", initialValue: "0s", prefix: !1, type: 1, parse: function (A, e) {
                        return e.filter(KA).map((function (e) {
                            return An.parse(A, e)
                        }))
                    }
                }, fn = {
                    name: "quotes", initialValue: "none", prefix: !0, type: 1, parse: function (A, e) {
                        if (0 === e.length) return null;
                        var t = e[0];
                        if (20 === t.type && "none" === t.value) return null;
                        var n = [], r = e.filter(WA);
                        if (r.length % 2 != 0) return null;
                        for (var i = 0; i < r.length; i += 2) {
                            var a = r[i].value, s = r[i + 1].value;
                            n.push({open: a, close: s})
                        }
                        return n
                    }
                }, gn = function (A, e, t) {
                    if (!A) return "";
                    var n = A[Math.min(e, A.length - 1)];
                    return n ? t ? n.open : n.close : ""
                }, mn = {
                    name: "box-shadow", initialValue: "none", type: 1, prefix: !1, parse: function (A, e) {
                        return 1 === e.length && XA(e[0], "none") ? [] : jA(e).map((function (e) {
                            for (var t = {
                                color: 255,
                                offsetX: ee,
                                offsetY: ee,
                                blur: ee,
                                spread: ee,
                                inset: !1
                            }, n = 0, r = 0; r < e.length; r++) {
                                var i = e[r];
                                XA(i, "inset") ? t.inset = !0 : qA(i) ? (0 === n ? t.offsetX = i : 1 === n ? t.offsetY = i : 2 === n ? t.blur = i : t.spread = i, n++) : t.color = he(A, i)
                            }
                            return t
                        }))
                    }
                }, Bn = {
                    name: "paint-order", initialValue: "normal", prefix: !1, type: 1, parse: function (A, e) {
                        var t = [];
                        return e.filter(zA).forEach((function (A) {
                            switch (A.value) {
                                case"stroke":
                                    t.push(1);
                                    break;
                                case"fill":
                                    t.push(0);
                                    break;
                                case"markers":
                                    t.push(2)
                            }
                        })), [0, 1, 2].forEach((function (A) {
                            -1 === t.indexOf(A) && t.push(A)
                        })), t
                    }
                }, wn = {
                    name: "-webkit-text-stroke-color",
                    initialValue: "currentcolor",
                    prefix: !1,
                    type: 3,
                    format: "color"
                }, vn = {
                    name: "-webkit-text-stroke-width",
                    initialValue: "0",
                    type: 0,
                    prefix: !1,
                    parse: function (A, e) {
                        return KA(e) ? e.number : 0
                    }
                }, _n = function () {
                    function A(A, e) {
                        var t, n;
                        this.animationDuration = Un(A, pn, e.animationDuration), this.backgroundClip = Un(A, Ee, e.backgroundClip), this.backgroundColor = Un(A, Ue, e.backgroundColor), this.backgroundImage = Un(A, Ke, e.backgroundImage), this.backgroundOrigin = Un(A, ke, e.backgroundOrigin), this.backgroundPosition = Un(A, ze, e.backgroundPosition), this.backgroundRepeat = Un(A, We, e.backgroundRepeat), this.backgroundSize = Un(A, Je, e.backgroundSize), this.borderTopColor = Un(A, qe, e.borderTopColor), this.borderRightColor = Un(A, $e, e.borderRightColor), this.borderBottomColor = Un(A, At, e.borderBottomColor), this.borderLeftColor = Un(A, et, e.borderLeftColor), this.borderTopLeftRadius = Un(A, nt, e.borderTopLeftRadius), this.borderTopRightRadius = Un(A, rt, e.borderTopRightRadius), this.borderBottomRightRadius = Un(A, it, e.borderBottomRightRadius), this.borderBottomLeftRadius = Un(A, at, e.borderBottomLeftRadius), this.borderTopStyle = Un(A, ot, e.borderTopStyle), this.borderRightStyle = Un(A, lt, e.borderRightStyle), this.borderBottomStyle = Un(A, ct, e.borderBottomStyle), this.borderLeftStyle = Un(A, ut, e.borderLeftStyle), this.borderTopWidth = Un(A, dt, e.borderTopWidth), this.borderRightWidth = Un(A, pt, e.borderRightWidth), this.borderBottomWidth = Un(A, ft, e.borderBottomWidth), this.borderLeftWidth = Un(A, gt, e.borderLeftWidth), this.boxShadow = Un(A, mn, e.boxShadow), this.color = Un(A, mt, e.color), this.direction = Un(A, Bt, e.direction), this.display = Un(A, wt, e.display), this.float = Un(A, _t, e.cssFloat), this.fontFamily = Un(A, rn, e.fontFamily), this.fontSize = Un(A, an, e.fontSize), this.fontStyle = Un(A, ln, e.fontStyle), this.fontVariant = Un(A, on, e.fontVariant), this.fontWeight = Un(A, sn, e.fontWeight), this.letterSpacing = Un(A, Ct, e.letterSpacing), this.lineBreak = Un(A, Ut, e.lineBreak), this.lineHeight = Un(A, yt, e.lineHeight), this.listStyleImage = Un(A, Mt, e.listStyleImage), this.listStylePosition = Un(A, Ft, e.listStylePosition), this.listStyleType = Un(A, St, e.listStyleType), this.marginTop = Un(A, Qt, e.marginTop), this.marginRight = Un(A, Tt, e.marginRight), this.marginBottom = Un(A, It, e.marginBottom), this.marginLeft = Un(A, Lt, e.marginLeft), this.opacity = Un(A, en, e.opacity);
                        var r = Un(A, Rt, e.overflow);
                        this.overflowX = r[0], this.overflowY = r[r.length > 1 ? 1 : 0], this.overflowWrap = Un(A, Ht, e.overflowWrap), this.paddingTop = Un(A, Pt, e.paddingTop), this.paddingRight = Un(A, Nt, e.paddingRight), this.paddingBottom = Un(A, Ot, e.paddingBottom), this.paddingLeft = Un(A, Gt, e.paddingLeft), this.paintOrder = Un(A, Bn, e.paintOrder), this.position = Un(A, Kt, e.position), this.textAlign = Un(A, Vt, e.textAlign), this.textDecorationColor = Un(A, tn, null !== (t = e.textDecorationColor) && void 0 !== t ? t : e.color), this.textDecorationLine = Un(A, nn, null !== (n = e.textDecorationLine) && void 0 !== n ? n : e.textDecoration), this.textShadow = Un(A, kt, e.textShadow), this.textTransform = Un(A, zt, e.textTransform), this.transform = Un(A, Wt, e.transform), this.transformOrigin = Un(A, jt, e.transformOrigin), this.visibility = Un(A, Zt, e.visibility), this.webkitTextStrokeColor = Un(A, wn, e.webkitTextStrokeColor), this.webkitTextStrokeWidth = Un(A, vn, e.webkitTextStrokeWidth), this.wordBreak = Un(A, qt, e.wordBreak), this.zIndex = Un(A, $t, e.zIndex)
                    }

                    return A.prototype.isVisible = function () {
                        return this.display > 0 && this.opacity > 0 && 0 === this.visibility
                    }, A.prototype.isTransparent = function () {
                        return de(this.backgroundColor)
                    }, A.prototype.isTransformed = function () {
                        return null !== this.transform
                    }, A.prototype.isPositioned = function () {
                        return 0 !== this.position
                    }, A.prototype.isPositionedWithZIndex = function () {
                        return this.isPositioned() && !this.zIndex.auto
                    }, A.prototype.isFloating = function () {
                        return 0 !== this.float
                    }, A.prototype.isInlineLevel = function () {
                        return cn(this.display, 4) || cn(this.display, 33554432) || cn(this.display, 268435456) || cn(this.display, 536870912) || cn(this.display, 67108864) || cn(this.display, 134217728)
                    }, A
                }(), Cn = function (A, e) {
                    this.content = Un(A, un, e.content), this.quotes = Un(A, fn, e.quotes)
                }, En = function (A, e) {
                    this.counterIncrement = Un(A, hn, e.counterIncrement), this.counterReset = Un(A, dn, e.counterReset)
                }, Un = function (A, e, t) {
                    var n = new GA, r = null != t ? t.toString() : e.initialValue;
                    n.write(r);
                    var i = new VA(n.read());
                    switch (e.type) {
                        case 2:
                            var a = i.parseComponentValue();
                            return e.parse(A, zA(a) ? a.value : e.initialValue);
                        case 0:
                            return e.parse(A, i.parseComponentValue());
                        case 1:
                            return e.parse(A, i.parseComponentValues());
                        case 4:
                            return i.parseComponentValue();
                        case 3:
                            switch (e.format) {
                                case"angle":
                                    return oe(A, i.parseComponentValue());
                                case"color":
                                    return he(A, i.parseComponentValue());
                                case"image":
                                    return Oe(A, i.parseComponentValue());
                                case"length":
                                    var s = i.parseComponentValue();
                                    return qA(s) ? s : ee;
                                case"length-percentage":
                                    var o = i.parseComponentValue();
                                    return $A(o) ? o : ee;
                                case"time":
                                    return An.parse(A, i.parseComponentValue())
                            }
                    }
                }, yn = function (A, e) {
                    var t = function (A) {
                        switch (A.getAttribute("data-html2canvas-debug")) {
                            case"all":
                                return 1;
                            case"clone":
                                return 2;
                            case"parse":
                                return 3;
                            case"render":
                                return 4;
                            default:
                                return 0
                        }
                    }(A);
                    return 1 === t || e === t
                }, xn = function (A, e) {
                    this.context = A, this.textNodes = [], this.elements = [], this.flags = 0, yn(e, 3), this.styles = new _n(A, window.getComputedStyle(e, null)), br(e) && (this.styles.animationDuration.some((function (A) {
                        return A > 0
                    })) && (e.style.animationDuration = "0s"), null !== this.styles.transform && (e.style.transform = "none")), this.bounds = s(this.context, e), yn(e, 4) && (this.flags |= 16)
                }, Mn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Fn = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), Sn = 0; Sn < 64; Sn++) Fn[Mn.charCodeAt(Sn)] = Sn;
                for (var bn = function (A, e, t) {
                    return A.slice ? A.slice(e, t) : new Uint16Array(Array.prototype.slice.call(A, e, t))
                }, Qn = function () {
                    function A(A, e, t, n, r, i) {
                        this.initialValue = A, this.errorValue = e, this.highStart = t, this.highValueIndex = n, this.index = r, this.data = i
                    }

                    return A.prototype.get = function (A) {
                        var e;
                        if (A >= 0) {
                            if (A < 55296 || A > 56319 && A <= 65535) return e = ((e = this.index[A >> 5]) << 2) + (31 & A), this.data[e];
                            if (A <= 65535) return e = ((e = this.index[2048 + (A - 55296 >> 5)]) << 2) + (31 & A), this.data[e];
                            if (A < this.highStart) return e = 2080 + (A >> 11), e = this.index[e], e += A >> 5 & 63, e = ((e = this.index[e]) << 2) + (31 & A), this.data[e];
                            if (A <= 1114111) return this.data[this.highValueIndex]
                        }
                        return this.errorValue
                    }, A
                }(), Tn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", In = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), Ln = 0; Ln < 64; Ln++) In[Tn.charCodeAt(Ln)] = Ln;
                var Rn, Hn = 8, Dn = 9, Pn = 11, Nn = 12, On = function () {
                        for (var A = [], e = 0; e < arguments.length; e++) A[e] = arguments[e];
                        if (String.fromCodePoint) return String.fromCodePoint.apply(String, A);
                        var t = A.length;
                        if (!t) return "";
                        for (var n = [], r = -1, i = ""; ++r < t;) {
                            var a = A[r];
                            a <= 65535 ? n.push(a) : (a -= 65536, n.push(55296 + (a >> 10), a % 1024 + 56320)), (r + 1 === t || n.length > 16384) && (i += String.fromCharCode.apply(String, n), n.length = 0)
                        }
                        return i
                    }, Gn = function (A, e) {
                        var t, n, r, i = function (A) {
                                var e, t, n, r, i, a = .75 * A.length, s = A.length, o = 0;
                                "=" === A[A.length - 1] && (a--, "=" === A[A.length - 2] && a--);
                                var l = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && void 0 !== Uint8Array.prototype.slice ? new ArrayBuffer(a) : new Array(a),
                                    c = Array.isArray(l) ? l : new Uint8Array(l);
                                for (e = 0; e < s; e += 4) t = Fn[A.charCodeAt(e)], n = Fn[A.charCodeAt(e + 1)], r = Fn[A.charCodeAt(e + 2)], i = Fn[A.charCodeAt(e + 3)], c[o++] = t << 2 | n >> 4, c[o++] = (15 & n) << 4 | r >> 2, c[o++] = (3 & r) << 6 | 63 & i;
                                return l
                            }(A), a = Array.isArray(i) ? function (A) {
                                for (var e = A.length, t = [], n = 0; n < e; n += 4) t.push(A[n + 3] << 24 | A[n + 2] << 16 | A[n + 1] << 8 | A[n]);
                                return t
                            }(i) : new Uint32Array(i), s = Array.isArray(i) ? function (A) {
                                for (var e = A.length, t = [], n = 0; n < e; n += 2) t.push(A[n + 1] << 8 | A[n]);
                                return t
                            }(i) : new Uint16Array(i), o = bn(s, 12, a[4] / 2),
                            l = 2 === a[5] ? bn(s, (24 + a[4]) / 2) : (t = a, n = Math.ceil((24 + a[4]) / 4), t.slice ? t.slice(n, r) : new Uint32Array(Array.prototype.slice.call(t, n, r)));
                        return new Qn(a[0], a[1], a[2], a[3], o, l)
                    }("AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA="),
                    Vn = "×", Kn = function (A) {
                        return Gn.get(A)
                    }, kn = function (A, e, t) {
                        var n = t - 2, r = e[n], i = e[t - 1], a = e[t];
                        if (2 === i && 3 === a) return Vn;
                        if (2 === i || 3 === i || 4 === i) return "÷";
                        if (2 === a || 3 === a || 4 === a) return "÷";
                        if (i === Hn && -1 !== [Hn, Dn, Pn, Nn].indexOf(a)) return Vn;
                        if (!(i !== Pn && i !== Dn || a !== Dn && 10 !== a)) return Vn;
                        if ((i === Nn || 10 === i) && 10 === a) return Vn;
                        if (13 === a || 5 === a) return Vn;
                        if (7 === a) return Vn;
                        if (1 === i) return Vn;
                        if (13 === i && 14 === a) {
                            for (; 5 === r;) r = e[--n];
                            if (14 === r) return Vn
                        }
                        if (15 === i && 15 === a) {
                            for (var s = 0; 15 === r;) s++, r = e[--n];
                            if (s % 2 == 0) return Vn
                        }
                        return "÷"
                    }, zn = function (A) {
                        var e = function (A) {
                            for (var e = [], t = 0, n = A.length; t < n;) {
                                var r = A.charCodeAt(t++);
                                if (r >= 55296 && r <= 56319 && t < n) {
                                    var i = A.charCodeAt(t++);
                                    56320 == (64512 & i) ? e.push(((1023 & r) << 10) + (1023 & i) + 65536) : (e.push(r), t--)
                                } else e.push(r)
                            }
                            return e
                        }(A), t = e.length, n = 0, r = 0, i = e.map(Kn);
                        return {
                            next: function () {
                                if (n >= t) return {done: !0, value: null};
                                for (var A = Vn; n < t && (A = kn(0, i, ++n)) === Vn;) ;
                                if (A !== Vn || n === t) {
                                    var a = On.apply(null, e.slice(r, n));
                                    return r = n, {value: a, done: !1}
                                }
                                return {done: !0, value: null}
                            }
                        }
                    }, Wn = function (A) {
                        return 0 === A[0] && 255 === A[1] && 0 === A[2] && 255 === A[3]
                    }, Xn = function (A, e, t, n, r) {
                        var i = "http://www.w3.org/2000/svg", a = document.createElementNS(i, "svg"),
                            s = document.createElementNS(i, "foreignObject");
                        return a.setAttributeNS(null, "width", A.toString()), a.setAttributeNS(null, "height", e.toString()), s.setAttributeNS(null, "width", "100%"), s.setAttributeNS(null, "height", "100%"), s.setAttributeNS(null, "x", t.toString()), s.setAttributeNS(null, "y", n.toString()), s.setAttributeNS(null, "externalResourcesRequired", "true"), a.appendChild(s), s.appendChild(r), a
                    }, Yn = function (A) {
                        return new Promise((function (e, t) {
                            var n = new Image;
                            n.onload = function () {
                                return e(n)
                            }, n.onerror = t, n.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent((new XMLSerializer).serializeToString(A))
                        }))
                    }, Jn = {
                        get SUPPORT_RANGE_BOUNDS() {
                            var A = function (A) {
                                if (A.createRange) {
                                    var e = A.createRange();
                                    if (e.getBoundingClientRect) {
                                        var t = A.createElement("boundtest");
                                        t.style.height = "123px", t.style.display = "block", A.body.appendChild(t), e.selectNode(t);
                                        var n = e.getBoundingClientRect(), r = Math.round(n.height);
                                        if (A.body.removeChild(t), 123 === r) return !0
                                    }
                                }
                                return !1
                            }(document);
                            return Object.defineProperty(Jn, "SUPPORT_RANGE_BOUNDS", {value: A}), A
                        }, get SUPPORT_WORD_BREAKING() {
                            var A = Jn.SUPPORT_RANGE_BOUNDS && function (A) {
                                var e = A.createElement("boundtest");
                                e.style.width = "50px", e.style.display = "block", e.style.fontSize = "12px", e.style.letterSpacing = "0px", e.style.wordSpacing = "0px", A.body.appendChild(e);
                                var t = A.createRange();
                                e.innerHTML = "function" == typeof "".repeat ? "&#128104;".repeat(10) : "";
                                var n = e.firstChild, r = o(n.data).map((function (A) {
                                    return l(A)
                                })), i = 0, a = {}, s = r.every((function (A, e) {
                                    t.setStart(n, i), t.setEnd(n, i + A.length);
                                    var r = t.getBoundingClientRect();
                                    i += A.length;
                                    var s = r.x > a.x || r.y > a.y;
                                    return a = r, 0 === e || s
                                }));
                                return A.body.removeChild(e), s
                            }(document);
                            return Object.defineProperty(Jn, "SUPPORT_WORD_BREAKING", {value: A}), A
                        }, get SUPPORT_SVG_DRAWING() {
                            var A = function (A) {
                                var e = new Image, t = A.createElement("canvas"), n = t.getContext("2d");
                                if (!n) return !1;
                                e.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
                                try {
                                    n.drawImage(e, 0, 0), t.toDataURL()
                                } catch (A) {
                                    return !1
                                }
                                return !0
                            }(document);
                            return Object.defineProperty(Jn, "SUPPORT_SVG_DRAWING", {value: A}), A
                        }, get SUPPORT_FOREIGNOBJECT_DRAWING() {
                            var A = "function" == typeof Array.from && "function" == typeof window.fetch ? function (A) {
                                var e = A.createElement("canvas"), t = 100;
                                e.width = t, e.height = t;
                                var n = e.getContext("2d");
                                if (!n) return Promise.reject(!1);
                                n.fillStyle = "rgb(0, 255, 0)", n.fillRect(0, 0, t, t);
                                var r = new Image, i = e.toDataURL();
                                r.src = i;
                                var a = Xn(t, t, 0, 0, r);
                                return n.fillStyle = "red", n.fillRect(0, 0, t, t), Yn(a).then((function (e) {
                                    n.drawImage(e, 0, 0);
                                    var r = n.getImageData(0, 0, t, t).data;
                                    n.fillStyle = "red", n.fillRect(0, 0, t, t);
                                    var a = A.createElement("div");
                                    return a.style.backgroundImage = "url(" + i + ")", a.style.height = t + "px", Wn(r) ? Yn(Xn(t, t, 0, 0, a)) : Promise.reject(!1)
                                })).then((function (A) {
                                    return n.drawImage(A, 0, 0), Wn(n.getImageData(0, 0, t, t).data)
                                })).catch((function () {
                                    return !1
                                }))
                            }(document) : Promise.resolve(!1);
                            return Object.defineProperty(Jn, "SUPPORT_FOREIGNOBJECT_DRAWING", {value: A}), A
                        }, get SUPPORT_CORS_IMAGES() {
                            var A = void 0 !== (new Image).crossOrigin;
                            return Object.defineProperty(Jn, "SUPPORT_CORS_IMAGES", {value: A}), A
                        }, get SUPPORT_RESPONSE_TYPE() {
                            var A = "string" == typeof (new XMLHttpRequest).responseType;
                            return Object.defineProperty(Jn, "SUPPORT_RESPONSE_TYPE", {value: A}), A
                        }, get SUPPORT_CORS_XHR() {
                            var A = "withCredentials" in new XMLHttpRequest;
                            return Object.defineProperty(Jn, "SUPPORT_CORS_XHR", {value: A}), A
                        }, get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
                            var A = !("undefined" == typeof Intl || !Intl.Segmenter);
                            return Object.defineProperty(Jn, "SUPPORT_NATIVE_TEXT_SEGMENTATION", {value: A}), A
                        }
                    }, jn = function (A, e) {
                        this.text = A, this.bounds = e
                    }, Zn = function (A, e) {
                        var t = e.ownerDocument;
                        if (t) {
                            var n = t.createElement("html2canvaswrapper");
                            n.appendChild(e.cloneNode(!0));
                            var r = e.parentNode;
                            if (r) {
                                r.replaceChild(n, e);
                                var i = s(A, n);
                                return n.firstChild && r.replaceChild(n.firstChild, n), i
                            }
                        }
                        return a.EMPTY
                    }, qn = function (A, e, t) {
                        var n = A.ownerDocument;
                        if (!n) throw new Error("Node has no owner document");
                        var r = n.createRange();
                        return r.setStart(A, e), r.setEnd(A, e + t), r
                    }, $n = function (A) {
                        if (Jn.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
                            var e = new Intl.Segmenter(void 0, {granularity: "grapheme"});
                            return Array.from(e.segment(A)).map((function (A) {
                                return A.segment
                            }))
                        }
                        return function (A) {
                            for (var e, t = zn(A), n = []; !(e = t.next()).done;) e.value && n.push(e.value.slice());
                            return n
                        }(A)
                    }, Ar = function (A, e) {
                        return 0 !== e.letterSpacing ? $n(A) : function (A, e) {
                            if (Jn.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
                                var t = new Intl.Segmenter(void 0, {granularity: "word"});
                                return Array.from(t.segment(A)).map((function (A) {
                                    return A.segment
                                }))
                            }
                            return tr(A, e)
                        }(A, e)
                    }, er = [32, 160, 4961, 65792, 65793, 4153, 4241], tr = function (A, e) {
                        for (var t, n = function (A, e) {
                            var t = o(A), n = iA(t, e), r = n[0], i = n[1], a = n[2], s = t.length, l = 0, c = 0;
                            return {
                                next: function () {
                                    if (c >= s) return {done: !0, value: null};
                                    for (var A = W; c < s && (A = rA(t, i, r, ++c, a)) === W;) ;
                                    if (A !== W || c === s) {
                                        var e = new aA(t, A, l, c);
                                        return l = c, {value: e, done: !1}
                                    }
                                    return {done: !0, value: null}
                                }
                            }
                        }(A, {
                            lineBreak: e.lineBreak,
                            wordBreak: "break-word" === e.overflowWrap ? "break-word" : e.wordBreak
                        }), r = [], i = function () {
                            if (t.value) {
                                var A = t.value.slice(), e = o(A), n = "";
                                e.forEach((function (A) {
                                    -1 === er.indexOf(A) ? n += l(A) : (n.length && r.push(n), r.push(l(A)), n = "")
                                })), n.length && r.push(n)
                            }
                        }; !(t = n.next()).done;) i();
                        return r
                    }, nr = function (A, e, t) {
                        this.text = rr(e.data, t.textTransform), this.textBounds = function (A, e, t, n) {
                            var r = Ar(e, t), i = [], s = 0;
                            return r.forEach((function (e) {
                                if (t.textDecorationLine.length || e.trim().length > 0) if (Jn.SUPPORT_RANGE_BOUNDS) {
                                    var r = qn(n, s, e.length).getClientRects();
                                    if (r.length > 1) {
                                        var o = $n(e), l = 0;
                                        o.forEach((function (e) {
                                            i.push(new jn(e, a.fromDOMRectList(A, qn(n, l + s, e.length).getClientRects()))), l += e.length
                                        }))
                                    } else i.push(new jn(e, a.fromDOMRectList(A, r)))
                                } else {
                                    var c = n.splitText(e.length);
                                    i.push(new jn(e, Zn(A, n))), n = c
                                } else Jn.SUPPORT_RANGE_BOUNDS || (n = n.splitText(e.length));
                                s += e.length
                            })), i
                        }(A, this.text, t, e)
                    }, rr = function (A, e) {
                        switch (e) {
                            case 1:
                                return A.toLowerCase();
                            case 3:
                                return A.replace(ir, ar);
                            case 2:
                                return A.toUpperCase();
                            default:
                                return A
                        }
                    }, ir = /(^|\s|:|-|\(|\))([a-z])/g, ar = function (A, e, t) {
                        return A.length > 0 ? e + t.toUpperCase() : A
                    }, sr = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this;
                            return n.src = t.currentSrc || t.src, n.intrinsicWidth = t.naturalWidth, n.intrinsicHeight = t.naturalHeight, n.context.cache.addImage(n.src), n
                        }

                        return e(t, A), t
                    }(xn), or = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this;
                            return n.canvas = t, n.intrinsicWidth = t.width, n.intrinsicHeight = t.height, n
                        }

                        return e(t, A), t
                    }(xn), lr = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this, r = new XMLSerializer, i = s(e, t);
                            return t.setAttribute("width", i.width + "px"), t.setAttribute("height", i.height + "px"), n.svg = "data:image/svg+xml," + encodeURIComponent(r.serializeToString(t)), n.intrinsicWidth = t.width.baseVal.value, n.intrinsicHeight = t.height.baseVal.value, n.context.cache.addImage(n.svg), n
                        }

                        return e(t, A), t
                    }(xn), cr = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this;
                            return n.value = t.value, n
                        }

                        return e(t, A), t
                    }(xn), ur = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this;
                            return n.start = t.start, n.reversed = "boolean" == typeof t.reversed && !0 === t.reversed, n
                        }

                        return e(t, A), t
                    }(xn), hr = [{type: 15, flags: 0, unit: "px", number: 3}], dr = [{type: 16, flags: 0, number: 50}],
                    pr = "checkbox", fr = "radio", gr = "password", mr = 707406591, Br = function (A) {
                        function t(e, t) {
                            var n, r, i, s = A.call(this, e, t) || this;
                            switch (s.type = t.type.toLowerCase(), s.checked = t.checked, s.value = 0 === (i = (r = t).type === gr ? new Array(r.value.length + 1).join("•") : r.value).length ? r.placeholder || "" : i, s.type !== pr && s.type !== fr || (s.styles.backgroundColor = 3739148031, s.styles.borderTopColor = s.styles.borderRightColor = s.styles.borderBottomColor = s.styles.borderLeftColor = 2779096575, s.styles.borderTopWidth = s.styles.borderRightWidth = s.styles.borderBottomWidth = s.styles.borderLeftWidth = 1, s.styles.borderTopStyle = s.styles.borderRightStyle = s.styles.borderBottomStyle = s.styles.borderLeftStyle = 1, s.styles.backgroundClip = [0], s.styles.backgroundOrigin = [0], s.bounds = (n = s.bounds).width > n.height ? new a(n.left + (n.width - n.height) / 2, n.top, n.height, n.height) : n.width < n.height ? new a(n.left, n.top + (n.height - n.width) / 2, n.width, n.width) : n), s.type) {
                                case pr:
                                    s.styles.borderTopRightRadius = s.styles.borderTopLeftRadius = s.styles.borderBottomRightRadius = s.styles.borderBottomLeftRadius = hr;
                                    break;
                                case fr:
                                    s.styles.borderTopRightRadius = s.styles.borderTopLeftRadius = s.styles.borderBottomRightRadius = s.styles.borderBottomLeftRadius = dr
                            }
                            return s
                        }

                        return e(t, A), t
                    }(xn), wr = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this, r = t.options[t.selectedIndex || 0];
                            return n.value = r && r.text || "", n
                        }

                        return e(t, A), t
                    }(xn), vr = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this;
                            return n.value = t.value, n
                        }

                        return e(t, A), t
                    }(xn), _r = function (A) {
                        function t(e, t) {
                            var n = A.call(this, e, t) || this;
                            n.src = t.src, n.width = parseInt(t.width, 10) || 0, n.height = parseInt(t.height, 10) || 0, n.backgroundColor = n.styles.backgroundColor;
                            try {
                                if (t.contentWindow && t.contentWindow.document && t.contentWindow.document.documentElement) {
                                    n.tree = yr(e, t.contentWindow.document.documentElement);
                                    var r = t.contentWindow.document.documentElement ? _e(e, getComputedStyle(t.contentWindow.document.documentElement).backgroundColor) : Ce.TRANSPARENT,
                                        i = t.contentWindow.document.body ? _e(e, getComputedStyle(t.contentWindow.document.body).backgroundColor) : Ce.TRANSPARENT;
                                    n.backgroundColor = de(r) ? de(i) ? n.styles.backgroundColor : i : r
                                }
                            } catch (A) {
                            }
                            return n
                        }

                        return e(t, A), t
                    }(xn), Cr = ["OL", "UL", "MENU"], Er = function (A, e, t, n) {
                        for (var r = e.firstChild, i = void 0; r; r = i) if (i = r.nextSibling, Fr(r) && r.data.trim().length > 0) t.textNodes.push(new nr(A, r, t.styles)); else if (Sr(r)) if (kr(r) && r.assignedNodes) r.assignedNodes().forEach((function (e) {
                            return Er(A, e, t, n)
                        })); else {
                            var a = Ur(A, r);
                            a.styles.isVisible() && (xr(r, a, n) ? a.flags |= 4 : Mr(a.styles) && (a.flags |= 2), -1 !== Cr.indexOf(r.tagName) && (a.flags |= 8), t.elements.push(a), r.slot, r.shadowRoot ? Er(A, r.shadowRoot, a, n) : Vr(r) || Rr(r) || Kr(r) || Er(A, r, a, n))
                        }
                    }, Ur = function (A, e) {
                        return Nr(e) ? new sr(A, e) : Dr(e) ? new or(A, e) : Rr(e) ? new lr(A, e) : Tr(e) ? new cr(A, e) : Ir(e) ? new ur(A, e) : Lr(e) ? new Br(A, e) : Kr(e) ? new wr(A, e) : Vr(e) ? new vr(A, e) : Or(e) ? new _r(A, e) : new xn(A, e)
                    }, yr = function (A, e) {
                        var t = Ur(A, e);
                        return t.flags |= 4, Er(A, e, t, t), t
                    }, xr = function (A, e, t) {
                        return e.styles.isPositionedWithZIndex() || e.styles.opacity < 1 || e.styles.isTransformed() || Hr(A) && t.styles.isTransparent()
                    }, Mr = function (A) {
                        return A.isPositioned() || A.isFloating()
                    }, Fr = function (A) {
                        return A.nodeType === Node.TEXT_NODE
                    }, Sr = function (A) {
                        return A.nodeType === Node.ELEMENT_NODE
                    }, br = function (A) {
                        return Sr(A) && void 0 !== A.style && !Qr(A)
                    }, Qr = function (A) {
                        return "object" == typeof A.className
                    }, Tr = function (A) {
                        return "LI" === A.tagName
                    }, Ir = function (A) {
                        return "OL" === A.tagName
                    }, Lr = function (A) {
                        return "INPUT" === A.tagName
                    }, Rr = function (A) {
                        return "svg" === A.tagName
                    }, Hr = function (A) {
                        return "BODY" === A.tagName
                    }, Dr = function (A) {
                        return "CANVAS" === A.tagName
                    }, Pr = function (A) {
                        return "VIDEO" === A.tagName
                    }, Nr = function (A) {
                        return "IMG" === A.tagName
                    }, Or = function (A) {
                        return "IFRAME" === A.tagName
                    }, Gr = function (A) {
                        return "STYLE" === A.tagName
                    }, Vr = function (A) {
                        return "TEXTAREA" === A.tagName
                    }, Kr = function (A) {
                        return "SELECT" === A.tagName
                    }, kr = function (A) {
                        return "SLOT" === A.tagName
                    }, zr = function (A) {
                        return A.tagName.indexOf("-") > 0
                    }, Wr = function () {
                        function A() {
                            this.counters = {}
                        }

                        return A.prototype.getCounterValue = function (A) {
                            var e = this.counters[A];
                            return e && e.length ? e[e.length - 1] : 1
                        }, A.prototype.getCounterValues = function (A) {
                            return this.counters[A] || []
                        }, A.prototype.pop = function (A) {
                            var e = this;
                            A.forEach((function (A) {
                                return e.counters[A].pop()
                            }))
                        }, A.prototype.parse = function (A) {
                            var e = this, t = A.counterIncrement, n = A.counterReset, r = !0;
                            null !== t && t.forEach((function (A) {
                                var t = e.counters[A.counter];
                                t && 0 !== A.increment && (r = !1, t.length || t.push(1), t[Math.max(0, t.length - 1)] += A.increment)
                            }));
                            var i = [];
                            return r && n.forEach((function (A) {
                                var t = e.counters[A.counter];
                                i.push(A.counter), t || (t = e.counters[A.counter] = []), t.push(A.reset)
                            })), i
                        }, A
                    }(), Xr = {
                        integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
                        values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
                    }, Yr = {
                        integers: [9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
                        values: ["Ք", "Փ", "Ւ", "Ց", "Ր", "Տ", "Վ", "Ս", "Ռ", "Ջ", "Պ", "Չ", "Ո", "Շ", "Ն", "Յ", "Մ", "Ճ", "Ղ", "Ձ", "Հ", "Կ", "Ծ", "Խ", "Լ", "Ի", "Ժ", "Թ", "Ը", "Է", "Զ", "Ե", "Դ", "Գ", "Բ", "Ա"]
                    }, Jr = {
                        integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
                        values: ["י׳", "ט׳", "ח׳", "ז׳", "ו׳", "ה׳", "ד׳", "ג׳", "ב׳", "א׳", "ת", "ש", "ר", "ק", "צ", "פ", "ע", "ס", "נ", "מ", "ל", "כ", "יט", "יח", "יז", "טז", "טו", "י", "ט", "ח", "ז", "ו", "ה", "ד", "ג", "ב", "א"]
                    }, jr = {
                        integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
                        values: ["ჵ", "ჰ", "ჯ", "ჴ", "ხ", "ჭ", "წ", "ძ", "ც", "ჩ", "შ", "ყ", "ღ", "ქ", "ფ", "ჳ", "ტ", "ს", "რ", "ჟ", "პ", "ო", "ჲ", "ნ", "მ", "ლ", "კ", "ი", "თ", "ჱ", "ზ", "ვ", "ე", "დ", "გ", "ბ", "ა"]
                    }, Zr = function (A, e, t, n, r, i) {
                        return A < e || A > t ? ai(A, r, i.length > 0) : n.integers.reduce((function (e, t, r) {
                            for (; A >= t;) A -= t, e += n.values[r];
                            return e
                        }), "") + i
                    }, qr = function (A, e, t, n) {
                        var r = "";
                        do {
                            t || A--, r = n(A) + r, A /= e
                        } while (A * e >= e);
                        return r
                    }, $r = function (A, e, t, n, r) {
                        var i = t - e + 1;
                        return (A < 0 ? "-" : "") + (qr(Math.abs(A), i, n, (function (A) {
                            return l(Math.floor(A % i) + e)
                        })) + r)
                    }, Ai = function (A, e, t) {
                        void 0 === t && (t = ". ");
                        var n = e.length;
                        return qr(Math.abs(A), n, !1, (function (A) {
                            return e[Math.floor(A % n)]
                        })) + t
                    }, ei = function (A, e, t, n, r, i) {
                        if (A < -9999 || A > 9999) return ai(A, 4, r.length > 0);
                        var a = Math.abs(A), s = r;
                        if (0 === a) return e[0] + s;
                        for (var o = 0; a > 0 && o <= 4; o++) {
                            var l = a % 10;
                            0 === l && cn(i, 1) && "" !== s ? s = e[l] + s : l > 1 || 1 === l && 0 === o || 1 === l && 1 === o && cn(i, 2) || 1 === l && 1 === o && cn(i, 4) && A > 100 || 1 === l && o > 1 && cn(i, 8) ? s = e[l] + (o > 0 ? t[o - 1] : "") + s : 1 === l && o > 0 && (s = t[o - 1] + s), a = Math.floor(a / 10)
                        }
                        return (A < 0 ? n : "") + s
                    }, ti = "十百千萬", ni = "拾佰仟萬", ri = "マイナス", ii = "마이너스", ai = function (A, e, t) {
                        var n = t ? ". " : "", r = t ? "、" : "", i = t ? ", " : "", a = t ? " " : "";
                        switch (e) {
                            case 0:
                                return "•" + a;
                            case 1:
                                return "◦" + a;
                            case 2:
                                return "◾" + a;
                            case 5:
                                var s = $r(A, 48, 57, !0, n);
                                return s.length < 4 ? "0" + s : s;
                            case 4:
                                return Ai(A, "〇一二三四五六七八九", r);
                            case 6:
                                return Zr(A, 1, 3999, Xr, 3, n).toLowerCase();
                            case 7:
                                return Zr(A, 1, 3999, Xr, 3, n);
                            case 8:
                                return $r(A, 945, 969, !1, n);
                            case 9:
                                return $r(A, 97, 122, !1, n);
                            case 10:
                                return $r(A, 65, 90, !1, n);
                            case 11:
                                return $r(A, 1632, 1641, !0, n);
                            case 12:
                            case 49:
                                return Zr(A, 1, 9999, Yr, 3, n);
                            case 35:
                                return Zr(A, 1, 9999, Yr, 3, n).toLowerCase();
                            case 13:
                                return $r(A, 2534, 2543, !0, n);
                            case 14:
                            case 30:
                                return $r(A, 6112, 6121, !0, n);
                            case 15:
                                return Ai(A, "子丑寅卯辰巳午未申酉戌亥", r);
                            case 16:
                                return Ai(A, "甲乙丙丁戊己庚辛壬癸", r);
                            case 17:
                            case 48:
                                return ei(A, "零一二三四五六七八九", ti, "負", r, 14);
                            case 47:
                                return ei(A, "零壹貳參肆伍陸柒捌玖", ni, "負", r, 15);
                            case 42:
                                return ei(A, "零一二三四五六七八九", ti, "负", r, 14);
                            case 41:
                                return ei(A, "零壹贰叁肆伍陆柒捌玖", ni, "负", r, 15);
                            case 26:
                                return ei(A, "〇一二三四五六七八九", "十百千万", ri, r, 0);
                            case 25:
                                return ei(A, "零壱弐参四伍六七八九", "拾百千万", ri, r, 7);
                            case 31:
                                return ei(A, "영일이삼사오육칠팔구", "십백천만", ii, i, 7);
                            case 33:
                                return ei(A, "零一二三四五六七八九", "十百千萬", ii, i, 0);
                            case 32:
                                return ei(A, "零壹貳參四五六七八九", "拾百千", ii, i, 7);
                            case 18:
                                return $r(A, 2406, 2415, !0, n);
                            case 20:
                                return Zr(A, 1, 19999, jr, 3, n);
                            case 21:
                                return $r(A, 2790, 2799, !0, n);
                            case 22:
                                return $r(A, 2662, 2671, !0, n);
                            case 22:
                                return Zr(A, 1, 10999, Jr, 3, n);
                            case 23:
                                return Ai(A, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
                            case 24:
                                return Ai(A, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
                            case 27:
                                return $r(A, 3302, 3311, !0, n);
                            case 28:
                                return Ai(A, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", r);
                            case 29:
                                return Ai(A, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", r);
                            case 34:
                                return $r(A, 3792, 3801, !0, n);
                            case 37:
                                return $r(A, 6160, 6169, !0, n);
                            case 38:
                                return $r(A, 4160, 4169, !0, n);
                            case 39:
                                return $r(A, 2918, 2927, !0, n);
                            case 40:
                                return $r(A, 1776, 1785, !0, n);
                            case 43:
                                return $r(A, 3046, 3055, !0, n);
                            case 44:
                                return $r(A, 3174, 3183, !0, n);
                            case 45:
                                return $r(A, 3664, 3673, !0, n);
                            case 46:
                                return $r(A, 3872, 3881, !0, n);
                            default:
                                return $r(A, 48, 57, !0, n)
                        }
                    }, si = "data-html2canvas-ignore", oi = function () {
                        function A(A, e, t) {
                            if (this.context = A, this.options = t, this.scrolledElements = [], this.referenceElement = e, this.counters = new Wr, this.quoteDepth = 0, !e.ownerDocument) throw new Error("Cloned element does not have an owner document");
                            this.documentElement = this.cloneNode(e.ownerDocument.documentElement, !1)
                        }

                        return A.prototype.toIFrame = function (A, e) {
                            var t = this, i = ci(A, e);
                            if (!i.contentWindow) return Promise.reject("Unable to find iframe window");
                            var a = A.defaultView.pageXOffset, s = A.defaultView.pageYOffset, o = i.contentWindow,
                                l = o.document, c = di(i).then((function () {
                                    return n(t, void 0, void 0, (function () {
                                        var A, t;
                                        return r(this, (function (n) {
                                            switch (n.label) {
                                                case 0:
                                                    return this.scrolledElements.forEach(Bi), o && (o.scrollTo(e.left, e.top), !/(iPad|iPhone|iPod)/g.test(navigator.userAgent) || o.scrollY === e.top && o.scrollX === e.left || (this.context.logger.warn("Unable to restore scroll position for cloned document"), this.context.windowBounds = this.context.windowBounds.add(o.scrollX - e.left, o.scrollY - e.top, 0, 0))), A = this.options.onclone, void 0 === (t = this.clonedReferenceElement) ? [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")] : l.fonts && l.fonts.ready ? [4, l.fonts.ready] : [3, 2];
                                                case 1:
                                                    n.sent(), n.label = 2;
                                                case 2:
                                                    return /(AppleWebKit)/g.test(navigator.userAgent) ? [4, hi(l)] : [3, 4];
                                                case 3:
                                                    n.sent(), n.label = 4;
                                                case 4:
                                                    return "function" == typeof A ? [2, Promise.resolve().then((function () {
                                                        return A(l, t)
                                                    })).then((function () {
                                                        return i
                                                    }))] : [2, i]
                                            }
                                        }))
                                    }))
                                }));
                            return l.open(), l.write(gi(document.doctype) + "<html></html>"), mi(this.referenceElement.ownerDocument, a, s), l.replaceChild(l.adoptNode(this.documentElement), l.documentElement), l.close(), c
                        }, A.prototype.createElementClone = function (A) {
                            if (yn(A, 2), Dr(A)) return this.createCanvasClone(A);
                            if (Pr(A)) return this.createVideoClone(A);
                            if (Gr(A)) return this.createStyleClone(A);
                            var e = A.cloneNode(!1);
                            return Nr(e) && (Nr(A) && A.currentSrc && A.currentSrc !== A.src && (e.src = A.currentSrc, e.srcset = ""), "lazy" === e.loading && (e.loading = "eager")), zr(e) ? this.createCustomElementClone(e) : e
                        }, A.prototype.createCustomElementClone = function (A) {
                            var e = document.createElement("html2canvascustomelement");
                            return fi(A.style, e), e
                        }, A.prototype.createStyleClone = function (A) {
                            try {
                                var e = A.sheet;
                                if (e && e.cssRules) {
                                    var t = [].slice.call(e.cssRules, 0).reduce((function (A, e) {
                                        return e && "string" == typeof e.cssText ? A + e.cssText : A
                                    }), ""), n = A.cloneNode(!1);
                                    return n.textContent = t, n
                                }
                            } catch (A) {
                                if (this.context.logger.error("Unable to access cssRules property", A), "SecurityError" !== A.name) throw A
                            }
                            return A.cloneNode(!1)
                        }, A.prototype.createCanvasClone = function (A) {
                            var e;
                            if (this.options.inlineImages && A.ownerDocument) {
                                var t = A.ownerDocument.createElement("img");
                                try {
                                    return t.src = A.toDataURL(), t
                                } catch (e) {
                                    this.context.logger.info("Unable to inline canvas contents, canvas is tainted", A)
                                }
                            }
                            var n = A.cloneNode(!1);
                            try {
                                n.width = A.width, n.height = A.height;
                                var r = A.getContext("2d"), i = n.getContext("2d");
                                if (i) if (!this.options.allowTaint && r) i.putImageData(r.getImageData(0, 0, A.width, A.height), 0, 0); else {
                                    var a = null !== (e = A.getContext("webgl2")) && void 0 !== e ? e : A.getContext("webgl");
                                    if (a) {
                                        var s = a.getContextAttributes();
                                        !1 === (null == s ? void 0 : s.preserveDrawingBuffer) && this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", A)
                                    }
                                    i.drawImage(A, 0, 0)
                                }
                                return n
                            } catch (e) {
                                this.context.logger.info("Unable to clone canvas as it is tainted", A)
                            }
                            return n
                        }, A.prototype.createVideoClone = function (A) {
                            var e = A.ownerDocument.createElement("canvas");
                            e.width = A.offsetWidth, e.height = A.offsetHeight;
                            var t = e.getContext("2d");
                            try {
                                return t && (t.drawImage(A, 0, 0, e.width, e.height), this.options.allowTaint || t.getImageData(0, 0, e.width, e.height)), e
                            } catch (e) {
                                this.context.logger.info("Unable to clone video as it is tainted", A)
                            }
                            var n = A.ownerDocument.createElement("canvas");
                            return n.width = A.offsetWidth, n.height = A.offsetHeight, n
                        }, A.prototype.appendChildNode = function (A, e, t) {
                            Sr(e) && ("SCRIPT" === e.tagName || e.hasAttribute(si) || "function" == typeof this.options.ignoreElements && this.options.ignoreElements(e)) || this.options.copyStyles && Sr(e) && Gr(e) || A.appendChild(this.cloneNode(e, t))
                        }, A.prototype.cloneChildNodes = function (A, e, t) {
                            for (var n = this, r = A.shadowRoot ? A.shadowRoot.firstChild : A.firstChild; r; r = r.nextSibling) if (Sr(r) && kr(r) && "function" == typeof r.assignedNodes) {
                                var i = r.assignedNodes();
                                i.length && i.forEach((function (A) {
                                    return n.appendChildNode(e, A, t)
                                }))
                            } else this.appendChildNode(e, r, t)
                        }, A.prototype.cloneNode = function (A, e) {
                            if (Fr(A)) return document.createTextNode(A.data);
                            if (!A.ownerDocument) return A.cloneNode(!1);
                            var t = A.ownerDocument.defaultView;
                            if (t && Sr(A) && (br(A) || Qr(A))) {
                                var n = this.createElementClone(A);
                                n.style.transitionProperty = "none";
                                var r = t.getComputedStyle(A), i = t.getComputedStyle(A, ":before"),
                                    a = t.getComputedStyle(A, ":after");
                                this.referenceElement === A && br(n) && (this.clonedReferenceElement = n), Hr(n) && Ci(n);
                                var s = this.counters.parse(new En(this.context, r)),
                                    o = this.resolvePseudoContent(A, n, i, Rn.BEFORE);
                                zr(A) && (e = !0), Pr(A) || this.cloneChildNodes(A, n, e), o && n.insertBefore(o, n.firstChild);
                                var l = this.resolvePseudoContent(A, n, a, Rn.AFTER);
                                return l && n.appendChild(l), this.counters.pop(s), (r && (this.options.copyStyles || Qr(A)) && !Or(A) || e) && fi(r, n), 0 === A.scrollTop && 0 === A.scrollLeft || this.scrolledElements.push([n, A.scrollLeft, A.scrollTop]), (Vr(A) || Kr(A)) && (Vr(n) || Kr(n)) && (n.value = A.value), n
                            }
                            return A.cloneNode(!1)
                        }, A.prototype.resolvePseudoContent = function (A, e, t, n) {
                            var r = this;
                            if (t) {
                                var i = t.content, a = e.ownerDocument;
                                if (a && i && "none" !== i && "-moz-alt-content" !== i && "none" !== t.display) {
                                    this.counters.parse(new En(this.context, t));
                                    var s = new Cn(this.context, t), o = a.createElement("html2canvaspseudoelement");
                                    fi(t, o), s.content.forEach((function (e) {
                                        if (0 === e.type) o.appendChild(a.createTextNode(e.value)); else if (22 === e.type) {
                                            var t = a.createElement("img");
                                            t.src = e.value, t.style.opacity = "1", o.appendChild(t)
                                        } else if (18 === e.type) {
                                            if ("attr" === e.name) {
                                                var n = e.values.filter(zA);
                                                n.length && o.appendChild(a.createTextNode(A.getAttribute(n[0].value) || ""))
                                            } else if ("counter" === e.name) {
                                                var i = e.values.filter(JA), l = i[0], c = i[1];
                                                if (l && zA(l)) {
                                                    var u = r.counters.getCounterValue(l.value),
                                                        h = c && zA(c) ? St.parse(r.context, c.value) : 3;
                                                    o.appendChild(a.createTextNode(ai(u, h, !1)))
                                                }
                                            } else if ("counters" === e.name) {
                                                var d = e.values.filter(JA), p = (l = d[0], d[1]);
                                                if (c = d[2], l && zA(l)) {
                                                    var f = r.counters.getCounterValues(l.value),
                                                        g = c && zA(c) ? St.parse(r.context, c.value) : 3,
                                                        m = p && 0 === p.type ? p.value : "", B = f.map((function (A) {
                                                            return ai(A, g, !1)
                                                        })).join(m);
                                                    o.appendChild(a.createTextNode(B))
                                                }
                                            }
                                        } else if (20 === e.type) switch (e.value) {
                                            case"open-quote":
                                                o.appendChild(a.createTextNode(gn(s.quotes, r.quoteDepth++, !0)));
                                                break;
                                            case"close-quote":
                                                o.appendChild(a.createTextNode(gn(s.quotes, --r.quoteDepth, !1)));
                                                break;
                                            default:
                                                o.appendChild(a.createTextNode(e.value))
                                        }
                                    })), o.className = wi + " " + vi;
                                    var l = n === Rn.BEFORE ? " " + wi : " " + vi;
                                    return Qr(e) ? e.className.baseValue += l : e.className += l, o
                                }
                            }
                        }, A.destroy = function (A) {
                            return !!A.parentNode && (A.parentNode.removeChild(A), !0)
                        }, A
                    }();
                !function (A) {
                    A[A.BEFORE = 0] = "BEFORE", A[A.AFTER = 1] = "AFTER"
                }(Rn || (Rn = {}));
                var li, ci = function (A, e) {
                        var t = A.createElement("iframe");
                        return t.className = "html2canvas-container", t.style.visibility = "hidden", t.style.position = "fixed", t.style.left = "-10000px", t.style.top = "0px", t.style.border = "0", t.width = e.width.toString(), t.height = e.height.toString(), t.scrolling = "no", t.setAttribute(si, "true"), A.body.appendChild(t), t
                    }, ui = function (A) {
                        return new Promise((function (e) {
                            A.complete ? e() : A.src ? (A.onload = e, A.onerror = e) : e()
                        }))
                    }, hi = function (A) {
                        return Promise.all([].slice.call(A.images, 0).map(ui))
                    }, di = function (A) {
                        return new Promise((function (e, t) {
                            var n = A.contentWindow;
                            if (!n) return t("No window assigned for iframe");
                            var r = n.document;
                            n.onload = A.onload = function () {
                                n.onload = A.onload = null;
                                var t = setInterval((function () {
                                    r.body.childNodes.length > 0 && "complete" === r.readyState && (clearInterval(t), e(A))
                                }), 50)
                            }
                        }))
                    }, pi = ["all", "d", "content"], fi = function (A, e) {
                        for (var t = A.length - 1; t >= 0; t--) {
                            var n = A.item(t);
                            -1 === pi.indexOf(n) && e.style.setProperty(n, A.getPropertyValue(n))
                        }
                        return e
                    }, gi = function (A) {
                        var e = "";
                        return A && (e += "<!DOCTYPE ", A.name && (e += A.name), A.internalSubset && (e += A.internalSubset), A.publicId && (e += '"' + A.publicId + '"'), A.systemId && (e += '"' + A.systemId + '"'), e += ">"), e
                    }, mi = function (A, e, t) {
                        A && A.defaultView && (e !== A.defaultView.pageXOffset || t !== A.defaultView.pageYOffset) && A.defaultView.scrollTo(e, t)
                    }, Bi = function (A) {
                        var e = A[0], t = A[1], n = A[2];
                        e.scrollLeft = t, e.scrollTop = n
                    }, wi = "___html2canvas___pseudoelement_before", vi = "___html2canvas___pseudoelement_after",
                    _i = '{\n    content: "" !important;\n    display: none !important;\n}', Ci = function (A) {
                        Ei(A, "." + wi + ":before" + _i + "\n         ." + vi + ":after" + _i)
                    }, Ei = function (A, e) {
                        var t = A.ownerDocument;
                        if (t) {
                            var n = t.createElement("style");
                            n.textContent = e, A.appendChild(n)
                        }
                    }, Ui = function () {
                        function A() {
                        }

                        return A.getOrigin = function (e) {
                            var t = A._link;
                            return t ? (t.href = e, t.href = t.href, t.protocol + t.hostname + t.port) : "about:blank"
                        }, A.isSameOrigin = function (e) {
                            return A.getOrigin(e) === A._origin
                        }, A.setContext = function (e) {
                            A._link = e.document.createElement("a"), A._origin = A.getOrigin(e.location.href)
                        }, A._origin = "about:blank", A
                    }(), yi = function () {
                        function A(A, e) {
                            this.context = A, this._options = e, this._cache = {}
                        }

                        return A.prototype.addImage = function (A) {
                            var e = Promise.resolve();
                            return this.has(A) ? e : Ti(A) || Si(A) ? ((this._cache[A] = this.loadImage(A)).catch((function () {
                            })), e) : e
                        }, A.prototype.match = function (A) {
                            return this._cache[A]
                        }, A.prototype.loadImage = function (A) {
                            return n(this, void 0, void 0, (function () {
                                var e, t, n, i, a = this;
                                return r(this, (function (r) {
                                    switch (r.label) {
                                        case 0:
                                            return e = Ui.isSameOrigin(A), t = !bi(A) && !0 === this._options.useCORS && Jn.SUPPORT_CORS_IMAGES && !e, n = !bi(A) && !e && !Ti(A) && "string" == typeof this._options.proxy && Jn.SUPPORT_CORS_XHR && !t, e || !1 !== this._options.allowTaint || bi(A) || Ti(A) || n || t ? (i = A, n ? [4, this.proxy(i)] : [3, 2]) : [2];
                                        case 1:
                                            i = r.sent(), r.label = 2;
                                        case 2:
                                            return this.context.logger.debug("Added image " + A.substring(0, 256)), [4, new Promise((function (A, e) {
                                                var n = new Image;
                                                n.onload = function () {
                                                    return A(n)
                                                }, n.onerror = e, (Qi(i) || t) && (n.crossOrigin = "anonymous"), n.src = i, !0 === n.complete && setTimeout((function () {
                                                    return A(n)
                                                }), 500), a._options.imageTimeout > 0 && setTimeout((function () {
                                                    return e("Timed out (" + a._options.imageTimeout + "ms) loading image")
                                                }), a._options.imageTimeout)
                                            }))];
                                        case 3:
                                            return [2, r.sent()]
                                    }
                                }))
                            }))
                        }, A.prototype.has = function (A) {
                            return void 0 !== this._cache[A]
                        }, A.prototype.keys = function () {
                            return Promise.resolve(Object.keys(this._cache))
                        }, A.prototype.proxy = function (A) {
                            var e = this, t = this._options.proxy;
                            if (!t) throw new Error("No proxy defined");
                            var n = A.substring(0, 256);
                            return new Promise((function (r, i) {
                                var a = Jn.SUPPORT_RESPONSE_TYPE ? "blob" : "text", s = new XMLHttpRequest;
                                s.onload = function () {
                                    if (200 === s.status) if ("text" === a) r(s.response); else {
                                        var A = new FileReader;
                                        A.addEventListener("load", (function () {
                                            return r(A.result)
                                        }), !1), A.addEventListener("error", (function (A) {
                                            return i(A)
                                        }), !1), A.readAsDataURL(s.response)
                                    } else i("Failed to proxy resource " + n + " with status code " + s.status)
                                }, s.onerror = i;
                                var o = t.indexOf("?") > -1 ? "&" : "?";
                                if (s.open("GET", "" + t + o + "url=" + encodeURIComponent(A) + "&responseType=" + a), "text" !== a && s instanceof XMLHttpRequest && (s.responseType = a), e._options.imageTimeout) {
                                    var l = e._options.imageTimeout;
                                    s.timeout = l, s.ontimeout = function () {
                                        return i("Timed out (" + l + "ms) proxying " + n)
                                    }
                                }
                                s.send()
                            }))
                        }, A
                    }(), xi = /^data:image\/svg\+xml/i, Mi = /^data:image\/.*;base64,/i, Fi = /^data:image\/.*/i,
                    Si = function (A) {
                        return Jn.SUPPORT_SVG_DRAWING || !Ii(A)
                    }, bi = function (A) {
                        return Fi.test(A)
                    }, Qi = function (A) {
                        return Mi.test(A)
                    }, Ti = function (A) {
                        return "blob" === A.substr(0, 4)
                    }, Ii = function (A) {
                        return "svg" === A.substr(-3).toLowerCase() || xi.test(A)
                    }, Li = function () {
                        function A(A, e) {
                            this.type = 0, this.x = A, this.y = e
                        }

                        return A.prototype.add = function (e, t) {
                            return new A(this.x + e, this.y + t)
                        }, A
                    }(), Ri = function (A, e, t) {
                        return new Li(A.x + (e.x - A.x) * t, A.y + (e.y - A.y) * t)
                    }, Hi = function () {
                        function A(A, e, t, n) {
                            this.type = 1, this.start = A, this.startControl = e, this.endControl = t, this.end = n
                        }

                        return A.prototype.subdivide = function (e, t) {
                            var n = Ri(this.start, this.startControl, e), r = Ri(this.startControl, this.endControl, e),
                                i = Ri(this.endControl, this.end, e), a = Ri(n, r, e), s = Ri(r, i, e), o = Ri(a, s, e);
                            return t ? new A(this.start, n, a, o) : new A(o, s, i, this.end)
                        }, A.prototype.add = function (e, t) {
                            return new A(this.start.add(e, t), this.startControl.add(e, t), this.endControl.add(e, t), this.end.add(e, t))
                        }, A.prototype.reverse = function () {
                            return new A(this.end, this.endControl, this.startControl, this.start)
                        }, A
                    }(), Di = function (A) {
                        return 1 === A.type
                    }, Pi = function (A) {
                        var e = A.styles, t = A.bounds, n = re(e.borderTopLeftRadius, t.width, t.height), r = n[0],
                            i = n[1], a = re(e.borderTopRightRadius, t.width, t.height), s = a[0], o = a[1],
                            l = re(e.borderBottomRightRadius, t.width, t.height), c = l[0], u = l[1],
                            h = re(e.borderBottomLeftRadius, t.width, t.height), d = h[0], p = h[1], f = [];
                        f.push((r + s) / t.width), f.push((d + c) / t.width), f.push((i + p) / t.height), f.push((o + u) / t.height);
                        var g = Math.max.apply(Math, f);
                        g > 1 && (r /= g, i /= g, s /= g, o /= g, c /= g, u /= g, d /= g, p /= g);
                        var m = t.width - s, B = t.height - u, w = t.width - c, v = t.height - p, _ = e.borderTopWidth,
                            C = e.borderRightWidth, E = e.borderBottomWidth, U = e.borderLeftWidth,
                            y = ie(e.paddingTop, A.bounds.width), x = ie(e.paddingRight, A.bounds.width),
                            M = ie(e.paddingBottom, A.bounds.width), F = ie(e.paddingLeft, A.bounds.width);
                        this.topLeftBorderDoubleOuterBox = r > 0 || i > 0 ? Ni(t.left + U / 3, t.top + _ / 3, r - U / 3, i - _ / 3, li.TOP_LEFT) : new Li(t.left + U / 3, t.top + _ / 3), this.topRightBorderDoubleOuterBox = r > 0 || i > 0 ? Ni(t.left + m, t.top + _ / 3, s - C / 3, o - _ / 3, li.TOP_RIGHT) : new Li(t.left + t.width - C / 3, t.top + _ / 3), this.bottomRightBorderDoubleOuterBox = c > 0 || u > 0 ? Ni(t.left + w, t.top + B, c - C / 3, u - E / 3, li.BOTTOM_RIGHT) : new Li(t.left + t.width - C / 3, t.top + t.height - E / 3), this.bottomLeftBorderDoubleOuterBox = d > 0 || p > 0 ? Ni(t.left + U / 3, t.top + v, d - U / 3, p - E / 3, li.BOTTOM_LEFT) : new Li(t.left + U / 3, t.top + t.height - E / 3), this.topLeftBorderDoubleInnerBox = r > 0 || i > 0 ? Ni(t.left + 2 * U / 3, t.top + 2 * _ / 3, r - 2 * U / 3, i - 2 * _ / 3, li.TOP_LEFT) : new Li(t.left + 2 * U / 3, t.top + 2 * _ / 3), this.topRightBorderDoubleInnerBox = r > 0 || i > 0 ? Ni(t.left + m, t.top + 2 * _ / 3, s - 2 * C / 3, o - 2 * _ / 3, li.TOP_RIGHT) : new Li(t.left + t.width - 2 * C / 3, t.top + 2 * _ / 3), this.bottomRightBorderDoubleInnerBox = c > 0 || u > 0 ? Ni(t.left + w, t.top + B, c - 2 * C / 3, u - 2 * E / 3, li.BOTTOM_RIGHT) : new Li(t.left + t.width - 2 * C / 3, t.top + t.height - 2 * E / 3), this.bottomLeftBorderDoubleInnerBox = d > 0 || p > 0 ? Ni(t.left + 2 * U / 3, t.top + v, d - 2 * U / 3, p - 2 * E / 3, li.BOTTOM_LEFT) : new Li(t.left + 2 * U / 3, t.top + t.height - 2 * E / 3), this.topLeftBorderStroke = r > 0 || i > 0 ? Ni(t.left + U / 2, t.top + _ / 2, r - U / 2, i - _ / 2, li.TOP_LEFT) : new Li(t.left + U / 2, t.top + _ / 2), this.topRightBorderStroke = r > 0 || i > 0 ? Ni(t.left + m, t.top + _ / 2, s - C / 2, o - _ / 2, li.TOP_RIGHT) : new Li(t.left + t.width - C / 2, t.top + _ / 2), this.bottomRightBorderStroke = c > 0 || u > 0 ? Ni(t.left + w, t.top + B, c - C / 2, u - E / 2, li.BOTTOM_RIGHT) : new Li(t.left + t.width - C / 2, t.top + t.height - E / 2), this.bottomLeftBorderStroke = d > 0 || p > 0 ? Ni(t.left + U / 2, t.top + v, d - U / 2, p - E / 2, li.BOTTOM_LEFT) : new Li(t.left + U / 2, t.top + t.height - E / 2), this.topLeftBorderBox = r > 0 || i > 0 ? Ni(t.left, t.top, r, i, li.TOP_LEFT) : new Li(t.left, t.top), this.topRightBorderBox = s > 0 || o > 0 ? Ni(t.left + m, t.top, s, o, li.TOP_RIGHT) : new Li(t.left + t.width, t.top), this.bottomRightBorderBox = c > 0 || u > 0 ? Ni(t.left + w, t.top + B, c, u, li.BOTTOM_RIGHT) : new Li(t.left + t.width, t.top + t.height), this.bottomLeftBorderBox = d > 0 || p > 0 ? Ni(t.left, t.top + v, d, p, li.BOTTOM_LEFT) : new Li(t.left, t.top + t.height), this.topLeftPaddingBox = r > 0 || i > 0 ? Ni(t.left + U, t.top + _, Math.max(0, r - U), Math.max(0, i - _), li.TOP_LEFT) : new Li(t.left + U, t.top + _), this.topRightPaddingBox = s > 0 || o > 0 ? Ni(t.left + Math.min(m, t.width - C), t.top + _, m > t.width + C ? 0 : Math.max(0, s - C), Math.max(0, o - _), li.TOP_RIGHT) : new Li(t.left + t.width - C, t.top + _), this.bottomRightPaddingBox = c > 0 || u > 0 ? Ni(t.left + Math.min(w, t.width - U), t.top + Math.min(B, t.height - E), Math.max(0, c - C), Math.max(0, u - E), li.BOTTOM_RIGHT) : new Li(t.left + t.width - C, t.top + t.height - E), this.bottomLeftPaddingBox = d > 0 || p > 0 ? Ni(t.left + U, t.top + Math.min(v, t.height - E), Math.max(0, d - U), Math.max(0, p - E), li.BOTTOM_LEFT) : new Li(t.left + U, t.top + t.height - E), this.topLeftContentBox = r > 0 || i > 0 ? Ni(t.left + U + F, t.top + _ + y, Math.max(0, r - (U + F)), Math.max(0, i - (_ + y)), li.TOP_LEFT) : new Li(t.left + U + F, t.top + _ + y), this.topRightContentBox = s > 0 || o > 0 ? Ni(t.left + Math.min(m, t.width + U + F), t.top + _ + y, m > t.width + U + F ? 0 : s - U + F, o - (_ + y), li.TOP_RIGHT) : new Li(t.left + t.width - (C + x), t.top + _ + y), this.bottomRightContentBox = c > 0 || u > 0 ? Ni(t.left + Math.min(w, t.width - (U + F)), t.top + Math.min(B, t.height + _ + y), Math.max(0, c - (C + x)), u - (E + M), li.BOTTOM_RIGHT) : new Li(t.left + t.width - (C + x), t.top + t.height - (E + M)), this.bottomLeftContentBox = d > 0 || p > 0 ? Ni(t.left + U + F, t.top + v, Math.max(0, d - (U + F)), p - (E + M), li.BOTTOM_LEFT) : new Li(t.left + U + F, t.top + t.height - (E + M))
                    };
                !function (A) {
                    A[A.TOP_LEFT = 0] = "TOP_LEFT", A[A.TOP_RIGHT = 1] = "TOP_RIGHT", A[A.BOTTOM_RIGHT = 2] = "BOTTOM_RIGHT", A[A.BOTTOM_LEFT = 3] = "BOTTOM_LEFT"
                }(li || (li = {}));
                var Ni = function (A, e, t, n, r) {
                    var i = (Math.sqrt(2) - 1) / 3 * 4, a = t * i, s = n * i, o = A + t, l = e + n;
                    switch (r) {
                        case li.TOP_LEFT:
                            return new Hi(new Li(A, l), new Li(A, l - s), new Li(o - a, e), new Li(o, e));
                        case li.TOP_RIGHT:
                            return new Hi(new Li(A, e), new Li(A + a, e), new Li(o, l - s), new Li(o, l));
                        case li.BOTTOM_RIGHT:
                            return new Hi(new Li(o, e), new Li(o, e + s), new Li(A + a, l), new Li(A, l));
                        case li.BOTTOM_LEFT:
                        default:
                            return new Hi(new Li(o, l), new Li(o - a, l), new Li(A, e + s), new Li(A, e))
                    }
                }, Oi = function (A) {
                    return [A.topLeftBorderBox, A.topRightBorderBox, A.bottomRightBorderBox, A.bottomLeftBorderBox]
                }, Gi = function (A) {
                    return [A.topLeftPaddingBox, A.topRightPaddingBox, A.bottomRightPaddingBox, A.bottomLeftPaddingBox]
                }, Vi = function (A, e, t) {
                    this.offsetX = A, this.offsetY = e, this.matrix = t, this.type = 0, this.target = 6
                }, Ki = function (A, e) {
                    this.path = A, this.target = e, this.type = 1
                }, ki = function (A) {
                    this.opacity = A, this.type = 2, this.target = 6
                }, zi = function (A) {
                    return 1 === A.type
                }, Wi = function (A, e) {
                    return A.length === e.length && A.some((function (A, t) {
                        return A === e[t]
                    }))
                }, Xi = function (A) {
                    this.element = A, this.inlineLevel = [], this.nonInlineLevel = [], this.negativeZIndex = [], this.zeroOrAutoZIndexOrTransformedOrOpacity = [], this.positiveZIndex = [], this.nonPositionedFloats = [], this.nonPositionedInlineLevel = []
                }, Yi = function () {
                    function A(A, e) {
                        if (this.container = A, this.parent = e, this.effects = [], this.curves = new Pi(this.container), this.container.styles.opacity < 1 && this.effects.push(new ki(this.container.styles.opacity)), null !== this.container.styles.transform) {
                            var t = this.container.bounds.left + this.container.styles.transformOrigin[0].number,
                                n = this.container.bounds.top + this.container.styles.transformOrigin[1].number,
                                r = this.container.styles.transform;
                            this.effects.push(new Vi(t, n, r))
                        }
                        if (0 !== this.container.styles.overflowX) {
                            var i = Oi(this.curves), a = Gi(this.curves);
                            Wi(i, a) ? this.effects.push(new Ki(i, 6)) : (this.effects.push(new Ki(i, 2)), this.effects.push(new Ki(a, 4)))
                        }
                    }

                    return A.prototype.getEffects = function (A) {
                        for (var e = -1 === [2, 3].indexOf(this.container.styles.position), t = this.parent, n = this.effects.slice(0); t;) {
                            var r = t.effects.filter((function (A) {
                                return !zi(A)
                            }));
                            if (e || 0 !== t.container.styles.position || !t.parent) {
                                if (n.unshift.apply(n, r), e = -1 === [2, 3].indexOf(t.container.styles.position), 0 !== t.container.styles.overflowX) {
                                    var i = Oi(t.curves), a = Gi(t.curves);
                                    Wi(i, a) || n.unshift(new Ki(a, 6))
                                }
                            } else n.unshift.apply(n, r);
                            t = t.parent
                        }
                        return n.filter((function (e) {
                            return cn(e.target, A)
                        }))
                    }, A
                }(), Ji = function (A, e, t, n) {
                    A.container.elements.forEach((function (r) {
                        var i = cn(r.flags, 4), a = cn(r.flags, 2), s = new Yi(r, A);
                        cn(r.styles.display, 2048) && n.push(s);
                        var o = cn(r.flags, 8) ? [] : n;
                        if (i || a) {
                            var l = i || r.styles.isPositioned() ? t : e, c = new Xi(s);
                            if (r.styles.isPositioned() || r.styles.opacity < 1 || r.styles.isTransformed()) {
                                var u = r.styles.zIndex.order;
                                if (u < 0) {
                                    var h = 0;
                                    l.negativeZIndex.some((function (A, e) {
                                        return u > A.element.container.styles.zIndex.order ? (h = e, !1) : h > 0
                                    })), l.negativeZIndex.splice(h, 0, c)
                                } else if (u > 0) {
                                    var d = 0;
                                    l.positiveZIndex.some((function (A, e) {
                                        return u >= A.element.container.styles.zIndex.order ? (d = e + 1, !1) : d > 0
                                    })), l.positiveZIndex.splice(d, 0, c)
                                } else l.zeroOrAutoZIndexOrTransformedOrOpacity.push(c)
                            } else r.styles.isFloating() ? l.nonPositionedFloats.push(c) : l.nonPositionedInlineLevel.push(c);
                            Ji(s, c, i ? c : t, o)
                        } else r.styles.isInlineLevel() ? e.inlineLevel.push(s) : e.nonInlineLevel.push(s), Ji(s, e, t, o);
                        cn(r.flags, 8) && ji(r, o)
                    }))
                }, ji = function (A, e) {
                    for (var t = A instanceof ur ? A.start : 1, n = A instanceof ur && A.reversed, r = 0; r < e.length; r++) {
                        var i = e[r];
                        i.container instanceof cr && "number" == typeof i.container.value && 0 !== i.container.value && (t = i.container.value), i.listValue = ai(t, i.container.styles.listStyleType, !0), t += n ? -1 : 1
                    }
                }, Zi = function (A, e) {
                    switch (e) {
                        case 0:
                            return $i(A.topLeftBorderBox, A.topLeftPaddingBox, A.topRightBorderBox, A.topRightPaddingBox);
                        case 1:
                            return $i(A.topRightBorderBox, A.topRightPaddingBox, A.bottomRightBorderBox, A.bottomRightPaddingBox);
                        case 2:
                            return $i(A.bottomRightBorderBox, A.bottomRightPaddingBox, A.bottomLeftBorderBox, A.bottomLeftPaddingBox);
                        default:
                            return $i(A.bottomLeftBorderBox, A.bottomLeftPaddingBox, A.topLeftBorderBox, A.topLeftPaddingBox)
                    }
                }, qi = function (A, e) {
                    var t = [];
                    return Di(A) ? t.push(A.subdivide(.5, !1)) : t.push(A), Di(e) ? t.push(e.subdivide(.5, !0)) : t.push(e), t
                }, $i = function (A, e, t, n) {
                    var r = [];
                    return Di(A) ? r.push(A.subdivide(.5, !1)) : r.push(A), Di(t) ? r.push(t.subdivide(.5, !0)) : r.push(t), Di(n) ? r.push(n.subdivide(.5, !0).reverse()) : r.push(n), Di(e) ? r.push(e.subdivide(.5, !1).reverse()) : r.push(e), r
                }, Aa = function (A) {
                    var e = A.bounds, t = A.styles;
                    return e.add(t.borderLeftWidth, t.borderTopWidth, -(t.borderRightWidth + t.borderLeftWidth), -(t.borderTopWidth + t.borderBottomWidth))
                }, ea = function (A) {
                    var e = A.styles, t = A.bounds, n = ie(e.paddingLeft, t.width), r = ie(e.paddingRight, t.width),
                        i = ie(e.paddingTop, t.width), a = ie(e.paddingBottom, t.width);
                    return t.add(n + e.borderLeftWidth, i + e.borderTopWidth, -(e.borderRightWidth + e.borderLeftWidth + n + r), -(e.borderTopWidth + e.borderBottomWidth + i + a))
                }, ta = function (A, e, t) {
                    var n = function (A, e) {
                            return 0 === A ? e.bounds : 2 === A ? ea(e) : Aa(e)
                        }(aa(A.styles.backgroundOrigin, e), A), r = function (A, e) {
                            return 0 === A ? e.bounds : 2 === A ? ea(e) : Aa(e)
                        }(aa(A.styles.backgroundClip, e), A), i = ia(aa(A.styles.backgroundSize, e), t, n), a = i[0],
                        s = i[1], o = re(aa(A.styles.backgroundPosition, e), n.width - a, n.height - s);
                    return [sa(aa(A.styles.backgroundRepeat, e), o, i, n, r), Math.round(n.left + o[0]), Math.round(n.top + o[1]), a, s]
                }, na = function (A) {
                    return zA(A) && A.value === Ge.AUTO
                }, ra = function (A) {
                    return "number" == typeof A
                }, ia = function (A, e, t) {
                    var n = e[0], r = e[1], i = e[2], a = A[0], s = A[1];
                    if (!a) return [0, 0];
                    if ($A(a) && s && $A(s)) return [ie(a, t.width), ie(s, t.height)];
                    var o = ra(i);
                    if (zA(a) && (a.value === Ge.CONTAIN || a.value === Ge.COVER)) return ra(i) ? t.width / t.height < i != (a.value === Ge.COVER) ? [t.width, t.width / i] : [t.height * i, t.height] : [t.width, t.height];
                    var l = ra(n), c = ra(r), u = l || c;
                    if (na(a) && (!s || na(s))) return l && c ? [n, r] : o || u ? u && o ? [l ? n : r * i, c ? r : n / i] : [l ? n : t.width, c ? r : t.height] : [t.width, t.height];
                    if (o) {
                        var h = 0, d = 0;
                        return $A(a) ? h = ie(a, t.width) : $A(s) && (d = ie(s, t.height)), na(a) ? h = d * i : s && !na(s) || (d = h / i), [h, d]
                    }
                    var p = null, f = null;
                    if ($A(a) ? p = ie(a, t.width) : s && $A(s) && (f = ie(s, t.height)), null === p || s && !na(s) || (f = l && c ? p / n * r : t.height), null !== f && na(a) && (p = l && c ? f / r * n : t.width), null !== p && null !== f) return [p, f];
                    throw new Error("Unable to calculate background-size for element")
                }, aa = function (A, e) {
                    var t = A[e];
                    return void 0 === t ? A[0] : t
                }, sa = function (A, e, t, n, r) {
                    var i = e[0], a = e[1], s = t[0], o = t[1];
                    switch (A) {
                        case 2:
                            return [new Li(Math.round(n.left), Math.round(n.top + a)), new Li(Math.round(n.left + n.width), Math.round(n.top + a)), new Li(Math.round(n.left + n.width), Math.round(o + n.top + a)), new Li(Math.round(n.left), Math.round(o + n.top + a))];
                        case 3:
                            return [new Li(Math.round(n.left + i), Math.round(n.top)), new Li(Math.round(n.left + i + s), Math.round(n.top)), new Li(Math.round(n.left + i + s), Math.round(n.height + n.top)), new Li(Math.round(n.left + i), Math.round(n.height + n.top))];
                        case 1:
                            return [new Li(Math.round(n.left + i), Math.round(n.top + a)), new Li(Math.round(n.left + i + s), Math.round(n.top + a)), new Li(Math.round(n.left + i + s), Math.round(n.top + a + o)), new Li(Math.round(n.left + i), Math.round(n.top + a + o))];
                        default:
                            return [new Li(Math.round(r.left), Math.round(r.top)), new Li(Math.round(r.left + r.width), Math.round(r.top)), new Li(Math.round(r.left + r.width), Math.round(r.height + r.top)), new Li(Math.round(r.left), Math.round(r.height + r.top))]
                    }
                }, oa = "Hidden Text", la = function () {
                    function A(A) {
                        this._data = {}, this._document = A
                    }

                    return A.prototype.parseMetrics = function (A, e) {
                        var t = this._document.createElement("div"), n = this._document.createElement("img"),
                            r = this._document.createElement("span"), i = this._document.body;
                        t.style.visibility = "hidden", t.style.fontFamily = A, t.style.fontSize = e, t.style.margin = "0", t.style.padding = "0", t.style.whiteSpace = "nowrap", i.appendChild(t), n.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", n.width = 1, n.height = 1, n.style.margin = "0", n.style.padding = "0", n.style.verticalAlign = "baseline", r.style.fontFamily = A, r.style.fontSize = e, r.style.margin = "0", r.style.padding = "0", r.appendChild(this._document.createTextNode(oa)), t.appendChild(r), t.appendChild(n);
                        var a = n.offsetTop - r.offsetTop + 2;
                        t.removeChild(r), t.appendChild(this._document.createTextNode(oa)), t.style.lineHeight = "normal", n.style.verticalAlign = "super";
                        var s = n.offsetTop - t.offsetTop + 2;
                        return i.removeChild(t), {baseline: a, middle: s}
                    }, A.prototype.getMetrics = function (A, e) {
                        var t = A + " " + e;
                        return void 0 === this._data[t] && (this._data[t] = this.parseMetrics(A, e)), this._data[t]
                    }, A
                }(), ca = function (A, e) {
                    this.context = A, this.options = e
                }, ua = function (A) {
                    function t(e, t) {
                        var n = A.call(this, e, t) || this;
                        return n._activeEffects = [], n.canvas = t.canvas ? t.canvas : document.createElement("canvas"), n.ctx = n.canvas.getContext("2d"), t.canvas || (n.canvas.width = Math.floor(t.width * t.scale), n.canvas.height = Math.floor(t.height * t.scale), n.canvas.style.width = t.width + "px", n.canvas.style.height = t.height + "px"), n.fontMetrics = new la(document), n.ctx.scale(n.options.scale, n.options.scale), n.ctx.translate(-t.x, -t.y), n.ctx.textBaseline = "bottom", n._activeEffects = [], n.context.logger.debug("Canvas renderer initialized (" + t.width + "x" + t.height + ") with scale " + t.scale), n
                    }

                    return e(t, A), t.prototype.applyEffects = function (A) {
                        for (var e = this; this._activeEffects.length;) this.popEffect();
                        A.forEach((function (A) {
                            return e.applyEffect(A)
                        }))
                    }, t.prototype.applyEffect = function (A) {
                        this.ctx.save(), function (A) {
                            return 2 === A.type
                        }(A) && (this.ctx.globalAlpha = A.opacity), function (A) {
                            return 0 === A.type
                        }(A) && (this.ctx.translate(A.offsetX, A.offsetY), this.ctx.transform(A.matrix[0], A.matrix[1], A.matrix[2], A.matrix[3], A.matrix[4], A.matrix[5]), this.ctx.translate(-A.offsetX, -A.offsetY)), zi(A) && (this.path(A.path), this.ctx.clip()), this._activeEffects.push(A)
                    }, t.prototype.popEffect = function () {
                        this._activeEffects.pop(), this.ctx.restore()
                    }, t.prototype.renderStack = function (A) {
                        return n(this, void 0, void 0, (function () {
                            return r(this, (function (e) {
                                switch (e.label) {
                                    case 0:
                                        return A.element.container.styles.isVisible() ? [4, this.renderStackContent(A)] : [3, 2];
                                    case 1:
                                        e.sent(), e.label = 2;
                                    case 2:
                                        return [2]
                                }
                            }))
                        }))
                    }, t.prototype.renderNode = function (A) {
                        return n(this, void 0, void 0, (function () {
                            return r(this, (function (e) {
                                switch (e.label) {
                                    case 0:
                                        return cn(A.container.flags, 16), A.container.styles.isVisible() ? [4, this.renderNodeBackgroundAndBorders(A)] : [3, 3];
                                    case 1:
                                        return e.sent(), [4, this.renderNodeContent(A)];
                                    case 2:
                                        e.sent(), e.label = 3;
                                    case 3:
                                        return [2]
                                }
                            }))
                        }))
                    }, t.prototype.renderTextWithLetterSpacing = function (A, e, t) {
                        var n = this;
                        0 === e ? this.ctx.fillText(A.text, A.bounds.left, A.bounds.top + t) : $n(A.text).reduce((function (e, r) {
                            return n.ctx.fillText(r, e, A.bounds.top + t), e + n.ctx.measureText(r).width
                        }), A.bounds.left)
                    }, t.prototype.createFontStyle = function (A) {
                        var e = A.fontVariant.filter((function (A) {
                                return "normal" === A || "small-caps" === A
                            })).join(""), t = ga(A.fontFamily).join(", "),
                            n = KA(A.fontSize) ? "" + A.fontSize.number + A.fontSize.unit : A.fontSize.number + "px";
                        return [[A.fontStyle, e, A.fontWeight, n, t].join(" "), t, n]
                    }, t.prototype.renderTextNode = function (A, e) {
                        return n(this, void 0, void 0, (function () {
                            var t, n, i, a, s, o, l, c, u = this;
                            return r(this, (function (r) {
                                return t = this.createFontStyle(e), n = t[0], i = t[1], a = t[2], this.ctx.font = n, this.ctx.direction = 1 === e.direction ? "rtl" : "ltr", this.ctx.textAlign = "left", this.ctx.textBaseline = "alphabetic", s = this.fontMetrics.getMetrics(i, a), o = s.baseline, l = s.middle, c = e.paintOrder, A.textBounds.forEach((function (A) {
                                    c.forEach((function (t) {
                                        switch (t) {
                                            case 0:
                                                u.ctx.fillStyle = pe(e.color), u.renderTextWithLetterSpacing(A, e.letterSpacing, o);
                                                var n = e.textShadow;
                                                n.length && A.text.trim().length && (n.slice(0).reverse().forEach((function (t) {
                                                    u.ctx.shadowColor = pe(t.color), u.ctx.shadowOffsetX = t.offsetX.number * u.options.scale, u.ctx.shadowOffsetY = t.offsetY.number * u.options.scale, u.ctx.shadowBlur = t.blur.number, u.renderTextWithLetterSpacing(A, e.letterSpacing, o)
                                                })), u.ctx.shadowColor = "", u.ctx.shadowOffsetX = 0, u.ctx.shadowOffsetY = 0, u.ctx.shadowBlur = 0), e.textDecorationLine.length && (u.ctx.fillStyle = pe(e.textDecorationColor || e.color), e.textDecorationLine.forEach((function (e) {
                                                    switch (e) {
                                                        case 1:
                                                            u.ctx.fillRect(A.bounds.left, Math.round(A.bounds.top + o), A.bounds.width, 1);
                                                            break;
                                                        case 2:
                                                            u.ctx.fillRect(A.bounds.left, Math.round(A.bounds.top), A.bounds.width, 1);
                                                            break;
                                                        case 3:
                                                            u.ctx.fillRect(A.bounds.left, Math.ceil(A.bounds.top + l), A.bounds.width, 1)
                                                    }
                                                })));
                                                break;
                                            case 1:
                                                e.webkitTextStrokeWidth && A.text.trim().length && (u.ctx.strokeStyle = pe(e.webkitTextStrokeColor), u.ctx.lineWidth = e.webkitTextStrokeWidth, u.ctx.lineJoin = window.chrome ? "miter" : "round", u.ctx.strokeText(A.text, A.bounds.left, A.bounds.top + o)), u.ctx.strokeStyle = "", u.ctx.lineWidth = 0, u.ctx.lineJoin = "miter"
                                        }
                                    }))
                                })), [2]
                            }))
                        }))
                    }, t.prototype.renderReplacedElement = function (A, e, t) {
                        if (t && A.intrinsicWidth > 0 && A.intrinsicHeight > 0) {
                            var n = ea(A), r = Gi(e);
                            this.path(r), this.ctx.save(), this.ctx.clip(), this.ctx.drawImage(t, 0, 0, A.intrinsicWidth, A.intrinsicHeight, n.left, n.top, n.width, n.height), this.ctx.restore()
                        }
                    }, t.prototype.renderNodeContent = function (A) {
                        return n(this, void 0, void 0, (function () {
                            var e, n, i, s, o, l, c, u, h, d, p, f, g, m, B, w, v, _;
                            return r(this, (function (r) {
                                switch (r.label) {
                                    case 0:
                                        this.applyEffects(A.getEffects(4)), e = A.container, n = A.curves, i = e.styles, s = 0, o = e.textNodes, r.label = 1;
                                    case 1:
                                        return s < o.length ? (l = o[s], [4, this.renderTextNode(l, i)]) : [3, 4];
                                    case 2:
                                        r.sent(), r.label = 3;
                                    case 3:
                                        return s++, [3, 1];
                                    case 4:
                                        if (!(e instanceof sr)) return [3, 8];
                                        r.label = 5;
                                    case 5:
                                        return r.trys.push([5, 7, , 8]), [4, this.context.cache.match(e.src)];
                                    case 6:
                                        return B = r.sent(), this.renderReplacedElement(e, n, B), [3, 8];
                                    case 7:
                                        return r.sent(), this.context.logger.error("Error loading image " + e.src), [3, 8];
                                    case 8:
                                        if (e instanceof or && this.renderReplacedElement(e, n, e.canvas), !(e instanceof lr)) return [3, 12];
                                        r.label = 9;
                                    case 9:
                                        return r.trys.push([9, 11, , 12]), [4, this.context.cache.match(e.svg)];
                                    case 10:
                                        return B = r.sent(), this.renderReplacedElement(e, n, B), [3, 12];
                                    case 11:
                                        return r.sent(), this.context.logger.error("Error loading svg " + e.svg.substring(0, 255)), [3, 12];
                                    case 12:
                                        return e instanceof _r && e.tree ? [4, new t(this.context, {
                                            scale: this.options.scale,
                                            backgroundColor: e.backgroundColor,
                                            x: 0,
                                            y: 0,
                                            width: e.width,
                                            height: e.height
                                        }).render(e.tree)] : [3, 14];
                                    case 13:
                                        c = r.sent(), e.width && e.height && this.ctx.drawImage(c, 0, 0, e.width, e.height, e.bounds.left, e.bounds.top, e.bounds.width, e.bounds.height), r.label = 14;
                                    case 14:
                                        if (e instanceof Br && (u = Math.min(e.bounds.width, e.bounds.height), e.type === pr ? e.checked && (this.ctx.save(), this.path([new Li(e.bounds.left + .39363 * u, e.bounds.top + .79 * u), new Li(e.bounds.left + .16 * u, e.bounds.top + .5549 * u), new Li(e.bounds.left + .27347 * u, e.bounds.top + .44071 * u), new Li(e.bounds.left + .39694 * u, e.bounds.top + .5649 * u), new Li(e.bounds.left + .72983 * u, e.bounds.top + .23 * u), new Li(e.bounds.left + .84 * u, e.bounds.top + .34085 * u), new Li(e.bounds.left + .39363 * u, e.bounds.top + .79 * u)]), this.ctx.fillStyle = pe(mr), this.ctx.fill(), this.ctx.restore()) : e.type === fr && e.checked && (this.ctx.save(), this.ctx.beginPath(), this.ctx.arc(e.bounds.left + u / 2, e.bounds.top + u / 2, u / 4, 0, 2 * Math.PI, !0), this.ctx.fillStyle = pe(mr), this.ctx.fill(), this.ctx.restore())), ha(e) && e.value.length) {
                                            switch (h = this.createFontStyle(i), v = h[0], d = h[1], p = this.fontMetrics.getMetrics(v, d).baseline, this.ctx.font = v, this.ctx.fillStyle = pe(i.color), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = pa(e.styles.textAlign), _ = ea(e), f = 0, e.styles.textAlign) {
                                                case 1:
                                                    f += _.width / 2;
                                                    break;
                                                case 2:
                                                    f += _.width
                                            }
                                            g = _.add(f, 0, 0, -_.height / 2 + 1), this.ctx.save(), this.path([new Li(_.left, _.top), new Li(_.left + _.width, _.top), new Li(_.left + _.width, _.top + _.height), new Li(_.left, _.top + _.height)]), this.ctx.clip(), this.renderTextWithLetterSpacing(new jn(e.value, g), i.letterSpacing, p), this.ctx.restore(), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = "left"
                                        }
                                        if (!cn(e.styles.display, 2048)) return [3, 20];
                                        if (null === e.styles.listStyleImage) return [3, 19];
                                        if (0 !== (m = e.styles.listStyleImage).type) return [3, 18];
                                        B = void 0, w = m.url, r.label = 15;
                                    case 15:
                                        return r.trys.push([15, 17, , 18]), [4, this.context.cache.match(w)];
                                    case 16:
                                        return B = r.sent(), this.ctx.drawImage(B, e.bounds.left - (B.width + 10), e.bounds.top), [3, 18];
                                    case 17:
                                        return r.sent(), this.context.logger.error("Error loading list-style-image " + w), [3, 18];
                                    case 18:
                                        return [3, 20];
                                    case 19:
                                        A.listValue && -1 !== e.styles.listStyleType && (v = this.createFontStyle(i)[0], this.ctx.font = v, this.ctx.fillStyle = pe(i.color), this.ctx.textBaseline = "middle", this.ctx.textAlign = "right", _ = new a(e.bounds.left, e.bounds.top + ie(e.styles.paddingTop, e.bounds.width), e.bounds.width, xt(i.lineHeight, i.fontSize.number) / 2 + 1), this.renderTextWithLetterSpacing(new jn(A.listValue, _), i.letterSpacing, xt(i.lineHeight, i.fontSize.number) / 2 + 2), this.ctx.textBaseline = "bottom", this.ctx.textAlign = "left"), r.label = 20;
                                    case 20:
                                        return [2]
                                }
                            }))
                        }))
                    }, t.prototype.renderStackContent = function (A) {
                        return n(this, void 0, void 0, (function () {
                            var e, t, n, i, a, s, o, l, c, u, h, d, p, f, g;
                            return r(this, (function (r) {
                                switch (r.label) {
                                    case 0:
                                        return cn(A.element.container.flags, 16), [4, this.renderNodeBackgroundAndBorders(A.element)];
                                    case 1:
                                        r.sent(), e = 0, t = A.negativeZIndex, r.label = 2;
                                    case 2:
                                        return e < t.length ? (g = t[e], [4, this.renderStack(g)]) : [3, 5];
                                    case 3:
                                        r.sent(), r.label = 4;
                                    case 4:
                                        return e++, [3, 2];
                                    case 5:
                                        return [4, this.renderNodeContent(A.element)];
                                    case 6:
                                        r.sent(), n = 0, i = A.nonInlineLevel, r.label = 7;
                                    case 7:
                                        return n < i.length ? (g = i[n], [4, this.renderNode(g)]) : [3, 10];
                                    case 8:
                                        r.sent(), r.label = 9;
                                    case 9:
                                        return n++, [3, 7];
                                    case 10:
                                        a = 0, s = A.nonPositionedFloats, r.label = 11;
                                    case 11:
                                        return a < s.length ? (g = s[a], [4, this.renderStack(g)]) : [3, 14];
                                    case 12:
                                        r.sent(), r.label = 13;
                                    case 13:
                                        return a++, [3, 11];
                                    case 14:
                                        o = 0, l = A.nonPositionedInlineLevel, r.label = 15;
                                    case 15:
                                        return o < l.length ? (g = l[o], [4, this.renderStack(g)]) : [3, 18];
                                    case 16:
                                        r.sent(), r.label = 17;
                                    case 17:
                                        return o++, [3, 15];
                                    case 18:
                                        c = 0, u = A.inlineLevel, r.label = 19;
                                    case 19:
                                        return c < u.length ? (g = u[c], [4, this.renderNode(g)]) : [3, 22];
                                    case 20:
                                        r.sent(), r.label = 21;
                                    case 21:
                                        return c++, [3, 19];
                                    case 22:
                                        h = 0, d = A.zeroOrAutoZIndexOrTransformedOrOpacity, r.label = 23;
                                    case 23:
                                        return h < d.length ? (g = d[h], [4, this.renderStack(g)]) : [3, 26];
                                    case 24:
                                        r.sent(), r.label = 25;
                                    case 25:
                                        return h++, [3, 23];
                                    case 26:
                                        p = 0, f = A.positiveZIndex, r.label = 27;
                                    case 27:
                                        return p < f.length ? (g = f[p], [4, this.renderStack(g)]) : [3, 30];
                                    case 28:
                                        r.sent(), r.label = 29;
                                    case 29:
                                        return p++, [3, 27];
                                    case 30:
                                        return [2]
                                }
                            }))
                        }))
                    }, t.prototype.mask = function (A) {
                        this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.lineTo(this.canvas.width, 0), this.ctx.lineTo(this.canvas.width, this.canvas.height), this.ctx.lineTo(0, this.canvas.height), this.ctx.lineTo(0, 0), this.formatPath(A.slice(0).reverse()), this.ctx.closePath()
                    }, t.prototype.path = function (A) {
                        this.ctx.beginPath(), this.formatPath(A), this.ctx.closePath()
                    }, t.prototype.formatPath = function (A) {
                        var e = this;
                        A.forEach((function (A, t) {
                            var n = Di(A) ? A.start : A;
                            0 === t ? e.ctx.moveTo(n.x, n.y) : e.ctx.lineTo(n.x, n.y), Di(A) && e.ctx.bezierCurveTo(A.startControl.x, A.startControl.y, A.endControl.x, A.endControl.y, A.end.x, A.end.y)
                        }))
                    }, t.prototype.renderRepeat = function (A, e, t, n) {
                        this.path(A), this.ctx.fillStyle = e, this.ctx.translate(t, n), this.ctx.fill(), this.ctx.translate(-t, -n)
                    }, t.prototype.resizeImage = function (A, e, t) {
                        var n;
                        if (A.width === e && A.height === t) return A;
                        var r = (null !== (n = this.canvas.ownerDocument) && void 0 !== n ? n : document).createElement("canvas");
                        return r.width = Math.max(1, e), r.height = Math.max(1, t), r.getContext("2d").drawImage(A, 0, 0, A.width, A.height, 0, 0, e, t), r
                    }, t.prototype.renderBackgroundImage = function (A) {
                        return n(this, void 0, void 0, (function () {
                            var e, t, n, i, a, s;
                            return r(this, (function (o) {
                                switch (o.label) {
                                    case 0:
                                        e = A.styles.backgroundImage.length - 1, t = function (t) {
                                            var i, a, s, o, l, c, u, h, d, p, f, g, m, B, w, v, _, C, E, U, y, x, M, F,
                                                S, b, Q, T, I, L, R;
                                            return r(this, (function (r) {
                                                switch (r.label) {
                                                    case 0:
                                                        if (0 !== t.type) return [3, 5];
                                                        i = void 0, a = t.url, r.label = 1;
                                                    case 1:
                                                        return r.trys.push([1, 3, , 4]), [4, n.context.cache.match(a)];
                                                    case 2:
                                                        return i = r.sent(), [3, 4];
                                                    case 3:
                                                        return r.sent(), n.context.logger.error("Error loading background-image " + a), [3, 4];
                                                    case 4:
                                                        return i && (s = ta(A, e, [i.width, i.height, i.width / i.height]), v = s[0], x = s[1], M = s[2], E = s[3], U = s[4], B = n.ctx.createPattern(n.resizeImage(i, E, U), "repeat"), n.renderRepeat(v, B, x, M)), [3, 6];
                                                    case 5:
                                                        1 === t.type ? (o = ta(A, e, [null, null, null]), v = o[0], x = o[1], M = o[2], E = o[3], U = o[4], l = Me(t.angle, E, U), c = l[0], u = l[1], h = l[2], d = l[3], p = l[4], (f = document.createElement("canvas")).width = E, f.height = U, g = f.getContext("2d"), m = g.createLinearGradient(u, d, h, p), xe(t.stops, c).forEach((function (A) {
                                                            return m.addColorStop(A.stop, pe(A.color))
                                                        })), g.fillStyle = m, g.fillRect(0, 0, E, U), E > 0 && U > 0 && (B = n.ctx.createPattern(f, "repeat"), n.renderRepeat(v, B, x, M))) : function (A) {
                                                            return 2 === A.type
                                                        }(t) && (w = ta(A, e, [null, null, null]), v = w[0], _ = w[1], C = w[2], E = w[3], U = w[4], y = 0 === t.position.length ? [te] : t.position, x = ie(y[0], E), M = ie(y[y.length - 1], U), F = function (A, e, t, n, r) {
                                                            var i = 0, a = 0;
                                                            switch (A.size) {
                                                                case 0:
                                                                    0 === A.shape ? i = a = Math.min(Math.abs(e), Math.abs(e - n), Math.abs(t), Math.abs(t - r)) : 1 === A.shape && (i = Math.min(Math.abs(e), Math.abs(e - n)), a = Math.min(Math.abs(t), Math.abs(t - r)));
                                                                    break;
                                                                case 2:
                                                                    if (0 === A.shape) i = a = Math.min(Fe(e, t), Fe(e, t - r), Fe(e - n, t), Fe(e - n, t - r)); else if (1 === A.shape) {
                                                                        var s = Math.min(Math.abs(t), Math.abs(t - r)) / Math.min(Math.abs(e), Math.abs(e - n)),
                                                                            o = Se(n, r, e, t, !0), l = o[0], c = o[1];
                                                                        a = s * (i = Fe(l - e, (c - t) / s))
                                                                    }
                                                                    break;
                                                                case 1:
                                                                    0 === A.shape ? i = a = Math.max(Math.abs(e), Math.abs(e - n), Math.abs(t), Math.abs(t - r)) : 1 === A.shape && (i = Math.max(Math.abs(e), Math.abs(e - n)), a = Math.max(Math.abs(t), Math.abs(t - r)));
                                                                    break;
                                                                case 3:
                                                                    if (0 === A.shape) i = a = Math.max(Fe(e, t), Fe(e, t - r), Fe(e - n, t), Fe(e - n, t - r)); else if (1 === A.shape) {
                                                                        s = Math.max(Math.abs(t), Math.abs(t - r)) / Math.max(Math.abs(e), Math.abs(e - n));
                                                                        var u = Se(n, r, e, t, !1);
                                                                        l = u[0], c = u[1], a = s * (i = Fe(l - e, (c - t) / s))
                                                                    }
                                                            }
                                                            return Array.isArray(A.size) && (i = ie(A.size[0], n), a = 2 === A.size.length ? ie(A.size[1], r) : i), [i, a]
                                                        }(t, x, M, E, U), S = F[0], b = F[1], S > 0 && b > 0 && (Q = n.ctx.createRadialGradient(_ + x, C + M, 0, _ + x, C + M, S), xe(t.stops, 2 * S).forEach((function (A) {
                                                            return Q.addColorStop(A.stop, pe(A.color))
                                                        })), n.path(v), n.ctx.fillStyle = Q, S !== b ? (T = A.bounds.left + .5 * A.bounds.width, I = A.bounds.top + .5 * A.bounds.height, R = 1 / (L = b / S), n.ctx.save(), n.ctx.translate(T, I), n.ctx.transform(1, 0, 0, L, 0, 0), n.ctx.translate(-T, -I), n.ctx.fillRect(_, R * (C - I) + I, E, U * R), n.ctx.restore()) : n.ctx.fill())), r.label = 6;
                                                    case 6:
                                                        return e--, [2]
                                                }
                                            }))
                                        }, n = this, i = 0, a = A.styles.backgroundImage.slice(0).reverse(), o.label = 1;
                                    case 1:
                                        return i < a.length ? (s = a[i], [5, t(s)]) : [3, 4];
                                    case 2:
                                        o.sent(), o.label = 3;
                                    case 3:
                                        return i++, [3, 1];
                                    case 4:
                                        return [2]
                                }
                            }))
                        }))
                    }, t.prototype.renderSolidBorder = function (A, e, t) {
                        return n(this, void 0, void 0, (function () {
                            return r(this, (function (n) {
                                return this.path(Zi(t, e)), this.ctx.fillStyle = pe(A), this.ctx.fill(), [2]
                            }))
                        }))
                    }, t.prototype.renderDoubleBorder = function (A, e, t, i) {
                        return n(this, void 0, void 0, (function () {
                            var n, a;
                            return r(this, (function (r) {
                                switch (r.label) {
                                    case 0:
                                        return e < 3 ? [4, this.renderSolidBorder(A, t, i)] : [3, 2];
                                    case 1:
                                        return r.sent(), [2];
                                    case 2:
                                        return n = function (A, e) {
                                            switch (e) {
                                                case 0:
                                                    return $i(A.topLeftBorderBox, A.topLeftBorderDoubleOuterBox, A.topRightBorderBox, A.topRightBorderDoubleOuterBox);
                                                case 1:
                                                    return $i(A.topRightBorderBox, A.topRightBorderDoubleOuterBox, A.bottomRightBorderBox, A.bottomRightBorderDoubleOuterBox);
                                                case 2:
                                                    return $i(A.bottomRightBorderBox, A.bottomRightBorderDoubleOuterBox, A.bottomLeftBorderBox, A.bottomLeftBorderDoubleOuterBox);
                                                default:
                                                    return $i(A.bottomLeftBorderBox, A.bottomLeftBorderDoubleOuterBox, A.topLeftBorderBox, A.topLeftBorderDoubleOuterBox)
                                            }
                                        }(i, t), this.path(n), this.ctx.fillStyle = pe(A), this.ctx.fill(), a = function (A, e) {
                                            switch (e) {
                                                case 0:
                                                    return $i(A.topLeftBorderDoubleInnerBox, A.topLeftPaddingBox, A.topRightBorderDoubleInnerBox, A.topRightPaddingBox);
                                                case 1:
                                                    return $i(A.topRightBorderDoubleInnerBox, A.topRightPaddingBox, A.bottomRightBorderDoubleInnerBox, A.bottomRightPaddingBox);
                                                case 2:
                                                    return $i(A.bottomRightBorderDoubleInnerBox, A.bottomRightPaddingBox, A.bottomLeftBorderDoubleInnerBox, A.bottomLeftPaddingBox);
                                                default:
                                                    return $i(A.bottomLeftBorderDoubleInnerBox, A.bottomLeftPaddingBox, A.topLeftBorderDoubleInnerBox, A.topLeftPaddingBox)
                                            }
                                        }(i, t), this.path(a), this.ctx.fill(), [2]
                                }
                            }))
                        }))
                    }, t.prototype.renderNodeBackgroundAndBorders = function (A) {
                        return n(this, void 0, void 0, (function () {
                            var e, t, n, i, a, s, o, l, c = this;
                            return r(this, (function (r) {
                                switch (r.label) {
                                    case 0:
                                        return this.applyEffects(A.getEffects(2)), e = A.container.styles, t = !de(e.backgroundColor) || e.backgroundImage.length, n = [{
                                            style: e.borderTopStyle,
                                            color: e.borderTopColor,
                                            width: e.borderTopWidth
                                        }, {
                                            style: e.borderRightStyle,
                                            color: e.borderRightColor,
                                            width: e.borderRightWidth
                                        }, {
                                            style: e.borderBottomStyle,
                                            color: e.borderBottomColor,
                                            width: e.borderBottomWidth
                                        }, {
                                            style: e.borderLeftStyle,
                                            color: e.borderLeftColor,
                                            width: e.borderLeftWidth
                                        }], i = da(aa(e.backgroundClip, 0), A.curves), t || e.boxShadow.length ? (this.ctx.save(), this.path(i), this.ctx.clip(), de(e.backgroundColor) || (this.ctx.fillStyle = pe(e.backgroundColor), this.ctx.fill()), [4, this.renderBackgroundImage(A.container)]) : [3, 2];
                                    case 1:
                                        r.sent(), this.ctx.restore(), e.boxShadow.slice(0).reverse().forEach((function (e) {
                                            c.ctx.save();
                                            var t, n, r, i, a, s = Oi(A.curves), o = e.inset ? 0 : 1e4,
                                                l = (t = s, n = -o + (e.inset ? 1 : -1) * e.spread.number, r = (e.inset ? 1 : -1) * e.spread.number, i = e.spread.number * (e.inset ? -2 : 2), a = e.spread.number * (e.inset ? -2 : 2), t.map((function (A, e) {
                                                    switch (e) {
                                                        case 0:
                                                            return A.add(n, r);
                                                        case 1:
                                                            return A.add(n + i, r);
                                                        case 2:
                                                            return A.add(n + i, r + a);
                                                        case 3:
                                                            return A.add(n, r + a)
                                                    }
                                                    return A
                                                })));
                                            e.inset ? (c.path(s), c.ctx.clip(), c.mask(l)) : (c.mask(s), c.ctx.clip(), c.path(l)), c.ctx.shadowOffsetX = e.offsetX.number + o, c.ctx.shadowOffsetY = e.offsetY.number, c.ctx.shadowColor = pe(e.color), c.ctx.shadowBlur = e.blur.number, c.ctx.fillStyle = e.inset ? pe(e.color) : "rgba(0,0,0,1)", c.ctx.fill(), c.ctx.restore()
                                        })), r.label = 2;
                                    case 2:
                                        a = 0, s = 0, o = n, r.label = 3;
                                    case 3:
                                        return s < o.length ? 0 !== (l = o[s]).style && !de(l.color) && l.width > 0 ? 2 !== l.style ? [3, 5] : [4, this.renderDashedDottedBorder(l.color, l.width, a, A.curves, 2)] : [3, 11] : [3, 13];
                                    case 4:
                                        return r.sent(), [3, 11];
                                    case 5:
                                        return 3 !== l.style ? [3, 7] : [4, this.renderDashedDottedBorder(l.color, l.width, a, A.curves, 3)];
                                    case 6:
                                        return r.sent(), [3, 11];
                                    case 7:
                                        return 4 !== l.style ? [3, 9] : [4, this.renderDoubleBorder(l.color, l.width, a, A.curves)];
                                    case 8:
                                        return r.sent(), [3, 11];
                                    case 9:
                                        return [4, this.renderSolidBorder(l.color, a, A.curves)];
                                    case 10:
                                        r.sent(), r.label = 11;
                                    case 11:
                                        a++, r.label = 12;
                                    case 12:
                                        return s++, [3, 3];
                                    case 13:
                                        return [2]
                                }
                            }))
                        }))
                    }, t.prototype.renderDashedDottedBorder = function (A, e, t, i, a) {
                        return n(this, void 0, void 0, (function () {
                            var n, s, o, l, c, u, h, d, p, f, g, m, B, w, v, _;
                            return r(this, (function (r) {
                                return this.ctx.save(), n = function (A, e) {
                                    switch (e) {
                                        case 0:
                                            return qi(A.topLeftBorderStroke, A.topRightBorderStroke);
                                        case 1:
                                            return qi(A.topRightBorderStroke, A.bottomRightBorderStroke);
                                        case 2:
                                            return qi(A.bottomRightBorderStroke, A.bottomLeftBorderStroke);
                                        default:
                                            return qi(A.bottomLeftBorderStroke, A.topLeftBorderStroke)
                                    }
                                }(i, t), s = Zi(i, t), 2 === a && (this.path(s), this.ctx.clip()), Di(s[0]) ? (o = s[0].start.x, l = s[0].start.y) : (o = s[0].x, l = s[0].y), Di(s[1]) ? (c = s[1].end.x, u = s[1].end.y) : (c = s[1].x, u = s[1].y), h = 0 === t || 2 === t ? Math.abs(o - c) : Math.abs(l - u), this.ctx.beginPath(), 3 === a ? this.formatPath(n) : this.formatPath(s.slice(0, 2)), d = e < 3 ? 3 * e : 2 * e, p = e < 3 ? 2 * e : e, 3 === a && (d = e, p = e), f = !0, h <= 2 * d ? f = !1 : h <= 2 * d + p ? (d *= g = h / (2 * d + p), p *= g) : (m = Math.floor((h + p) / (d + p)), B = (h - m * d) / (m - 1), p = (w = (h - (m + 1) * d) / m) <= 0 || Math.abs(p - B) < Math.abs(p - w) ? B : w), f && (3 === a ? this.ctx.setLineDash([0, d + p]) : this.ctx.setLineDash([d, p])), 3 === a ? (this.ctx.lineCap = "round", this.ctx.lineWidth = e) : this.ctx.lineWidth = 2 * e + 1.1, this.ctx.strokeStyle = pe(A), this.ctx.stroke(), this.ctx.setLineDash([]), 2 === a && (Di(s[0]) && (v = s[3], _ = s[0], this.ctx.beginPath(), this.formatPath([new Li(v.end.x, v.end.y), new Li(_.start.x, _.start.y)]), this.ctx.stroke()), Di(s[1]) && (v = s[1], _ = s[2], this.ctx.beginPath(), this.formatPath([new Li(v.end.x, v.end.y), new Li(_.start.x, _.start.y)]), this.ctx.stroke())), this.ctx.restore(), [2]
                            }))
                        }))
                    }, t.prototype.render = function (A) {
                        return n(this, void 0, void 0, (function () {
                            var e;
                            return r(this, (function (t) {
                                switch (t.label) {
                                    case 0:
                                        return this.options.backgroundColor && (this.ctx.fillStyle = pe(this.options.backgroundColor), this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height)), n = new Yi(A, null), r = new Xi(n), Ji(n, r, r, i = []), ji(n.container, i), e = r, [4, this.renderStack(e)];
                                    case 1:
                                        return t.sent(), this.applyEffects([]), [2, this.canvas]
                                }
                                var n, r, i
                            }))
                        }))
                    }, t
                }(ca), ha = function (A) {
                    return A instanceof vr || A instanceof wr || A instanceof Br && A.type !== fr && A.type !== pr
                }, da = function (A, e) {
                    switch (A) {
                        case 0:
                            return Oi(e);
                        case 2:
                            return function (A) {
                                return [A.topLeftContentBox, A.topRightContentBox, A.bottomRightContentBox, A.bottomLeftContentBox]
                            }(e);
                        default:
                            return Gi(e)
                    }
                }, pa = function (A) {
                    switch (A) {
                        case 1:
                            return "center";
                        case 2:
                            return "right";
                        default:
                            return "left"
                    }
                }, fa = ["-apple-system", "system-ui"], ga = function (A) {
                    return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? A.filter((function (A) {
                        return -1 === fa.indexOf(A)
                    })) : A
                }, ma = function (A) {
                    function t(e, t) {
                        var n = A.call(this, e, t) || this;
                        return n.canvas = t.canvas ? t.canvas : document.createElement("canvas"), n.ctx = n.canvas.getContext("2d"), n.options = t, n.canvas.width = Math.floor(t.width * t.scale), n.canvas.height = Math.floor(t.height * t.scale), n.canvas.style.width = t.width + "px", n.canvas.style.height = t.height + "px", n.ctx.scale(n.options.scale, n.options.scale), n.ctx.translate(-t.x, -t.y), n.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + t.width + "x" + t.height + " at " + t.x + "," + t.y + ") with scale " + t.scale), n
                    }

                    return e(t, A), t.prototype.render = function (A) {
                        return n(this, void 0, void 0, (function () {
                            var e, t;
                            return r(this, (function (n) {
                                switch (n.label) {
                                    case 0:
                                        return e = Xn(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, A), [4, Ba(e)];
                                    case 1:
                                        return t = n.sent(), this.options.backgroundColor && (this.ctx.fillStyle = pe(this.options.backgroundColor), this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale)), this.ctx.drawImage(t, -this.options.x * this.options.scale, -this.options.y * this.options.scale), [2, this.canvas]
                                }
                            }))
                        }))
                    }, t
                }(ca), Ba = function (A) {
                    return new Promise((function (e, t) {
                        var n = new Image;
                        n.onload = function () {
                            e(n)
                        }, n.onerror = t, n.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent((new XMLSerializer).serializeToString(A))
                    }))
                }, wa = function () {
                    function A(A) {
                        var e = A.id, t = A.enabled;
                        this.id = e, this.enabled = t, this.start = Date.now()
                    }

                    return A.prototype.debug = function () {
                        for (var A = [], e = 0; e < arguments.length; e++) A[e] = arguments[e];
                        this.enabled && ("undefined" != typeof window && window.console && "function" == typeof console.debug ? console.debug.apply(console, i([this.id, this.getTime() + "ms"], A)) : this.info.apply(this, A))
                    }, A.prototype.getTime = function () {
                        return Date.now() - this.start
                    }, A.prototype.info = function () {
                        for (var A = [], e = 0; e < arguments.length; e++) A[e] = arguments[e];
                        this.enabled && "undefined" != typeof window && window.console && "function" == typeof console.info && console.info.apply(console, i([this.id, this.getTime() + "ms"], A))
                    }, A.prototype.warn = function () {
                        for (var A = [], e = 0; e < arguments.length; e++) A[e] = arguments[e];
                        this.enabled && ("undefined" != typeof window && window.console && "function" == typeof console.warn ? console.warn.apply(console, i([this.id, this.getTime() + "ms"], A)) : this.info.apply(this, A))
                    }, A.prototype.error = function () {
                        for (var A = [], e = 0; e < arguments.length; e++) A[e] = arguments[e];
                        this.enabled && ("undefined" != typeof window && window.console && "function" == typeof console.error ? console.error.apply(console, i([this.id, this.getTime() + "ms"], A)) : this.info.apply(this, A))
                    }, A.instances = {}, A
                }(), va = function () {
                    function A(e, t) {
                        var n;
                        this.windowBounds = t, this.instanceName = "#" + A.instanceCount++, this.logger = new wa({
                            id: this.instanceName,
                            enabled: e.logging
                        }), this.cache = null !== (n = e.cache) && void 0 !== n ? n : new yi(this, e)
                    }

                    return A.instanceCount = 1, A
                }();
                "undefined" != typeof window && Ui.setContext(window);
                var _a = function (A, e) {
                    return n(void 0, void 0, void 0, (function () {
                        var n, i, o, l, c, u, h, d, p, f, g, m, B, w, v, _, C, E, U, y, x, M, F, S, b, Q, T, I, L, R, H,
                            D, P, N, O, G, V, K;
                        return r(this, (function (r) {
                            switch (r.label) {
                                case 0:
                                    if (!A || "object" != typeof A) return [2, Promise.reject("Invalid element provided as first argument")];
                                    if (!(n = A.ownerDocument)) throw new Error("Element is not attached to a Document");
                                    if (!(i = n.defaultView)) throw new Error("Document is not attached to a Window");
                                    return o = {
                                        allowTaint: null !== (M = e.allowTaint) && void 0 !== M && M,
                                        imageTimeout: null !== (F = e.imageTimeout) && void 0 !== F ? F : 15e3,
                                        proxy: e.proxy,
                                        useCORS: null !== (S = e.useCORS) && void 0 !== S && S
                                    }, l = t({
                                        logging: null === (b = e.logging) || void 0 === b || b,
                                        cache: e.cache
                                    }, o), c = {
                                        windowWidth: null !== (Q = e.windowWidth) && void 0 !== Q ? Q : i.innerWidth,
                                        windowHeight: null !== (T = e.windowHeight) && void 0 !== T ? T : i.innerHeight,
                                        scrollX: null !== (I = e.scrollX) && void 0 !== I ? I : i.pageXOffset,
                                        scrollY: null !== (L = e.scrollY) && void 0 !== L ? L : i.pageYOffset
                                    }, u = new a(c.scrollX, c.scrollY, c.windowWidth, c.windowHeight), h = new va(l, u), d = null !== (R = e.foreignObjectRendering) && void 0 !== R && R, p = {
                                        allowTaint: null !== (H = e.allowTaint) && void 0 !== H && H,
                                        onclone: e.onclone,
                                        ignoreElements: e.ignoreElements,
                                        inlineImages: d,
                                        copyStyles: d
                                    }, h.logger.debug("Starting document clone with size " + u.width + "x" + u.height + " scrolled to " + -u.left + "," + -u.top), f = new oi(h, A, p), (g = f.clonedReferenceElement) ? [4, f.toIFrame(n, u)] : [2, Promise.reject("Unable to find element in cloned iframe")];
                                case 1:
                                    return m = r.sent(), B = Hr(g) || "HTML" === g.tagName ? function (A) {
                                        var e = A.body, t = A.documentElement;
                                        if (!e || !t) throw new Error("Unable to get document size");
                                        var n = Math.max(Math.max(e.scrollWidth, t.scrollWidth), Math.max(e.offsetWidth, t.offsetWidth), Math.max(e.clientWidth, t.clientWidth)),
                                            r = Math.max(Math.max(e.scrollHeight, t.scrollHeight), Math.max(e.offsetHeight, t.offsetHeight), Math.max(e.clientHeight, t.clientHeight));
                                        return new a(0, 0, n, r)
                                    }(g.ownerDocument) : s(h, g), w = B.width, v = B.height, _ = B.left, C = B.top, E = Ca(h, g, e.backgroundColor), U = {
                                        canvas: e.canvas,
                                        backgroundColor: E,
                                        scale: null !== (P = null !== (D = e.scale) && void 0 !== D ? D : i.devicePixelRatio) && void 0 !== P ? P : 1,
                                        x: (null !== (N = e.x) && void 0 !== N ? N : 0) + _,
                                        y: (null !== (O = e.y) && void 0 !== O ? O : 0) + C,
                                        width: null !== (G = e.width) && void 0 !== G ? G : Math.ceil(w),
                                        height: null !== (V = e.height) && void 0 !== V ? V : Math.ceil(v)
                                    }, d ? (h.logger.debug("Document cloned, using foreign object rendering"), [4, new ma(h, U).render(g)]) : [3, 3];
                                case 2:
                                    return y = r.sent(), [3, 5];
                                case 3:
                                    return h.logger.debug("Document cloned, element located at " + _ + "," + C + " with size " + w + "x" + v + " using computed rendering"), h.logger.debug("Starting DOM parsing"), x = yr(h, g), E === x.styles.backgroundColor && (x.styles.backgroundColor = Ce.TRANSPARENT), h.logger.debug("Starting renderer for element at " + U.x + "," + U.y + " with size " + U.width + "x" + U.height), [4, new ua(h, U).render(x)];
                                case 4:
                                    y = r.sent(), r.label = 5;
                                case 5:
                                    return (null === (K = e.removeContainer) || void 0 === K || K) && (oi.destroy(m) || h.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore")), h.logger.debug("Finished rendering"), [2, y]
                            }
                        }))
                    }))
                }, Ca = function (A, e, t) {
                    var n = e.ownerDocument,
                        r = n.documentElement ? _e(A, getComputedStyle(n.documentElement).backgroundColor) : Ce.TRANSPARENT,
                        i = n.body ? _e(A, getComputedStyle(n.body).backgroundColor) : Ce.TRANSPARENT,
                        a = "string" == typeof t ? _e(A, t) : null === t ? Ce.TRANSPARENT : 4294967295;
                    return e === n.documentElement ? de(r) ? de(i) ? a : i : r : a
                };
                return function (A, e) {
                    return void 0 === e && (e = {}), _a(A, e)
                }
            }()
        }, 72: A => {
            "use strict";
            var e = [];

            function t(A) {
                for (var t = -1, n = 0; n < e.length; n++) if (e[n].identifier === A) {
                    t = n;
                    break
                }
                return t
            }

            function n(A, n) {
                for (var i = {}, a = [], s = 0; s < A.length; s++) {
                    var o = A[s], l = n.base ? o[0] + n.base : o[0], c = i[l] || 0, u = "".concat(l, " ").concat(c);
                    i[l] = c + 1;
                    var h = t(u), d = {css: o[1], media: o[2], sourceMap: o[3], supports: o[4], layer: o[5]};
                    if (-1 !== h) e[h].references++, e[h].updater(d); else {
                        var p = r(d, n);
                        n.byIndex = s, e.splice(s, 0, {identifier: u, updater: p, references: 1})
                    }
                    a.push(u)
                }
                return a
            }

            function r(A, e) {
                var t = e.domAPI(e);
                return t.update(A), function (e) {
                    if (e) {
                        if (e.css === A.css && e.media === A.media && e.sourceMap === A.sourceMap && e.supports === A.supports && e.layer === A.layer) return;
                        t.update(A = e)
                    } else t.remove()
                }
            }

            A.exports = function (A, r) {
                var i = n(A = A || [], r = r || {});
                return function (A) {
                    A = A || [];
                    for (var a = 0; a < i.length; a++) {
                        var s = t(i[a]);
                        e[s].references--
                    }
                    for (var o = n(A, r), l = 0; l < i.length; l++) {
                        var c = t(i[l]);
                        0 === e[c].references && (e[c].updater(), e.splice(c, 1))
                    }
                    i = o
                }
            }
        }, 659: A => {
            "use strict";
            var e = {};
            A.exports = function (A, t) {
                var n = function (A) {
                    if (void 0 === e[A]) {
                        var t = document.querySelector(A);
                        if (window.HTMLIFrameElement && t instanceof window.HTMLIFrameElement) try {
                            t = t.contentDocument.head
                        } catch (A) {
                            t = null
                        }
                        e[A] = t
                    }
                    return e[A]
                }(A);
                if (!n) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                n.appendChild(t)
            }
        }, 540: A => {
            "use strict";
            A.exports = function (A) {
                var e = document.createElement("style");
                return A.setAttributes(e, A.attributes), A.insert(e, A.options), e
            }
        }, 56: (A, e, t) => {
            "use strict";
            A.exports = function (A) {
                var e = t.nc;
                e && A.setAttribute("nonce", e)
            }
        }, 825: A => {
            "use strict";
            A.exports = function (A) {
                if ("undefined" == typeof document) return {
                    update: function () {
                    }, remove: function () {
                    }
                };
                var e = A.insertStyleElement(A);
                return {
                    update: function (t) {
                        !function (A, e, t) {
                            var n = "";
                            t.supports && (n += "@supports (".concat(t.supports, ") {")), t.media && (n += "@media ".concat(t.media, " {"));
                            var r = void 0 !== t.layer;
                            r && (n += "@layer".concat(t.layer.length > 0 ? " ".concat(t.layer) : "", " {")), n += t.css, r && (n += "}"), t.media && (n += "}"), t.supports && (n += "}");
                            var i = t.sourceMap;
                            i && "undefined" != typeof btoa && (n += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i)))), " */")), e.styleTagTransform(n, A, e.options)
                        }(e, A, t)
                    }, remove: function () {
                        !function (A) {
                            if (null === A.parentNode) return !1;
                            A.parentNode.removeChild(A)
                        }(e)
                    }
                }
            }
        }, 113: A => {
            "use strict";
            A.exports = function (A, e) {
                if (e.styleSheet) e.styleSheet.cssText = A; else {
                    for (; e.firstChild;) e.removeChild(e.firstChild);
                    e.appendChild(document.createTextNode(A))
                }
            }
        }, 258: (A, e, t) => {
            "use strict";
            A.exports = t.p + "2864c3d6f72c1fe2d590.png"
        }, 547: (A, e, t) => {
            "use strict";
            A.exports = t.p + "4075c4731db78eeb009c.css"
        }
    }, e = {};

    function t(n) {
        var r = e[n];
        if (void 0 !== r) return r.exports;
        var i = e[n] = {id: n, exports: {}};
        return A[n].call(i.exports, i, i.exports, t), i.exports
    }

    t.m = A, t.n = A => {
        var e = A && A.__esModule ? () => A.default : () => A;
        return t.d(e, {a: e}), e
    }, t.d = (A, e) => {
        for (var n in e) t.o(e, n) && !t.o(A, n) && Object.defineProperty(A, n, {enumerable: !0, get: e[n]})
    }, t.g = function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (A) {
            if ("object" == typeof window) return window
        }
    }(), t.o = (A, e) => Object.prototype.hasOwnProperty.call(A, e), (() => {
        var A;
        t.g.importScripts && (A = t.g.location + "");
        var e = t.g.document;
        if (!A && e && (e.currentScript && (A = e.currentScript.src), !A)) {
            var n = e.getElementsByTagName("script");
            if (n.length) for (var r = n.length - 1; r > -1 && (!A || !/^http(s?):/.test(A));) A = n[r--].src
        }
        if (!A) throw new Error("Automatic publicPath is not supported in this browser");
        A = A.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"), t.p = A
    })(), t.b = document.baseURI || self.location.href, t.nc = void 0, (() => {
        "use strict";
        var A = t(385), e = t.n(A), n = new URL(t(258), t.b), r = new URL(t(547), t.b);
        e()(n), e()(r);
        var i = t(72), a = t.n(i), s = t(825), o = t.n(s), l = t(659), c = t.n(l), u = t(56), h = t.n(u), d = t(540),
            p = t.n(d), f = t(113), g = t.n(f), m = t(365), B = {};
        B.styleTagTransform = g(), B.setAttributes = h(), B.insert = c().bind(null, "head"), B.domAPI = o(), B.insertStyleElement = p(), a()(m.A, B), m.A && m.A.locals && m.A.locals;
        const w = "162", v = 1, _ = 2, C = 3, E = 100, U = 0, y = 1, x = 2, M = 0, F = 1, S = 2, b = 3, Q = 4, T = 5,
            I = 6, L = 7, R = 301, H = 302, D = 306, P = 1e3, N = 1001, O = 1002, G = 1003, V = 1005, K = 1006,
            k = 1007, z = 1008, W = 1009, X = 1012, Y = 1014, J = 1015, j = 1016, Z = 1020, q = 1023, $ = 1026,
            AA = 1027, eA = 33776, tA = 33777, nA = 33778, rA = 33779, iA = 36492, aA = 2300, sA = 2301, oA = 2302,
            lA = "", cA = "srgb", uA = "srgb-linear", hA = "display-p3", dA = "display-p3-linear", pA = "linear",
            fA = "srgb", gA = "rec709", mA = "p3", BA = 7680, wA = "300 es", vA = 1035, _A = 2e3, CA = 2001;

        class EA {
            addEventListener(A, e) {
                void 0 === this._listeners && (this._listeners = {});
                const t = this._listeners;
                void 0 === t[A] && (t[A] = []), -1 === t[A].indexOf(e) && t[A].push(e)
            }

            hasEventListener(A, e) {
                if (void 0 === this._listeners) return !1;
                const t = this._listeners;
                return void 0 !== t[A] && -1 !== t[A].indexOf(e)
            }

            removeEventListener(A, e) {
                if (void 0 === this._listeners) return;
                const t = this._listeners[A];
                if (void 0 !== t) {
                    const A = t.indexOf(e);
                    -1 !== A && t.splice(A, 1)
                }
            }

            dispatchEvent(A) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[A.type];
                if (void 0 !== e) {
                    A.target = this;
                    const t = e.slice(0);
                    for (let e = 0, n = t.length; e < n; e++) t[e].call(this, A);
                    A.target = null
                }
            }
        }

        const UA = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let yA = 1234567;
        const xA = Math.PI / 180, MA = 180 / Math.PI;

        function FA() {
            const A = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0,
                t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0;
            return (UA[255 & A] + UA[A >> 8 & 255] + UA[A >> 16 & 255] + UA[A >> 24 & 255] + "-" + UA[255 & e] + UA[e >> 8 & 255] + "-" + UA[e >> 16 & 15 | 64] + UA[e >> 24 & 255] + "-" + UA[63 & t | 128] + UA[t >> 8 & 255] + "-" + UA[t >> 16 & 255] + UA[t >> 24 & 255] + UA[255 & n] + UA[n >> 8 & 255] + UA[n >> 16 & 255] + UA[n >> 24 & 255]).toLowerCase()
        }

        function SA(A, e, t) {
            return Math.max(e, Math.min(t, A))
        }

        function bA(A, e) {
            return (A % e + e) % e
        }

        function QA(A, e, t) {
            return (1 - t) * A + t * e
        }

        function TA(A) {
            return 0 == (A & A - 1) && 0 !== A
        }

        function IA(A) {
            return Math.pow(2, Math.floor(Math.log(A) / Math.LN2))
        }

        function LA(A, e) {
            switch (e.constructor) {
                case Float32Array:
                    return A;
                case Uint32Array:
                    return A / 4294967295;
                case Uint16Array:
                    return A / 65535;
                case Uint8Array:
                    return A / 255;
                case Int32Array:
                    return Math.max(A / 2147483647, -1);
                case Int16Array:
                    return Math.max(A / 32767, -1);
                case Int8Array:
                    return Math.max(A / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        function RA(A, e) {
            switch (e.constructor) {
                case Float32Array:
                    return A;
                case Uint32Array:
                    return Math.round(4294967295 * A);
                case Uint16Array:
                    return Math.round(65535 * A);
                case Uint8Array:
                    return Math.round(255 * A);
                case Int32Array:
                    return Math.round(2147483647 * A);
                case Int16Array:
                    return Math.round(32767 * A);
                case Int8Array:
                    return Math.round(127 * A);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        const HA = {
            DEG2RAD: xA,
            RAD2DEG: MA,
            generateUUID: FA,
            clamp: SA,
            euclideanModulo: bA,
            mapLinear: function (A, e, t, n, r) {
                return n + (A - e) * (r - n) / (t - e)
            },
            inverseLerp: function (A, e, t) {
                return A !== e ? (t - A) / (e - A) : 0
            },
            lerp: QA,
            damp: function (A, e, t, n) {
                return QA(A, e, 1 - Math.exp(-t * n))
            },
            pingpong: function (A, e = 1) {
                return e - Math.abs(bA(A, 2 * e) - e)
            },
            smoothstep: function (A, e, t) {
                return A <= e ? 0 : A >= t ? 1 : (A = (A - e) / (t - e)) * A * (3 - 2 * A)
            },
            smootherstep: function (A, e, t) {
                return A <= e ? 0 : A >= t ? 1 : (A = (A - e) / (t - e)) * A * A * (A * (6 * A - 15) + 10)
            },
            randInt: function (A, e) {
                return A + Math.floor(Math.random() * (e - A + 1))
            },
            randFloat: function (A, e) {
                return A + Math.random() * (e - A)
            },
            randFloatSpread: function (A) {
                return A * (.5 - Math.random())
            },
            seededRandom: function (A) {
                void 0 !== A && (yA = A);
                let e = yA += 1831565813;
                return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
            },
            degToRad: function (A) {
                return A * xA
            },
            radToDeg: function (A) {
                return A * MA
            },
            isPowerOfTwo: TA,
            ceilPowerOfTwo: function (A) {
                return Math.pow(2, Math.ceil(Math.log(A) / Math.LN2))
            },
            floorPowerOfTwo: IA,
            setQuaternionFromProperEuler: function (A, e, t, n, r) {
                const i = Math.cos, a = Math.sin, s = i(t / 2), o = a(t / 2), l = i((e + n) / 2), c = a((e + n) / 2),
                    u = i((e - n) / 2), h = a((e - n) / 2), d = i((n - e) / 2), p = a((n - e) / 2);
                switch (r) {
                    case"XYX":
                        A.set(s * c, o * u, o * h, s * l);
                        break;
                    case"YZY":
                        A.set(o * h, s * c, o * u, s * l);
                        break;
                    case"ZXZ":
                        A.set(o * u, o * h, s * c, s * l);
                        break;
                    case"XZX":
                        A.set(s * c, o * p, o * d, s * l);
                        break;
                    case"YXY":
                        A.set(o * d, s * c, o * p, s * l);
                        break;
                    case"ZYZ":
                        A.set(o * p, o * d, s * c, s * l);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: RA,
            denormalize: LA
        };

        class DA {
            constructor(A = 0, e = 0) {
                DA.prototype.isVector2 = !0, this.x = A, this.y = e
            }

            get width() {
                return this.x
            }

            set width(A) {
                this.x = A
            }

            get height() {
                return this.y
            }

            set height(A) {
                this.y = A
            }

            set(A, e) {
                return this.x = A, this.y = e, this
            }

            setScalar(A) {
                return this.x = A, this.y = A, this
            }

            setX(A) {
                return this.x = A, this
            }

            setY(A) {
                return this.y = A, this
            }

            setComponent(A, e) {
                switch (A) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + A)
                }
                return this
            }

            getComponent(A) {
                switch (A) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + A)
                }
            }

            clone() {
                return new this.constructor(this.x, this.y)
            }

            copy(A) {
                return this.x = A.x, this.y = A.y, this
            }

            add(A) {
                return this.x += A.x, this.y += A.y, this
            }

            addScalar(A) {
                return this.x += A, this.y += A, this
            }

            addVectors(A, e) {
                return this.x = A.x + e.x, this.y = A.y + e.y, this
            }

            addScaledVector(A, e) {
                return this.x += A.x * e, this.y += A.y * e, this
            }

            sub(A) {
                return this.x -= A.x, this.y -= A.y, this
            }

            subScalar(A) {
                return this.x -= A, this.y -= A, this
            }

            subVectors(A, e) {
                return this.x = A.x - e.x, this.y = A.y - e.y, this
            }

            multiply(A) {
                return this.x *= A.x, this.y *= A.y, this
            }

            multiplyScalar(A) {
                return this.x *= A, this.y *= A, this
            }

            divide(A) {
                return this.x /= A.x, this.y /= A.y, this
            }

            divideScalar(A) {
                return this.multiplyScalar(1 / A)
            }

            applyMatrix3(A) {
                const e = this.x, t = this.y, n = A.elements;
                return this.x = n[0] * e + n[3] * t + n[6], this.y = n[1] * e + n[4] * t + n[7], this
            }

            min(A) {
                return this.x = Math.min(this.x, A.x), this.y = Math.min(this.y, A.y), this
            }

            max(A) {
                return this.x = Math.max(this.x, A.x), this.y = Math.max(this.y, A.y), this
            }

            clamp(A, e) {
                return this.x = Math.max(A.x, Math.min(e.x, this.x)), this.y = Math.max(A.y, Math.min(e.y, this.y)), this
            }

            clampScalar(A, e) {
                return this.x = Math.max(A, Math.min(e, this.x)), this.y = Math.max(A, Math.min(e, this.y)), this
            }

            clampLength(A, e) {
                const t = this.length();
                return this.divideScalar(t || 1).multiplyScalar(Math.max(A, Math.min(e, t)))
            }

            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }

            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }

            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }

            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
            }

            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }

            dot(A) {
                return this.x * A.x + this.y * A.y
            }

            cross(A) {
                return this.x * A.y - this.y * A.x
            }

            lengthSq() {
                return this.x * this.x + this.y * this.y
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }

            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }

            normalize() {
                return this.divideScalar(this.length() || 1)
            }

            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }

            angleTo(A) {
                const e = Math.sqrt(this.lengthSq() * A.lengthSq());
                if (0 === e) return Math.PI / 2;
                const t = this.dot(A) / e;
                return Math.acos(SA(t, -1, 1))
            }

            distanceTo(A) {
                return Math.sqrt(this.distanceToSquared(A))
            }

            distanceToSquared(A) {
                const e = this.x - A.x, t = this.y - A.y;
                return e * e + t * t
            }

            manhattanDistanceTo(A) {
                return Math.abs(this.x - A.x) + Math.abs(this.y - A.y)
            }

            setLength(A) {
                return this.normalize().multiplyScalar(A)
            }

            lerp(A, e) {
                return this.x += (A.x - this.x) * e, this.y += (A.y - this.y) * e, this
            }

            lerpVectors(A, e, t) {
                return this.x = A.x + (e.x - A.x) * t, this.y = A.y + (e.y - A.y) * t, this
            }

            equals(A) {
                return A.x === this.x && A.y === this.y
            }

            fromArray(A, e = 0) {
                return this.x = A[e], this.y = A[e + 1], this
            }

            toArray(A = [], e = 0) {
                return A[e] = this.x, A[e + 1] = this.y, A
            }

            fromBufferAttribute(A, e) {
                return this.x = A.getX(e), this.y = A.getY(e), this
            }

            rotateAround(A, e) {
                const t = Math.cos(e), n = Math.sin(e), r = this.x - A.x, i = this.y - A.y;
                return this.x = r * t - i * n + A.x, this.y = r * n + i * t + A.y, this
            }

            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }

            * [Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }

        class PA {
            constructor(A, e, t, n, r, i, a, s, o) {
                PA.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== A && this.set(A, e, t, n, r, i, a, s, o)
            }

            set(A, e, t, n, r, i, a, s, o) {
                const l = this.elements;
                return l[0] = A, l[1] = n, l[2] = a, l[3] = e, l[4] = r, l[5] = s, l[6] = t, l[7] = i, l[8] = o, this
            }

            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }

            copy(A) {
                const e = this.elements, t = A.elements;
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this
            }

            extractBasis(A, e, t) {
                return A.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), t.setFromMatrix3Column(this, 2), this
            }

            setFromMatrix4(A) {
                const e = A.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }

            multiply(A) {
                return this.multiplyMatrices(this, A)
            }

            premultiply(A) {
                return this.multiplyMatrices(A, this)
            }

            multiplyMatrices(A, e) {
                const t = A.elements, n = e.elements, r = this.elements, i = t[0], a = t[3], s = t[6], o = t[1],
                    l = t[4], c = t[7], u = t[2], h = t[5], d = t[8], p = n[0], f = n[3], g = n[6], m = n[1], B = n[4],
                    w = n[7], v = n[2], _ = n[5], C = n[8];
                return r[0] = i * p + a * m + s * v, r[3] = i * f + a * B + s * _, r[6] = i * g + a * w + s * C, r[1] = o * p + l * m + c * v, r[4] = o * f + l * B + c * _, r[7] = o * g + l * w + c * C, r[2] = u * p + h * m + d * v, r[5] = u * f + h * B + d * _, r[8] = u * g + h * w + d * C, this
            }

            multiplyScalar(A) {
                const e = this.elements;
                return e[0] *= A, e[3] *= A, e[6] *= A, e[1] *= A, e[4] *= A, e[7] *= A, e[2] *= A, e[5] *= A, e[8] *= A, this
            }

            determinant() {
                const A = this.elements, e = A[0], t = A[1], n = A[2], r = A[3], i = A[4], a = A[5], s = A[6], o = A[7],
                    l = A[8];
                return e * i * l - e * a * o - t * r * l + t * a * s + n * r * o - n * i * s
            }

            invert() {
                const A = this.elements, e = A[0], t = A[1], n = A[2], r = A[3], i = A[4], a = A[5], s = A[6], o = A[7],
                    l = A[8], c = l * i - a * o, u = a * s - l * r, h = o * r - i * s, d = e * c + t * u + n * h;
                if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const p = 1 / d;
                return A[0] = c * p, A[1] = (n * o - l * t) * p, A[2] = (a * t - n * i) * p, A[3] = u * p, A[4] = (l * e - n * s) * p, A[5] = (n * r - a * e) * p, A[6] = h * p, A[7] = (t * s - o * e) * p, A[8] = (i * e - t * r) * p, this
            }

            transpose() {
                let A;
                const e = this.elements;
                return A = e[1], e[1] = e[3], e[3] = A, A = e[2], e[2] = e[6], e[6] = A, A = e[5], e[5] = e[7], e[7] = A, this
            }

            getNormalMatrix(A) {
                return this.setFromMatrix4(A).invert().transpose()
            }

            transposeIntoArray(A) {
                const e = this.elements;
                return A[0] = e[0], A[1] = e[3], A[2] = e[6], A[3] = e[1], A[4] = e[4], A[5] = e[7], A[6] = e[2], A[7] = e[5], A[8] = e[8], this
            }

            setUvTransform(A, e, t, n, r, i, a) {
                const s = Math.cos(r), o = Math.sin(r);
                return this.set(t * s, t * o, -t * (s * i + o * a) + i + A, -n * o, n * s, -n * (-o * i + s * a) + a + e, 0, 0, 1), this
            }

            scale(A, e) {
                return this.premultiply(NA.makeScale(A, e)), this
            }

            rotate(A) {
                return this.premultiply(NA.makeRotation(-A)), this
            }

            translate(A, e) {
                return this.premultiply(NA.makeTranslation(A, e)), this
            }

            makeTranslation(A, e) {
                return A.isVector2 ? this.set(1, 0, A.x, 0, 1, A.y, 0, 0, 1) : this.set(1, 0, A, 0, 1, e, 0, 0, 1), this
            }

            makeRotation(A) {
                const e = Math.cos(A), t = Math.sin(A);
                return this.set(e, -t, 0, t, e, 0, 0, 0, 1), this
            }

            makeScale(A, e) {
                return this.set(A, 0, 0, 0, e, 0, 0, 0, 1), this
            }

            equals(A) {
                const e = this.elements, t = A.elements;
                for (let A = 0; A < 9; A++) if (e[A] !== t[A]) return !1;
                return !0
            }

            fromArray(A, e = 0) {
                for (let t = 0; t < 9; t++) this.elements[t] = A[t + e];
                return this
            }

            toArray(A = [], e = 0) {
                const t = this.elements;
                return A[e] = t[0], A[e + 1] = t[1], A[e + 2] = t[2], A[e + 3] = t[3], A[e + 4] = t[4], A[e + 5] = t[5], A[e + 6] = t[6], A[e + 7] = t[7], A[e + 8] = t[8], A
            }

            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }

        const NA = new PA;

        function OA(A) {
            for (let e = A.length - 1; e >= 0; --e) if (A[e] >= 65535) return !0;
            return !1
        }

        function GA(A) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", A)
        }

        function VA() {
            const A = GA("canvas");
            return A.style.display = "block", A
        }

        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
        const KA = {};
        const kA = (new PA).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
            zA = (new PA).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735), WA = {
                [uA]: {transfer: pA, primaries: gA, toReference: A => A, fromReference: A => A},
                [cA]: {
                    transfer: fA,
                    primaries: gA,
                    toReference: A => A.convertSRGBToLinear(),
                    fromReference: A => A.convertLinearToSRGB()
                },
                [dA]: {
                    transfer: pA,
                    primaries: mA,
                    toReference: A => A.applyMatrix3(zA),
                    fromReference: A => A.applyMatrix3(kA)
                },
                [hA]: {
                    transfer: fA,
                    primaries: mA,
                    toReference: A => A.convertSRGBToLinear().applyMatrix3(zA),
                    fromReference: A => A.applyMatrix3(kA).convertLinearToSRGB()
                }
            }, XA = new Set([uA, dA]), YA = {
                enabled: !0, _workingColorSpace: uA, get workingColorSpace() {
                    return this._workingColorSpace
                }, set workingColorSpace(A) {
                    if (!XA.has(A)) throw new Error(`Unsupported working color space, "${A}".`);
                    this._workingColorSpace = A
                }, convert: function (A, e, t) {
                    if (!1 === this.enabled || e === t || !e || !t) return A;
                    const n = WA[e].toReference;
                    return (0, WA[t].fromReference)(n(A))
                }, fromWorkingColorSpace: function (A, e) {
                    return this.convert(A, this._workingColorSpace, e)
                }, toWorkingColorSpace: function (A, e) {
                    return this.convert(A, e, this._workingColorSpace)
                }, getPrimaries: function (A) {
                    return WA[A].primaries
                }, getTransfer: function (A) {
                    return A === lA ? pA : WA[A].transfer
                }
            };

        function JA(A) {
            return A < .04045 ? .0773993808 * A : Math.pow(.9478672986 * A + .0521327014, 2.4)
        }

        function jA(A) {
            return A < .0031308 ? 12.92 * A : 1.055 * Math.pow(A, .41666) - .055
        }

        let ZA;

        class qA {
            static getDataURL(A) {
                if (/^data:/i.test(A.src)) return A.src;
                if ("undefined" == typeof HTMLCanvasElement) return A.src;
                let e;
                if (A instanceof HTMLCanvasElement) e = A; else {
                    void 0 === ZA && (ZA = GA("canvas")), ZA.width = A.width, ZA.height = A.height;
                    const t = ZA.getContext("2d");
                    A instanceof ImageData ? t.putImageData(A, 0, 0) : t.drawImage(A, 0, 0, A.width, A.height), e = ZA
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", A), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }

            static sRGBToLinear(A) {
                if ("undefined" != typeof HTMLImageElement && A instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && A instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && A instanceof ImageBitmap) {
                    const e = GA("canvas");
                    e.width = A.width, e.height = A.height;
                    const t = e.getContext("2d");
                    t.drawImage(A, 0, 0, A.width, A.height);
                    const n = t.getImageData(0, 0, A.width, A.height), r = n.data;
                    for (let A = 0; A < r.length; A++) r[A] = 255 * JA(r[A] / 255);
                    return t.putImageData(n, 0, 0), e
                }
                if (A.data) {
                    const e = A.data.slice(0);
                    for (let A = 0; A < e.length; A++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[A] = Math.floor(255 * JA(e[A] / 255)) : e[A] = JA(e[A]);
                    return {data: e, width: A.width, height: A.height}
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), A
            }
        }

        let $A = 0;

        class Ae {
            constructor(A = null) {
                this.isSource = !0, Object.defineProperty(this, "id", {value: $A++}), this.uuid = FA(), this.data = A, this.dataReady = !0, this.version = 0
            }

            set needsUpdate(A) {
                !0 === A && this.version++
            }

            toJSON(A) {
                const e = void 0 === A || "string" == typeof A;
                if (!e && void 0 !== A.images[this.uuid]) return A.images[this.uuid];
                const t = {uuid: this.uuid, url: ""}, n = this.data;
                if (null !== n) {
                    let A;
                    if (Array.isArray(n)) {
                        A = [];
                        for (let e = 0, t = n.length; e < t; e++) n[e].isDataTexture ? A.push(ee(n[e].image)) : A.push(ee(n[e]))
                    } else A = ee(n);
                    t.url = A
                }
                return e || (A.images[this.uuid] = t), t
            }
        }

        function ee(A) {
            return "undefined" != typeof HTMLImageElement && A instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && A instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && A instanceof ImageBitmap ? qA.getDataURL(A) : A.data ? {
                data: Array.from(A.data),
                width: A.width,
                height: A.height,
                type: A.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }

        let te = 0;

        class ne extends EA {
            constructor(A = ne.DEFAULT_IMAGE, e = ne.DEFAULT_MAPPING, t = 1001, n = 1001, r = 1006, i = 1008, a = 1023, s = 1009, o = ne.DEFAULT_ANISOTROPY, l = "") {
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {value: te++}), this.uuid = FA(), this.name = "", this.source = new Ae(A), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = t, this.wrapT = n, this.magFilter = r, this.minFilter = i, this.anisotropy = o, this.format = a, this.internalFormat = null, this.type = s, this.offset = new DA(0, 0), this.repeat = new DA(1, 1), this.center = new DA(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new PA, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = l, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }

            get image() {
                return this.source.data
            }

            set image(A = null) {
                this.source.data = A
            }

            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(A) {
                return this.name = A.name, this.source = A.source, this.mipmaps = A.mipmaps.slice(0), this.mapping = A.mapping, this.channel = A.channel, this.wrapS = A.wrapS, this.wrapT = A.wrapT, this.magFilter = A.magFilter, this.minFilter = A.minFilter, this.anisotropy = A.anisotropy, this.format = A.format, this.internalFormat = A.internalFormat, this.type = A.type, this.offset.copy(A.offset), this.repeat.copy(A.repeat), this.center.copy(A.center), this.rotation = A.rotation, this.matrixAutoUpdate = A.matrixAutoUpdate, this.matrix.copy(A.matrix), this.generateMipmaps = A.generateMipmaps, this.premultiplyAlpha = A.premultiplyAlpha, this.flipY = A.flipY, this.unpackAlignment = A.unpackAlignment, this.colorSpace = A.colorSpace, this.userData = JSON.parse(JSON.stringify(A.userData)), this.needsUpdate = !0, this
            }

            toJSON(A) {
                const e = void 0 === A || "string" == typeof A;
                if (!e && void 0 !== A.textures[this.uuid]) return A.textures[this.uuid];
                const t = {
                    metadata: {version: 4.6, type: "Texture", generator: "Texture.toJSON"},
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(A).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (t.userData = this.userData), e || (A.textures[this.uuid] = t), t
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }

            transformUv(A) {
                if (300 !== this.mapping) return A;
                if (A.applyMatrix3(this.matrix), A.x < 0 || A.x > 1) switch (this.wrapS) {
                    case P:
                        A.x = A.x - Math.floor(A.x);
                        break;
                    case N:
                        A.x = A.x < 0 ? 0 : 1;
                        break;
                    case O:
                        1 === Math.abs(Math.floor(A.x) % 2) ? A.x = Math.ceil(A.x) - A.x : A.x = A.x - Math.floor(A.x)
                }
                if (A.y < 0 || A.y > 1) switch (this.wrapT) {
                    case P:
                        A.y = A.y - Math.floor(A.y);
                        break;
                    case N:
                        A.y = A.y < 0 ? 0 : 1;
                        break;
                    case O:
                        1 === Math.abs(Math.floor(A.y) % 2) ? A.y = Math.ceil(A.y) - A.y : A.y = A.y - Math.floor(A.y)
                }
                return this.flipY && (A.y = 1 - A.y), A
            }

            set needsUpdate(A) {
                !0 === A && (this.version++, this.source.needsUpdate = !0)
            }
        }

        ne.DEFAULT_IMAGE = null, ne.DEFAULT_MAPPING = 300, ne.DEFAULT_ANISOTROPY = 1;

        class re {
            constructor(A = 0, e = 0, t = 0, n = 1) {
                re.prototype.isVector4 = !0, this.x = A, this.y = e, this.z = t, this.w = n
            }

            get width() {
                return this.z
            }

            set width(A) {
                this.z = A
            }

            get height() {
                return this.w
            }

            set height(A) {
                this.w = A
            }

            set(A, e, t, n) {
                return this.x = A, this.y = e, this.z = t, this.w = n, this
            }

            setScalar(A) {
                return this.x = A, this.y = A, this.z = A, this.w = A, this
            }

            setX(A) {
                return this.x = A, this
            }

            setY(A) {
                return this.y = A, this
            }

            setZ(A) {
                return this.z = A, this
            }

            setW(A) {
                return this.w = A, this
            }

            setComponent(A, e) {
                switch (A) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + A)
                }
                return this
            }

            getComponent(A) {
                switch (A) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + A)
                }
            }

            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }

            copy(A) {
                return this.x = A.x, this.y = A.y, this.z = A.z, this.w = void 0 !== A.w ? A.w : 1, this
            }

            add(A) {
                return this.x += A.x, this.y += A.y, this.z += A.z, this.w += A.w, this
            }

            addScalar(A) {
                return this.x += A, this.y += A, this.z += A, this.w += A, this
            }

            addVectors(A, e) {
                return this.x = A.x + e.x, this.y = A.y + e.y, this.z = A.z + e.z, this.w = A.w + e.w, this
            }

            addScaledVector(A, e) {
                return this.x += A.x * e, this.y += A.y * e, this.z += A.z * e, this.w += A.w * e, this
            }

            sub(A) {
                return this.x -= A.x, this.y -= A.y, this.z -= A.z, this.w -= A.w, this
            }

            subScalar(A) {
                return this.x -= A, this.y -= A, this.z -= A, this.w -= A, this
            }

            subVectors(A, e) {
                return this.x = A.x - e.x, this.y = A.y - e.y, this.z = A.z - e.z, this.w = A.w - e.w, this
            }

            multiply(A) {
                return this.x *= A.x, this.y *= A.y, this.z *= A.z, this.w *= A.w, this
            }

            multiplyScalar(A) {
                return this.x *= A, this.y *= A, this.z *= A, this.w *= A, this
            }

            applyMatrix4(A) {
                const e = this.x, t = this.y, n = this.z, r = this.w, i = A.elements;
                return this.x = i[0] * e + i[4] * t + i[8] * n + i[12] * r, this.y = i[1] * e + i[5] * t + i[9] * n + i[13] * r, this.z = i[2] * e + i[6] * t + i[10] * n + i[14] * r, this.w = i[3] * e + i[7] * t + i[11] * n + i[15] * r, this
            }

            divideScalar(A) {
                return this.multiplyScalar(1 / A)
            }

            setAxisAngleFromQuaternion(A) {
                this.w = 2 * Math.acos(A.w);
                const e = Math.sqrt(1 - A.w * A.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = A.x / e, this.y = A.y / e, this.z = A.z / e), this
            }

            setAxisAngleFromRotationMatrix(A) {
                let e, t, n, r;
                const i = .01, a = .1, s = A.elements, o = s[0], l = s[4], c = s[8], u = s[1], h = s[5], d = s[9],
                    p = s[2], f = s[6], g = s[10];
                if (Math.abs(l - u) < i && Math.abs(c - p) < i && Math.abs(d - f) < i) {
                    if (Math.abs(l + u) < a && Math.abs(c + p) < a && Math.abs(d + f) < a && Math.abs(o + h + g - 3) < a) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const A = (o + 1) / 2, s = (h + 1) / 2, m = (g + 1) / 2, B = (l + u) / 4, w = (c + p) / 4,
                        v = (d + f) / 4;
                    return A > s && A > m ? A < i ? (t = 0, n = .707106781, r = .707106781) : (t = Math.sqrt(A), n = B / t, r = w / t) : s > m ? s < i ? (t = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(s), t = B / n, r = v / n) : m < i ? (t = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(m), t = w / r, n = v / r), this.set(t, n, r, e), this
                }
                let m = Math.sqrt((f - d) * (f - d) + (c - p) * (c - p) + (u - l) * (u - l));
                return Math.abs(m) < .001 && (m = 1), this.x = (f - d) / m, this.y = (c - p) / m, this.z = (u - l) / m, this.w = Math.acos((o + h + g - 1) / 2), this
            }

            min(A) {
                return this.x = Math.min(this.x, A.x), this.y = Math.min(this.y, A.y), this.z = Math.min(this.z, A.z), this.w = Math.min(this.w, A.w), this
            }

            max(A) {
                return this.x = Math.max(this.x, A.x), this.y = Math.max(this.y, A.y), this.z = Math.max(this.z, A.z), this.w = Math.max(this.w, A.w), this
            }

            clamp(A, e) {
                return this.x = Math.max(A.x, Math.min(e.x, this.x)), this.y = Math.max(A.y, Math.min(e.y, this.y)), this.z = Math.max(A.z, Math.min(e.z, this.z)), this.w = Math.max(A.w, Math.min(e.w, this.w)), this
            }

            clampScalar(A, e) {
                return this.x = Math.max(A, Math.min(e, this.x)), this.y = Math.max(A, Math.min(e, this.y)), this.z = Math.max(A, Math.min(e, this.z)), this.w = Math.max(A, Math.min(e, this.w)), this
            }

            clampLength(A, e) {
                const t = this.length();
                return this.divideScalar(t || 1).multiplyScalar(Math.max(A, Math.min(e, t)))
            }

            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }

            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }

            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }

            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
            }

            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }

            dot(A) {
                return this.x * A.x + this.y * A.y + this.z * A.z + this.w * A.w
            }

            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }

            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }

            normalize() {
                return this.divideScalar(this.length() || 1)
            }

            setLength(A) {
                return this.normalize().multiplyScalar(A)
            }

            lerp(A, e) {
                return this.x += (A.x - this.x) * e, this.y += (A.y - this.y) * e, this.z += (A.z - this.z) * e, this.w += (A.w - this.w) * e, this
            }

            lerpVectors(A, e, t) {
                return this.x = A.x + (e.x - A.x) * t, this.y = A.y + (e.y - A.y) * t, this.z = A.z + (e.z - A.z) * t, this.w = A.w + (e.w - A.w) * t, this
            }

            equals(A) {
                return A.x === this.x && A.y === this.y && A.z === this.z && A.w === this.w
            }

            fromArray(A, e = 0) {
                return this.x = A[e], this.y = A[e + 1], this.z = A[e + 2], this.w = A[e + 3], this
            }

            toArray(A = [], e = 0) {
                return A[e] = this.x, A[e + 1] = this.y, A[e + 2] = this.z, A[e + 3] = this.w, A
            }

            fromBufferAttribute(A, e) {
                return this.x = A.getX(e), this.y = A.getY(e), this.z = A.getZ(e), this.w = A.getW(e), this
            }

            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }

            * [Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }

        class ie extends EA {
            constructor(A = 1, e = 1, t = {}) {
                super(), this.isRenderTarget = !0, this.width = A, this.height = e, this.depth = 1, this.scissor = new re(0, 0, A, e), this.scissorTest = !1, this.viewport = new re(0, 0, A, e);
                const n = {width: A, height: e, depth: 1};
                t = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: K,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0,
                    count: 1
                }, t);
                const r = new ne(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace);
                r.flipY = !1, r.generateMipmaps = t.generateMipmaps, r.internalFormat = t.internalFormat, this.textures = [];
                const i = t.count;
                for (let A = 0; A < i; A++) this.textures[A] = r.clone(), this.textures[A].isRenderTargetTexture = !0;
                this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.samples = t.samples
            }

            get texture() {
                return this.textures[0]
            }

            set texture(A) {
                this.textures[0] = A
            }

            setSize(A, e, t = 1) {
                if (this.width !== A || this.height !== e || this.depth !== t) {
                    this.width = A, this.height = e, this.depth = t;
                    for (let n = 0, r = this.textures.length; n < r; n++) this.textures[n].image.width = A, this.textures[n].image.height = e, this.textures[n].image.depth = t;
                    this.dispose()
                }
                this.viewport.set(0, 0, A, e), this.scissor.set(0, 0, A, e)
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(A) {
                this.width = A.width, this.height = A.height, this.depth = A.depth, this.scissor.copy(A.scissor), this.scissorTest = A.scissorTest, this.viewport.copy(A.viewport), this.textures.length = 0;
                for (let e = 0, t = A.textures.length; e < t; e++) this.textures[e] = A.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0;
                const e = Object.assign({}, A.texture.image);
                return this.texture.source = new Ae(e), this.depthBuffer = A.depthBuffer, this.stencilBuffer = A.stencilBuffer, null !== A.depthTexture && (this.depthTexture = A.depthTexture.clone()), this.samples = A.samples, this
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }
        }

        class ae extends ie {
            constructor(A = 1, e = 1, t = {}) {
                super(A, e, t), this.isWebGLRenderTarget = !0
            }
        }

        class se extends ne {
            constructor(A = null, e = 1, t = 1, n = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: A,
                    width: e,
                    height: t,
                    depth: n
                }, this.magFilter = G, this.minFilter = G, this.wrapR = N, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }

        class oe extends ne {
            constructor(A = null, e = 1, t = 1, n = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: A,
                    width: e,
                    height: t,
                    depth: n
                }, this.magFilter = G, this.minFilter = G, this.wrapR = N, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }

        class le {
            constructor(A = 0, e = 0, t = 0, n = 1) {
                this.isQuaternion = !0, this._x = A, this._y = e, this._z = t, this._w = n
            }

            static slerpFlat(A, e, t, n, r, i, a) {
                let s = t[n + 0], o = t[n + 1], l = t[n + 2], c = t[n + 3];
                const u = r[i + 0], h = r[i + 1], d = r[i + 2], p = r[i + 3];
                if (0 === a) return A[e + 0] = s, A[e + 1] = o, A[e + 2] = l, void (A[e + 3] = c);
                if (1 === a) return A[e + 0] = u, A[e + 1] = h, A[e + 2] = d, void (A[e + 3] = p);
                if (c !== p || s !== u || o !== h || l !== d) {
                    let A = 1 - a;
                    const e = s * u + o * h + l * d + c * p, t = e >= 0 ? 1 : -1, n = 1 - e * e;
                    if (n > Number.EPSILON) {
                        const r = Math.sqrt(n), i = Math.atan2(r, e * t);
                        A = Math.sin(A * i) / r, a = Math.sin(a * i) / r
                    }
                    const r = a * t;
                    if (s = s * A + u * r, o = o * A + h * r, l = l * A + d * r, c = c * A + p * r, A === 1 - a) {
                        const A = 1 / Math.sqrt(s * s + o * o + l * l + c * c);
                        s *= A, o *= A, l *= A, c *= A
                    }
                }
                A[e] = s, A[e + 1] = o, A[e + 2] = l, A[e + 3] = c
            }

            static multiplyQuaternionsFlat(A, e, t, n, r, i) {
                const a = t[n], s = t[n + 1], o = t[n + 2], l = t[n + 3], c = r[i], u = r[i + 1], h = r[i + 2],
                    d = r[i + 3];
                return A[e] = a * d + l * c + s * h - o * u, A[e + 1] = s * d + l * u + o * c - a * h, A[e + 2] = o * d + l * h + a * u - s * c, A[e + 3] = l * d - a * c - s * u - o * h, A
            }

            get x() {
                return this._x
            }

            set x(A) {
                this._x = A, this._onChangeCallback()
            }

            get y() {
                return this._y
            }

            set y(A) {
                this._y = A, this._onChangeCallback()
            }

            get z() {
                return this._z
            }

            set z(A) {
                this._z = A, this._onChangeCallback()
            }

            get w() {
                return this._w
            }

            set w(A) {
                this._w = A, this._onChangeCallback()
            }

            set(A, e, t, n) {
                return this._x = A, this._y = e, this._z = t, this._w = n, this._onChangeCallback(), this
            }

            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }

            copy(A) {
                return this._x = A.x, this._y = A.y, this._z = A.z, this._w = A.w, this._onChangeCallback(), this
            }

            setFromEuler(A, e = !0) {
                const t = A._x, n = A._y, r = A._z, i = A._order, a = Math.cos, s = Math.sin, o = a(t / 2),
                    l = a(n / 2), c = a(r / 2), u = s(t / 2), h = s(n / 2), d = s(r / 2);
                switch (i) {
                    case"XYZ":
                        this._x = u * l * c + o * h * d, this._y = o * h * c - u * l * d, this._z = o * l * d + u * h * c, this._w = o * l * c - u * h * d;
                        break;
                    case"YXZ":
                        this._x = u * l * c + o * h * d, this._y = o * h * c - u * l * d, this._z = o * l * d - u * h * c, this._w = o * l * c + u * h * d;
                        break;
                    case"ZXY":
                        this._x = u * l * c - o * h * d, this._y = o * h * c + u * l * d, this._z = o * l * d + u * h * c, this._w = o * l * c - u * h * d;
                        break;
                    case"ZYX":
                        this._x = u * l * c - o * h * d, this._y = o * h * c + u * l * d, this._z = o * l * d - u * h * c, this._w = o * l * c + u * h * d;
                        break;
                    case"YZX":
                        this._x = u * l * c + o * h * d, this._y = o * h * c + u * l * d, this._z = o * l * d - u * h * c, this._w = o * l * c - u * h * d;
                        break;
                    case"XZY":
                        this._x = u * l * c - o * h * d, this._y = o * h * c - u * l * d, this._z = o * l * d + u * h * c, this._w = o * l * c + u * h * d;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + i)
                }
                return !0 === e && this._onChangeCallback(), this
            }

            setFromAxisAngle(A, e) {
                const t = e / 2, n = Math.sin(t);
                return this._x = A.x * n, this._y = A.y * n, this._z = A.z * n, this._w = Math.cos(t), this._onChangeCallback(), this
            }

            setFromRotationMatrix(A) {
                const e = A.elements, t = e[0], n = e[4], r = e[8], i = e[1], a = e[5], s = e[9], o = e[2], l = e[6],
                    c = e[10], u = t + a + c;
                if (u > 0) {
                    const A = .5 / Math.sqrt(u + 1);
                    this._w = .25 / A, this._x = (l - s) * A, this._y = (r - o) * A, this._z = (i - n) * A
                } else if (t > a && t > c) {
                    const A = 2 * Math.sqrt(1 + t - a - c);
                    this._w = (l - s) / A, this._x = .25 * A, this._y = (n + i) / A, this._z = (r + o) / A
                } else if (a > c) {
                    const A = 2 * Math.sqrt(1 + a - t - c);
                    this._w = (r - o) / A, this._x = (n + i) / A, this._y = .25 * A, this._z = (s + l) / A
                } else {
                    const A = 2 * Math.sqrt(1 + c - t - a);
                    this._w = (i - n) / A, this._x = (r + o) / A, this._y = (s + l) / A, this._z = .25 * A
                }
                return this._onChangeCallback(), this
            }

            setFromUnitVectors(A, e) {
                let t = A.dot(e) + 1;
                return t < Number.EPSILON ? (t = 0, Math.abs(A.x) > Math.abs(A.z) ? (this._x = -A.y, this._y = A.x, this._z = 0, this._w = t) : (this._x = 0, this._y = -A.z, this._z = A.y, this._w = t)) : (this._x = A.y * e.z - A.z * e.y, this._y = A.z * e.x - A.x * e.z, this._z = A.x * e.y - A.y * e.x, this._w = t), this.normalize()
            }

            angleTo(A) {
                return 2 * Math.acos(Math.abs(SA(this.dot(A), -1, 1)))
            }

            rotateTowards(A, e) {
                const t = this.angleTo(A);
                if (0 === t) return this;
                const n = Math.min(1, e / t);
                return this.slerp(A, n), this
            }

            identity() {
                return this.set(0, 0, 0, 1)
            }

            invert() {
                return this.conjugate()
            }

            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }

            dot(A) {
                return this._x * A._x + this._y * A._y + this._z * A._z + this._w * A._w
            }

            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }

            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }

            normalize() {
                let A = this.length();
                return 0 === A ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (A = 1 / A, this._x = this._x * A, this._y = this._y * A, this._z = this._z * A, this._w = this._w * A), this._onChangeCallback(), this
            }

            multiply(A) {
                return this.multiplyQuaternions(this, A)
            }

            premultiply(A) {
                return this.multiplyQuaternions(A, this)
            }

            multiplyQuaternions(A, e) {
                const t = A._x, n = A._y, r = A._z, i = A._w, a = e._x, s = e._y, o = e._z, l = e._w;
                return this._x = t * l + i * a + n * o - r * s, this._y = n * l + i * s + r * a - t * o, this._z = r * l + i * o + t * s - n * a, this._w = i * l - t * a - n * s - r * o, this._onChangeCallback(), this
            }

            slerp(A, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(A);
                const t = this._x, n = this._y, r = this._z, i = this._w;
                let a = i * A._w + t * A._x + n * A._y + r * A._z;
                if (a < 0 ? (this._w = -A._w, this._x = -A._x, this._y = -A._y, this._z = -A._z, a = -a) : this.copy(A), a >= 1) return this._w = i, this._x = t, this._y = n, this._z = r, this;
                const s = 1 - a * a;
                if (s <= Number.EPSILON) {
                    const A = 1 - e;
                    return this._w = A * i + e * this._w, this._x = A * t + e * this._x, this._y = A * n + e * this._y, this._z = A * r + e * this._z, this.normalize(), this
                }
                const o = Math.sqrt(s), l = Math.atan2(o, a), c = Math.sin((1 - e) * l) / o, u = Math.sin(e * l) / o;
                return this._w = i * c + this._w * u, this._x = t * c + this._x * u, this._y = n * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this
            }

            slerpQuaternions(A, e, t) {
                return this.copy(A).slerp(e, t)
            }

            random() {
                const A = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), t = Math.random(),
                    n = Math.sqrt(1 - t), r = Math.sqrt(t);
                return this.set(n * Math.sin(A), n * Math.cos(A), r * Math.sin(e), r * Math.cos(e))
            }

            equals(A) {
                return A._x === this._x && A._y === this._y && A._z === this._z && A._w === this._w
            }

            fromArray(A, e = 0) {
                return this._x = A[e], this._y = A[e + 1], this._z = A[e + 2], this._w = A[e + 3], this._onChangeCallback(), this
            }

            toArray(A = [], e = 0) {
                return A[e] = this._x, A[e + 1] = this._y, A[e + 2] = this._z, A[e + 3] = this._w, A
            }

            fromBufferAttribute(A, e) {
                return this._x = A.getX(e), this._y = A.getY(e), this._z = A.getZ(e), this._w = A.getW(e), this._onChangeCallback(), this
            }

            toJSON() {
                return this.toArray()
            }

            _onChange(A) {
                return this._onChangeCallback = A, this
            }

            _onChangeCallback() {
            }

            * [Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }

        class ce {
            constructor(A = 0, e = 0, t = 0) {
                ce.prototype.isVector3 = !0, this.x = A, this.y = e, this.z = t
            }

            set(A, e, t) {
                return void 0 === t && (t = this.z), this.x = A, this.y = e, this.z = t, this
            }

            setScalar(A) {
                return this.x = A, this.y = A, this.z = A, this
            }

            setX(A) {
                return this.x = A, this
            }

            setY(A) {
                return this.y = A, this
            }

            setZ(A) {
                return this.z = A, this
            }

            setComponent(A, e) {
                switch (A) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + A)
                }
                return this
            }

            getComponent(A) {
                switch (A) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + A)
                }
            }

            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }

            copy(A) {
                return this.x = A.x, this.y = A.y, this.z = A.z, this
            }

            add(A) {
                return this.x += A.x, this.y += A.y, this.z += A.z, this
            }

            addScalar(A) {
                return this.x += A, this.y += A, this.z += A, this
            }

            addVectors(A, e) {
                return this.x = A.x + e.x, this.y = A.y + e.y, this.z = A.z + e.z, this
            }

            addScaledVector(A, e) {
                return this.x += A.x * e, this.y += A.y * e, this.z += A.z * e, this
            }

            sub(A) {
                return this.x -= A.x, this.y -= A.y, this.z -= A.z, this
            }

            subScalar(A) {
                return this.x -= A, this.y -= A, this.z -= A, this
            }

            subVectors(A, e) {
                return this.x = A.x - e.x, this.y = A.y - e.y, this.z = A.z - e.z, this
            }

            multiply(A) {
                return this.x *= A.x, this.y *= A.y, this.z *= A.z, this
            }

            multiplyScalar(A) {
                return this.x *= A, this.y *= A, this.z *= A, this
            }

            multiplyVectors(A, e) {
                return this.x = A.x * e.x, this.y = A.y * e.y, this.z = A.z * e.z, this
            }

            applyEuler(A) {
                return this.applyQuaternion(he.setFromEuler(A))
            }

            applyAxisAngle(A, e) {
                return this.applyQuaternion(he.setFromAxisAngle(A, e))
            }

            applyMatrix3(A) {
                const e = this.x, t = this.y, n = this.z, r = A.elements;
                return this.x = r[0] * e + r[3] * t + r[6] * n, this.y = r[1] * e + r[4] * t + r[7] * n, this.z = r[2] * e + r[5] * t + r[8] * n, this
            }

            applyNormalMatrix(A) {
                return this.applyMatrix3(A).normalize()
            }

            applyMatrix4(A) {
                const e = this.x, t = this.y, n = this.z, r = A.elements,
                    i = 1 / (r[3] * e + r[7] * t + r[11] * n + r[15]);
                return this.x = (r[0] * e + r[4] * t + r[8] * n + r[12]) * i, this.y = (r[1] * e + r[5] * t + r[9] * n + r[13]) * i, this.z = (r[2] * e + r[6] * t + r[10] * n + r[14]) * i, this
            }

            applyQuaternion(A) {
                const e = this.x, t = this.y, n = this.z, r = A.x, i = A.y, a = A.z, s = A.w, o = 2 * (i * n - a * t),
                    l = 2 * (a * e - r * n), c = 2 * (r * t - i * e);
                return this.x = e + s * o + i * c - a * l, this.y = t + s * l + a * o - r * c, this.z = n + s * c + r * l - i * o, this
            }

            project(A) {
                return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)
            }

            unproject(A) {
                return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)
            }

            transformDirection(A) {
                const e = this.x, t = this.y, n = this.z, r = A.elements;
                return this.x = r[0] * e + r[4] * t + r[8] * n, this.y = r[1] * e + r[5] * t + r[9] * n, this.z = r[2] * e + r[6] * t + r[10] * n, this.normalize()
            }

            divide(A) {
                return this.x /= A.x, this.y /= A.y, this.z /= A.z, this
            }

            divideScalar(A) {
                return this.multiplyScalar(1 / A)
            }

            min(A) {
                return this.x = Math.min(this.x, A.x), this.y = Math.min(this.y, A.y), this.z = Math.min(this.z, A.z), this
            }

            max(A) {
                return this.x = Math.max(this.x, A.x), this.y = Math.max(this.y, A.y), this.z = Math.max(this.z, A.z), this
            }

            clamp(A, e) {
                return this.x = Math.max(A.x, Math.min(e.x, this.x)), this.y = Math.max(A.y, Math.min(e.y, this.y)), this.z = Math.max(A.z, Math.min(e.z, this.z)), this
            }

            clampScalar(A, e) {
                return this.x = Math.max(A, Math.min(e, this.x)), this.y = Math.max(A, Math.min(e, this.y)), this.z = Math.max(A, Math.min(e, this.z)), this
            }

            clampLength(A, e) {
                const t = this.length();
                return this.divideScalar(t || 1).multiplyScalar(Math.max(A, Math.min(e, t)))
            }

            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }

            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }

            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }

            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
            }

            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }

            dot(A) {
                return this.x * A.x + this.y * A.y + this.z * A.z
            }

            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }

            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }

            normalize() {
                return this.divideScalar(this.length() || 1)
            }

            setLength(A) {
                return this.normalize().multiplyScalar(A)
            }

            lerp(A, e) {
                return this.x += (A.x - this.x) * e, this.y += (A.y - this.y) * e, this.z += (A.z - this.z) * e, this
            }

            lerpVectors(A, e, t) {
                return this.x = A.x + (e.x - A.x) * t, this.y = A.y + (e.y - A.y) * t, this.z = A.z + (e.z - A.z) * t, this
            }

            cross(A) {
                return this.crossVectors(this, A)
            }

            crossVectors(A, e) {
                const t = A.x, n = A.y, r = A.z, i = e.x, a = e.y, s = e.z;
                return this.x = n * s - r * a, this.y = r * i - t * s, this.z = t * a - n * i, this
            }

            projectOnVector(A) {
                const e = A.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const t = A.dot(this) / e;
                return this.copy(A).multiplyScalar(t)
            }

            projectOnPlane(A) {
                return ue.copy(this).projectOnVector(A), this.sub(ue)
            }

            reflect(A) {
                return this.sub(ue.copy(A).multiplyScalar(2 * this.dot(A)))
            }

            angleTo(A) {
                const e = Math.sqrt(this.lengthSq() * A.lengthSq());
                if (0 === e) return Math.PI / 2;
                const t = this.dot(A) / e;
                return Math.acos(SA(t, -1, 1))
            }

            distanceTo(A) {
                return Math.sqrt(this.distanceToSquared(A))
            }

            distanceToSquared(A) {
                const e = this.x - A.x, t = this.y - A.y, n = this.z - A.z;
                return e * e + t * t + n * n
            }

            manhattanDistanceTo(A) {
                return Math.abs(this.x - A.x) + Math.abs(this.y - A.y) + Math.abs(this.z - A.z)
            }

            setFromSpherical(A) {
                return this.setFromSphericalCoords(A.radius, A.phi, A.theta)
            }

            setFromSphericalCoords(A, e, t) {
                const n = Math.sin(e) * A;
                return this.x = n * Math.sin(t), this.y = Math.cos(e) * A, this.z = n * Math.cos(t), this
            }

            setFromCylindrical(A) {
                return this.setFromCylindricalCoords(A.radius, A.theta, A.y)
            }

            setFromCylindricalCoords(A, e, t) {
                return this.x = A * Math.sin(e), this.y = t, this.z = A * Math.cos(e), this
            }

            setFromMatrixPosition(A) {
                const e = A.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }

            setFromMatrixScale(A) {
                const e = this.setFromMatrixColumn(A, 0).length(), t = this.setFromMatrixColumn(A, 1).length(),
                    n = this.setFromMatrixColumn(A, 2).length();
                return this.x = e, this.y = t, this.z = n, this
            }

            setFromMatrixColumn(A, e) {
                return this.fromArray(A.elements, 4 * e)
            }

            setFromMatrix3Column(A, e) {
                return this.fromArray(A.elements, 3 * e)
            }

            setFromEuler(A) {
                return this.x = A._x, this.y = A._y, this.z = A._z, this
            }

            setFromColor(A) {
                return this.x = A.r, this.y = A.g, this.z = A.b, this
            }

            equals(A) {
                return A.x === this.x && A.y === this.y && A.z === this.z
            }

            fromArray(A, e = 0) {
                return this.x = A[e], this.y = A[e + 1], this.z = A[e + 2], this
            }

            toArray(A = [], e = 0) {
                return A[e] = this.x, A[e + 1] = this.y, A[e + 2] = this.z, A
            }

            fromBufferAttribute(A, e) {
                return this.x = A.getX(e), this.y = A.getY(e), this.z = A.getZ(e), this
            }

            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }

            randomDirection() {
                const A = Math.random() * Math.PI * 2, e = 2 * Math.random() - 1, t = Math.sqrt(1 - e * e);
                return this.x = t * Math.cos(A), this.y = e, this.z = t * Math.sin(A), this
            }

            * [Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }

        const ue = new ce, he = new le;

        class de {
            constructor(A = new ce(1 / 0, 1 / 0, 1 / 0), e = new ce(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = A, this.max = e
            }

            set(A, e) {
                return this.min.copy(A), this.max.copy(e), this
            }

            setFromArray(A) {
                this.makeEmpty();
                for (let e = 0, t = A.length; e < t; e += 3) this.expandByPoint(fe.fromArray(A, e));
                return this
            }

            setFromBufferAttribute(A) {
                this.makeEmpty();
                for (let e = 0, t = A.count; e < t; e++) this.expandByPoint(fe.fromBufferAttribute(A, e));
                return this
            }

            setFromPoints(A) {
                this.makeEmpty();
                for (let e = 0, t = A.length; e < t; e++) this.expandByPoint(A[e]);
                return this
            }

            setFromCenterAndSize(A, e) {
                const t = fe.copy(e).multiplyScalar(.5);
                return this.min.copy(A).sub(t), this.max.copy(A).add(t), this
            }

            setFromObject(A, e = !1) {
                return this.makeEmpty(), this.expandByObject(A, e)
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(A) {
                return this.min.copy(A.min), this.max.copy(A.max), this
            }

            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }

            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }

            getCenter(A) {
                return this.isEmpty() ? A.set(0, 0, 0) : A.addVectors(this.min, this.max).multiplyScalar(.5)
            }

            getSize(A) {
                return this.isEmpty() ? A.set(0, 0, 0) : A.subVectors(this.max, this.min)
            }

            expandByPoint(A) {
                return this.min.min(A), this.max.max(A), this
            }

            expandByVector(A) {
                return this.min.sub(A), this.max.add(A), this
            }

            expandByScalar(A) {
                return this.min.addScalar(-A), this.max.addScalar(A), this
            }

            expandByObject(A, e = !1) {
                A.updateWorldMatrix(!1, !1);
                const t = A.geometry;
                if (void 0 !== t) {
                    const n = t.getAttribute("position");
                    if (!0 === e && void 0 !== n && !0 !== A.isInstancedMesh) for (let e = 0, t = n.count; e < t; e++) !0 === A.isMesh ? A.getVertexPosition(e, fe) : fe.fromBufferAttribute(n, e), fe.applyMatrix4(A.matrixWorld), this.expandByPoint(fe); else void 0 !== A.boundingBox ? (null === A.boundingBox && A.computeBoundingBox(), ge.copy(A.boundingBox)) : (null === t.boundingBox && t.computeBoundingBox(), ge.copy(t.boundingBox)), ge.applyMatrix4(A.matrixWorld), this.union(ge)
                }
                const n = A.children;
                for (let A = 0, t = n.length; A < t; A++) this.expandByObject(n[A], e);
                return this
            }

            containsPoint(A) {
                return !(A.x < this.min.x || A.x > this.max.x || A.y < this.min.y || A.y > this.max.y || A.z < this.min.z || A.z > this.max.z)
            }

            containsBox(A) {
                return this.min.x <= A.min.x && A.max.x <= this.max.x && this.min.y <= A.min.y && A.max.y <= this.max.y && this.min.z <= A.min.z && A.max.z <= this.max.z
            }

            getParameter(A, e) {
                return e.set((A.x - this.min.x) / (this.max.x - this.min.x), (A.y - this.min.y) / (this.max.y - this.min.y), (A.z - this.min.z) / (this.max.z - this.min.z))
            }

            intersectsBox(A) {
                return !(A.max.x < this.min.x || A.min.x > this.max.x || A.max.y < this.min.y || A.min.y > this.max.y || A.max.z < this.min.z || A.min.z > this.max.z)
            }

            intersectsSphere(A) {
                return this.clampPoint(A.center, fe), fe.distanceToSquared(A.center) <= A.radius * A.radius
            }

            intersectsPlane(A) {
                let e, t;
                return A.normal.x > 0 ? (e = A.normal.x * this.min.x, t = A.normal.x * this.max.x) : (e = A.normal.x * this.max.x, t = A.normal.x * this.min.x), A.normal.y > 0 ? (e += A.normal.y * this.min.y, t += A.normal.y * this.max.y) : (e += A.normal.y * this.max.y, t += A.normal.y * this.min.y), A.normal.z > 0 ? (e += A.normal.z * this.min.z, t += A.normal.z * this.max.z) : (e += A.normal.z * this.max.z, t += A.normal.z * this.min.z), e <= -A.constant && t >= -A.constant
            }

            intersectsTriangle(A) {
                if (this.isEmpty()) return !1;
                this.getCenter(Ee), Ue.subVectors(this.max, Ee), me.subVectors(A.a, Ee), Be.subVectors(A.b, Ee), we.subVectors(A.c, Ee), ve.subVectors(Be, me), _e.subVectors(we, Be), Ce.subVectors(me, we);
                let e = [0, -ve.z, ve.y, 0, -_e.z, _e.y, 0, -Ce.z, Ce.y, ve.z, 0, -ve.x, _e.z, 0, -_e.x, Ce.z, 0, -Ce.x, -ve.y, ve.x, 0, -_e.y, _e.x, 0, -Ce.y, Ce.x, 0];
                return !!Me(e, me, Be, we, Ue) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Me(e, me, Be, we, Ue) && (ye.crossVectors(ve, _e), e = [ye.x, ye.y, ye.z], Me(e, me, Be, we, Ue)))
            }

            clampPoint(A, e) {
                return e.copy(A).clamp(this.min, this.max)
            }

            distanceToPoint(A) {
                return this.clampPoint(A, fe).distanceTo(A)
            }

            getBoundingSphere(A) {
                return this.isEmpty() ? A.makeEmpty() : (this.getCenter(A.center), A.radius = .5 * this.getSize(fe).length()), A
            }

            intersect(A) {
                return this.min.max(A.min), this.max.min(A.max), this.isEmpty() && this.makeEmpty(), this
            }

            union(A) {
                return this.min.min(A.min), this.max.max(A.max), this
            }

            applyMatrix4(A) {
                return this.isEmpty() || (pe[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(A), pe[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(A), pe[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(A), pe[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(A), pe[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(A), pe[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(A), pe[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(A), pe[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(A), this.setFromPoints(pe)), this
            }

            translate(A) {
                return this.min.add(A), this.max.add(A), this
            }

            equals(A) {
                return A.min.equals(this.min) && A.max.equals(this.max)
            }
        }

        const pe = [new ce, new ce, new ce, new ce, new ce, new ce, new ce, new ce], fe = new ce, ge = new de,
            me = new ce, Be = new ce, we = new ce, ve = new ce, _e = new ce, Ce = new ce, Ee = new ce, Ue = new ce,
            ye = new ce, xe = new ce;

        function Me(A, e, t, n, r) {
            for (let i = 0, a = A.length - 3; i <= a; i += 3) {
                xe.fromArray(A, i);
                const a = r.x * Math.abs(xe.x) + r.y * Math.abs(xe.y) + r.z * Math.abs(xe.z), s = e.dot(xe),
                    o = t.dot(xe), l = n.dot(xe);
                if (Math.max(-Math.max(s, o, l), Math.min(s, o, l)) > a) return !1
            }
            return !0
        }

        const Fe = new de, Se = new ce, be = new ce;

        class Qe {
            constructor(A = new ce, e = -1) {
                this.isSphere = !0, this.center = A, this.radius = e
            }

            set(A, e) {
                return this.center.copy(A), this.radius = e, this
            }

            setFromPoints(A, e) {
                const t = this.center;
                void 0 !== e ? t.copy(e) : Fe.setFromPoints(A).getCenter(t);
                let n = 0;
                for (let e = 0, r = A.length; e < r; e++) n = Math.max(n, t.distanceToSquared(A[e]));
                return this.radius = Math.sqrt(n), this
            }

            copy(A) {
                return this.center.copy(A.center), this.radius = A.radius, this
            }

            isEmpty() {
                return this.radius < 0
            }

            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }

            containsPoint(A) {
                return A.distanceToSquared(this.center) <= this.radius * this.radius
            }

            distanceToPoint(A) {
                return A.distanceTo(this.center) - this.radius
            }

            intersectsSphere(A) {
                const e = this.radius + A.radius;
                return A.center.distanceToSquared(this.center) <= e * e
            }

            intersectsBox(A) {
                return A.intersectsSphere(this)
            }

            intersectsPlane(A) {
                return Math.abs(A.distanceToPoint(this.center)) <= this.radius
            }

            clampPoint(A, e) {
                const t = this.center.distanceToSquared(A);
                return e.copy(A), t > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }

            getBoundingBox(A) {
                return this.isEmpty() ? (A.makeEmpty(), A) : (A.set(this.center, this.center), A.expandByScalar(this.radius), A)
            }

            applyMatrix4(A) {
                return this.center.applyMatrix4(A), this.radius = this.radius * A.getMaxScaleOnAxis(), this
            }

            translate(A) {
                return this.center.add(A), this
            }

            expandByPoint(A) {
                if (this.isEmpty()) return this.center.copy(A), this.radius = 0, this;
                Se.subVectors(A, this.center);
                const e = Se.lengthSq();
                if (e > this.radius * this.radius) {
                    const A = Math.sqrt(e), t = .5 * (A - this.radius);
                    this.center.addScaledVector(Se, t / A), this.radius += t
                }
                return this
            }

            union(A) {
                return A.isEmpty() ? this : this.isEmpty() ? (this.copy(A), this) : (!0 === this.center.equals(A.center) ? this.radius = Math.max(this.radius, A.radius) : (be.subVectors(A.center, this.center).setLength(A.radius), this.expandByPoint(Se.copy(A.center).add(be)), this.expandByPoint(Se.copy(A.center).sub(be))), this)
            }

            equals(A) {
                return A.center.equals(this.center) && A.radius === this.radius
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        const Te = new ce, Ie = new ce, Le = new ce, Re = new ce, He = new ce, De = new ce, Pe = new ce;

        class Ne {
            constructor(A = new ce, e = new ce(0, 0, -1)) {
                this.origin = A, this.direction = e
            }

            set(A, e) {
                return this.origin.copy(A), this.direction.copy(e), this
            }

            copy(A) {
                return this.origin.copy(A.origin), this.direction.copy(A.direction), this
            }

            at(A, e) {
                return e.copy(this.origin).addScaledVector(this.direction, A)
            }

            lookAt(A) {
                return this.direction.copy(A).sub(this.origin).normalize(), this
            }

            recast(A) {
                return this.origin.copy(this.at(A, Te)), this
            }

            closestPointToPoint(A, e) {
                e.subVectors(A, this.origin);
                const t = e.dot(this.direction);
                return t < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, t)
            }

            distanceToPoint(A) {
                return Math.sqrt(this.distanceSqToPoint(A))
            }

            distanceSqToPoint(A) {
                const e = Te.subVectors(A, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(A) : (Te.copy(this.origin).addScaledVector(this.direction, e), Te.distanceToSquared(A))
            }

            distanceSqToSegment(A, e, t, n) {
                Ie.copy(A).add(e).multiplyScalar(.5), Le.copy(e).sub(A).normalize(), Re.copy(this.origin).sub(Ie);
                const r = .5 * A.distanceTo(e), i = -this.direction.dot(Le), a = Re.dot(this.direction),
                    s = -Re.dot(Le), o = Re.lengthSq(), l = Math.abs(1 - i * i);
                let c, u, h, d;
                if (l > 0) if (c = i * s - a, u = i * a - s, d = r * l, c >= 0) if (u >= -d) if (u <= d) {
                    const A = 1 / l;
                    c *= A, u *= A, h = c * (c + i * u + 2 * a) + u * (i * c + u + 2 * s) + o
                } else u = r, c = Math.max(0, -(i * u + a)), h = -c * c + u * (u + 2 * s) + o; else u = -r, c = Math.max(0, -(i * u + a)), h = -c * c + u * (u + 2 * s) + o; else u <= -d ? (c = Math.max(0, -(-i * r + a)), u = c > 0 ? -r : Math.min(Math.max(-r, -s), r), h = -c * c + u * (u + 2 * s) + o) : u <= d ? (c = 0, u = Math.min(Math.max(-r, -s), r), h = u * (u + 2 * s) + o) : (c = Math.max(0, -(i * r + a)), u = c > 0 ? r : Math.min(Math.max(-r, -s), r), h = -c * c + u * (u + 2 * s) + o); else u = i > 0 ? -r : r, c = Math.max(0, -(i * u + a)), h = -c * c + u * (u + 2 * s) + o;
                return t && t.copy(this.origin).addScaledVector(this.direction, c), n && n.copy(Ie).addScaledVector(Le, u), h
            }

            intersectSphere(A, e) {
                Te.subVectors(A.center, this.origin);
                const t = Te.dot(this.direction), n = Te.dot(Te) - t * t, r = A.radius * A.radius;
                if (n > r) return null;
                const i = Math.sqrt(r - n), a = t - i, s = t + i;
                return s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e)
            }

            intersectsSphere(A) {
                return this.distanceSqToPoint(A.center) <= A.radius * A.radius
            }

            distanceToPlane(A) {
                const e = A.normal.dot(this.direction);
                if (0 === e) return 0 === A.distanceToPoint(this.origin) ? 0 : null;
                const t = -(this.origin.dot(A.normal) + A.constant) / e;
                return t >= 0 ? t : null
            }

            intersectPlane(A, e) {
                const t = this.distanceToPlane(A);
                return null === t ? null : this.at(t, e)
            }

            intersectsPlane(A) {
                const e = A.distanceToPoint(this.origin);
                return 0 === e || A.normal.dot(this.direction) * e < 0
            }

            intersectBox(A, e) {
                let t, n, r, i, a, s;
                const o = 1 / this.direction.x, l = 1 / this.direction.y, c = 1 / this.direction.z, u = this.origin;
                return o >= 0 ? (t = (A.min.x - u.x) * o, n = (A.max.x - u.x) * o) : (t = (A.max.x - u.x) * o, n = (A.min.x - u.x) * o), l >= 0 ? (r = (A.min.y - u.y) * l, i = (A.max.y - u.y) * l) : (r = (A.max.y - u.y) * l, i = (A.min.y - u.y) * l), t > i || r > n ? null : ((r > t || isNaN(t)) && (t = r), (i < n || isNaN(n)) && (n = i), c >= 0 ? (a = (A.min.z - u.z) * c, s = (A.max.z - u.z) * c) : (a = (A.max.z - u.z) * c, s = (A.min.z - u.z) * c), t > s || a > n ? null : ((a > t || t != t) && (t = a), (s < n || n != n) && (n = s), n < 0 ? null : this.at(t >= 0 ? t : n, e)))
            }

            intersectsBox(A) {
                return null !== this.intersectBox(A, Te)
            }

            intersectTriangle(A, e, t, n, r) {
                He.subVectors(e, A), De.subVectors(t, A), Pe.crossVectors(He, De);
                let i, a = this.direction.dot(Pe);
                if (a > 0) {
                    if (n) return null;
                    i = 1
                } else {
                    if (!(a < 0)) return null;
                    i = -1, a = -a
                }
                Re.subVectors(this.origin, A);
                const s = i * this.direction.dot(De.crossVectors(Re, De));
                if (s < 0) return null;
                const o = i * this.direction.dot(He.cross(Re));
                if (o < 0) return null;
                if (s + o > a) return null;
                const l = -i * Re.dot(Pe);
                return l < 0 ? null : this.at(l / a, r)
            }

            applyMatrix4(A) {
                return this.origin.applyMatrix4(A), this.direction.transformDirection(A), this
            }

            equals(A) {
                return A.origin.equals(this.origin) && A.direction.equals(this.direction)
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        class Oe {
            constructor(A, e, t, n, r, i, a, s, o, l, c, u, h, d, p, f) {
                Oe.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== A && this.set(A, e, t, n, r, i, a, s, o, l, c, u, h, d, p, f)
            }

            set(A, e, t, n, r, i, a, s, o, l, c, u, h, d, p, f) {
                const g = this.elements;
                return g[0] = A, g[4] = e, g[8] = t, g[12] = n, g[1] = r, g[5] = i, g[9] = a, g[13] = s, g[2] = o, g[6] = l, g[10] = c, g[14] = u, g[3] = h, g[7] = d, g[11] = p, g[15] = f, this
            }

            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }

            clone() {
                return (new Oe).fromArray(this.elements)
            }

            copy(A) {
                const e = this.elements, t = A.elements;
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this
            }

            copyPosition(A) {
                const e = this.elements, t = A.elements;
                return e[12] = t[12], e[13] = t[13], e[14] = t[14], this
            }

            setFromMatrix3(A) {
                const e = A.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }

            extractBasis(A, e, t) {
                return A.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), t.setFromMatrixColumn(this, 2), this
            }

            makeBasis(A, e, t) {
                return this.set(A.x, e.x, t.x, 0, A.y, e.y, t.y, 0, A.z, e.z, t.z, 0, 0, 0, 0, 1), this
            }

            extractRotation(A) {
                const e = this.elements, t = A.elements, n = 1 / Ge.setFromMatrixColumn(A, 0).length(),
                    r = 1 / Ge.setFromMatrixColumn(A, 1).length(), i = 1 / Ge.setFromMatrixColumn(A, 2).length();
                return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = 0, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = 0, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }

            makeRotationFromEuler(A) {
                const e = this.elements, t = A.x, n = A.y, r = A.z, i = Math.cos(t), a = Math.sin(t), s = Math.cos(n),
                    o = Math.sin(n), l = Math.cos(r), c = Math.sin(r);
                if ("XYZ" === A.order) {
                    const A = i * l, t = i * c, n = a * l, r = a * c;
                    e[0] = s * l, e[4] = -s * c, e[8] = o, e[1] = t + n * o, e[5] = A - r * o, e[9] = -a * s, e[2] = r - A * o, e[6] = n + t * o, e[10] = i * s
                } else if ("YXZ" === A.order) {
                    const A = s * l, t = s * c, n = o * l, r = o * c;
                    e[0] = A + r * a, e[4] = n * a - t, e[8] = i * o, e[1] = i * c, e[5] = i * l, e[9] = -a, e[2] = t * a - n, e[6] = r + A * a, e[10] = i * s
                } else if ("ZXY" === A.order) {
                    const A = s * l, t = s * c, n = o * l, r = o * c;
                    e[0] = A - r * a, e[4] = -i * c, e[8] = n + t * a, e[1] = t + n * a, e[5] = i * l, e[9] = r - A * a, e[2] = -i * o, e[6] = a, e[10] = i * s
                } else if ("ZYX" === A.order) {
                    const A = i * l, t = i * c, n = a * l, r = a * c;
                    e[0] = s * l, e[4] = n * o - t, e[8] = A * o + r, e[1] = s * c, e[5] = r * o + A, e[9] = t * o - n, e[2] = -o, e[6] = a * s, e[10] = i * s
                } else if ("YZX" === A.order) {
                    const A = i * s, t = i * o, n = a * s, r = a * o;
                    e[0] = s * l, e[4] = r - A * c, e[8] = n * c + t, e[1] = c, e[5] = i * l, e[9] = -a * l, e[2] = -o * l, e[6] = t * c + n, e[10] = A - r * c
                } else if ("XZY" === A.order) {
                    const A = i * s, t = i * o, n = a * s, r = a * o;
                    e[0] = s * l, e[4] = -c, e[8] = o * l, e[1] = A * c + r, e[5] = i * l, e[9] = t * c - n, e[2] = n * c - t, e[6] = a * l, e[10] = r * c + A
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }

            makeRotationFromQuaternion(A) {
                return this.compose(Ke, A, ke)
            }

            lookAt(A, e, t) {
                const n = this.elements;
                return Xe.subVectors(A, e), 0 === Xe.lengthSq() && (Xe.z = 1), Xe.normalize(), ze.crossVectors(t, Xe), 0 === ze.lengthSq() && (1 === Math.abs(t.z) ? Xe.x += 1e-4 : Xe.z += 1e-4, Xe.normalize(), ze.crossVectors(t, Xe)), ze.normalize(), We.crossVectors(Xe, ze), n[0] = ze.x, n[4] = We.x, n[8] = Xe.x, n[1] = ze.y, n[5] = We.y, n[9] = Xe.y, n[2] = ze.z, n[6] = We.z, n[10] = Xe.z, this
            }

            multiply(A) {
                return this.multiplyMatrices(this, A)
            }

            premultiply(A) {
                return this.multiplyMatrices(A, this)
            }

            multiplyMatrices(A, e) {
                const t = A.elements, n = e.elements, r = this.elements, i = t[0], a = t[4], s = t[8], o = t[12],
                    l = t[1], c = t[5], u = t[9], h = t[13], d = t[2], p = t[6], f = t[10], g = t[14], m = t[3],
                    B = t[7], w = t[11], v = t[15], _ = n[0], C = n[4], E = n[8], U = n[12], y = n[1], x = n[5],
                    M = n[9], F = n[13], S = n[2], b = n[6], Q = n[10], T = n[14], I = n[3], L = n[7], R = n[11],
                    H = n[15];
                return r[0] = i * _ + a * y + s * S + o * I, r[4] = i * C + a * x + s * b + o * L, r[8] = i * E + a * M + s * Q + o * R, r[12] = i * U + a * F + s * T + o * H, r[1] = l * _ + c * y + u * S + h * I, r[5] = l * C + c * x + u * b + h * L, r[9] = l * E + c * M + u * Q + h * R, r[13] = l * U + c * F + u * T + h * H, r[2] = d * _ + p * y + f * S + g * I, r[6] = d * C + p * x + f * b + g * L, r[10] = d * E + p * M + f * Q + g * R, r[14] = d * U + p * F + f * T + g * H, r[3] = m * _ + B * y + w * S + v * I, r[7] = m * C + B * x + w * b + v * L, r[11] = m * E + B * M + w * Q + v * R, r[15] = m * U + B * F + w * T + v * H, this
            }

            multiplyScalar(A) {
                const e = this.elements;
                return e[0] *= A, e[4] *= A, e[8] *= A, e[12] *= A, e[1] *= A, e[5] *= A, e[9] *= A, e[13] *= A, e[2] *= A, e[6] *= A, e[10] *= A, e[14] *= A, e[3] *= A, e[7] *= A, e[11] *= A, e[15] *= A, this
            }

            determinant() {
                const A = this.elements, e = A[0], t = A[4], n = A[8], r = A[12], i = A[1], a = A[5], s = A[9],
                    o = A[13], l = A[2], c = A[6], u = A[10], h = A[14];
                return A[3] * (+r * s * c - n * o * c - r * a * u + t * o * u + n * a * h - t * s * h) + A[7] * (+e * s * h - e * o * u + r * i * u - n * i * h + n * o * l - r * s * l) + A[11] * (+e * o * c - e * a * h - r * i * c + t * i * h + r * a * l - t * o * l) + A[15] * (-n * a * l - e * s * c + e * a * u + n * i * c - t * i * u + t * s * l)
            }

            transpose() {
                const A = this.elements;
                let e;
                return e = A[1], A[1] = A[4], A[4] = e, e = A[2], A[2] = A[8], A[8] = e, e = A[6], A[6] = A[9], A[9] = e, e = A[3], A[3] = A[12], A[12] = e, e = A[7], A[7] = A[13], A[13] = e, e = A[11], A[11] = A[14], A[14] = e, this
            }

            setPosition(A, e, t) {
                const n = this.elements;
                return A.isVector3 ? (n[12] = A.x, n[13] = A.y, n[14] = A.z) : (n[12] = A, n[13] = e, n[14] = t), this
            }

            invert() {
                const A = this.elements, e = A[0], t = A[1], n = A[2], r = A[3], i = A[4], a = A[5], s = A[6], o = A[7],
                    l = A[8], c = A[9], u = A[10], h = A[11], d = A[12], p = A[13], f = A[14], g = A[15],
                    m = c * f * o - p * u * o + p * s * h - a * f * h - c * s * g + a * u * g,
                    B = d * u * o - l * f * o - d * s * h + i * f * h + l * s * g - i * u * g,
                    w = l * p * o - d * c * o + d * a * h - i * p * h - l * a * g + i * c * g,
                    v = d * c * s - l * p * s - d * a * u + i * p * u + l * a * f - i * c * f,
                    _ = e * m + t * B + n * w + r * v;
                if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const C = 1 / _;
                return A[0] = m * C, A[1] = (p * u * r - c * f * r - p * n * h + t * f * h + c * n * g - t * u * g) * C, A[2] = (a * f * r - p * s * r + p * n * o - t * f * o - a * n * g + t * s * g) * C, A[3] = (c * s * r - a * u * r - c * n * o + t * u * o + a * n * h - t * s * h) * C, A[4] = B * C, A[5] = (l * f * r - d * u * r + d * n * h - e * f * h - l * n * g + e * u * g) * C, A[6] = (d * s * r - i * f * r - d * n * o + e * f * o + i * n * g - e * s * g) * C, A[7] = (i * u * r - l * s * r + l * n * o - e * u * o - i * n * h + e * s * h) * C, A[8] = w * C, A[9] = (d * c * r - l * p * r - d * t * h + e * p * h + l * t * g - e * c * g) * C, A[10] = (i * p * r - d * a * r + d * t * o - e * p * o - i * t * g + e * a * g) * C, A[11] = (l * a * r - i * c * r - l * t * o + e * c * o + i * t * h - e * a * h) * C, A[12] = v * C, A[13] = (l * p * n - d * c * n + d * t * u - e * p * u - l * t * f + e * c * f) * C, A[14] = (d * a * n - i * p * n - d * t * s + e * p * s + i * t * f - e * a * f) * C, A[15] = (i * c * n - l * a * n + l * t * s - e * c * s - i * t * u + e * a * u) * C, this
            }

            scale(A) {
                const e = this.elements, t = A.x, n = A.y, r = A.z;
                return e[0] *= t, e[4] *= n, e[8] *= r, e[1] *= t, e[5] *= n, e[9] *= r, e[2] *= t, e[6] *= n, e[10] *= r, e[3] *= t, e[7] *= n, e[11] *= r, this
            }

            getMaxScaleOnAxis() {
                const A = this.elements, e = A[0] * A[0] + A[1] * A[1] + A[2] * A[2],
                    t = A[4] * A[4] + A[5] * A[5] + A[6] * A[6], n = A[8] * A[8] + A[9] * A[9] + A[10] * A[10];
                return Math.sqrt(Math.max(e, t, n))
            }

            makeTranslation(A, e, t) {
                return A.isVector3 ? this.set(1, 0, 0, A.x, 0, 1, 0, A.y, 0, 0, 1, A.z, 0, 0, 0, 1) : this.set(1, 0, 0, A, 0, 1, 0, e, 0, 0, 1, t, 0, 0, 0, 1), this
            }

            makeRotationX(A) {
                const e = Math.cos(A), t = Math.sin(A);
                return this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this
            }

            makeRotationY(A) {
                const e = Math.cos(A), t = Math.sin(A);
                return this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this
            }

            makeRotationZ(A) {
                const e = Math.cos(A), t = Math.sin(A);
                return this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }

            makeRotationAxis(A, e) {
                const t = Math.cos(e), n = Math.sin(e), r = 1 - t, i = A.x, a = A.y, s = A.z, o = r * i, l = r * a;
                return this.set(o * i + t, o * a - n * s, o * s + n * a, 0, o * a + n * s, l * a + t, l * s - n * i, 0, o * s - n * a, l * s + n * i, r * s * s + t, 0, 0, 0, 0, 1), this
            }

            makeScale(A, e, t) {
                return this.set(A, 0, 0, 0, 0, e, 0, 0, 0, 0, t, 0, 0, 0, 0, 1), this
            }

            makeShear(A, e, t, n, r, i) {
                return this.set(1, t, r, 0, A, 1, i, 0, e, n, 1, 0, 0, 0, 0, 1), this
            }

            compose(A, e, t) {
                const n = this.elements, r = e._x, i = e._y, a = e._z, s = e._w, o = r + r, l = i + i, c = a + a,
                    u = r * o, h = r * l, d = r * c, p = i * l, f = i * c, g = a * c, m = s * o, B = s * l, w = s * c,
                    v = t.x, _ = t.y, C = t.z;
                return n[0] = (1 - (p + g)) * v, n[1] = (h + w) * v, n[2] = (d - B) * v, n[3] = 0, n[4] = (h - w) * _, n[5] = (1 - (u + g)) * _, n[6] = (f + m) * _, n[7] = 0, n[8] = (d + B) * C, n[9] = (f - m) * C, n[10] = (1 - (u + p)) * C, n[11] = 0, n[12] = A.x, n[13] = A.y, n[14] = A.z, n[15] = 1, this
            }

            decompose(A, e, t) {
                const n = this.elements;
                let r = Ge.set(n[0], n[1], n[2]).length();
                const i = Ge.set(n[4], n[5], n[6]).length(), a = Ge.set(n[8], n[9], n[10]).length();
                this.determinant() < 0 && (r = -r), A.x = n[12], A.y = n[13], A.z = n[14], Ve.copy(this);
                const s = 1 / r, o = 1 / i, l = 1 / a;
                return Ve.elements[0] *= s, Ve.elements[1] *= s, Ve.elements[2] *= s, Ve.elements[4] *= o, Ve.elements[5] *= o, Ve.elements[6] *= o, Ve.elements[8] *= l, Ve.elements[9] *= l, Ve.elements[10] *= l, e.setFromRotationMatrix(Ve), t.x = r, t.y = i, t.z = a, this
            }

            makePerspective(A, e, t, n, r, i, a = 2e3) {
                const s = this.elements, o = 2 * r / (e - A), l = 2 * r / (t - n), c = (e + A) / (e - A),
                    u = (t + n) / (t - n);
                let h, d;
                if (a === _A) h = -(i + r) / (i - r), d = -2 * i * r / (i - r); else {
                    if (a !== CA) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                    h = -i / (i - r), d = -i * r / (i - r)
                }
                return s[0] = o, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            }

            makeOrthographic(A, e, t, n, r, i, a = 2e3) {
                const s = this.elements, o = 1 / (e - A), l = 1 / (t - n), c = 1 / (i - r), u = (e + A) * o,
                    h = (t + n) * l;
                let d, p;
                if (a === _A) d = (i + r) * c, p = -2 * c; else {
                    if (a !== CA) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                    d = r * c, p = -1 * c
                }
                return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = p, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            }

            equals(A) {
                const e = this.elements, t = A.elements;
                for (let A = 0; A < 16; A++) if (e[A] !== t[A]) return !1;
                return !0
            }

            fromArray(A, e = 0) {
                for (let t = 0; t < 16; t++) this.elements[t] = A[t + e];
                return this
            }

            toArray(A = [], e = 0) {
                const t = this.elements;
                return A[e] = t[0], A[e + 1] = t[1], A[e + 2] = t[2], A[e + 3] = t[3], A[e + 4] = t[4], A[e + 5] = t[5], A[e + 6] = t[6], A[e + 7] = t[7], A[e + 8] = t[8], A[e + 9] = t[9], A[e + 10] = t[10], A[e + 11] = t[11], A[e + 12] = t[12], A[e + 13] = t[13], A[e + 14] = t[14], A[e + 15] = t[15], A
            }
        }

        const Ge = new ce, Ve = new Oe, Ke = new ce(0, 0, 0), ke = new ce(1, 1, 1), ze = new ce, We = new ce,
            Xe = new ce, Ye = new Oe, Je = new le;

        class je {
            constructor(A = 0, e = 0, t = 0, n = je.DEFAULT_ORDER) {
                this.isEuler = !0, this._x = A, this._y = e, this._z = t, this._order = n
            }

            get x() {
                return this._x
            }

            set x(A) {
                this._x = A, this._onChangeCallback()
            }

            get y() {
                return this._y
            }

            set y(A) {
                this._y = A, this._onChangeCallback()
            }

            get z() {
                return this._z
            }

            set z(A) {
                this._z = A, this._onChangeCallback()
            }

            get order() {
                return this._order
            }

            set order(A) {
                this._order = A, this._onChangeCallback()
            }

            set(A, e, t, n = this._order) {
                return this._x = A, this._y = e, this._z = t, this._order = n, this._onChangeCallback(), this
            }

            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }

            copy(A) {
                return this._x = A._x, this._y = A._y, this._z = A._z, this._order = A._order, this._onChangeCallback(), this
            }

            setFromRotationMatrix(A, e = this._order, t = !0) {
                const n = A.elements, r = n[0], i = n[4], a = n[8], s = n[1], o = n[5], l = n[9], c = n[2], u = n[6],
                    h = n[10];
                switch (e) {
                    case"XYZ":
                        this._y = Math.asin(SA(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-l, h), this._z = Math.atan2(-i, r)) : (this._x = Math.atan2(u, o), this._z = 0);
                        break;
                    case"YXZ":
                        this._x = Math.asin(-SA(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(a, h), this._z = Math.atan2(s, o)) : (this._y = Math.atan2(-c, r), this._z = 0);
                        break;
                    case"ZXY":
                        this._x = Math.asin(SA(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, h), this._z = Math.atan2(-i, o)) : (this._y = 0, this._z = Math.atan2(s, r));
                        break;
                    case"ZYX":
                        this._y = Math.asin(-SA(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, h), this._z = Math.atan2(s, r)) : (this._x = 0, this._z = Math.atan2(-i, o));
                        break;
                    case"YZX":
                        this._z = Math.asin(SA(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-l, o), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, h));
                        break;
                    case"XZY":
                        this._z = Math.asin(-SA(i, -1, 1)), Math.abs(i) < .9999999 ? (this._x = Math.atan2(u, o), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-l, h), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !0 === t && this._onChangeCallback(), this
            }

            setFromQuaternion(A, e, t) {
                return Ye.makeRotationFromQuaternion(A), this.setFromRotationMatrix(Ye, e, t)
            }

            setFromVector3(A, e = this._order) {
                return this.set(A.x, A.y, A.z, e)
            }

            reorder(A) {
                return Je.setFromEuler(this), this.setFromQuaternion(Je, A)
            }

            equals(A) {
                return A._x === this._x && A._y === this._y && A._z === this._z && A._order === this._order
            }

            fromArray(A) {
                return this._x = A[0], this._y = A[1], this._z = A[2], void 0 !== A[3] && (this._order = A[3]), this._onChangeCallback(), this
            }

            toArray(A = [], e = 0) {
                return A[e] = this._x, A[e + 1] = this._y, A[e + 2] = this._z, A[e + 3] = this._order, A
            }

            _onChange(A) {
                return this._onChangeCallback = A, this
            }

            _onChangeCallback() {
            }

            * [Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
        }

        je.DEFAULT_ORDER = "XYZ";

        class Ze {
            constructor() {
                this.mask = 1
            }

            set(A) {
                this.mask = (1 << A | 0) >>> 0
            }

            enable(A) {
                this.mask |= 1 << A | 0
            }

            enableAll() {
                this.mask = -1
            }

            toggle(A) {
                this.mask ^= 1 << A | 0
            }

            disable(A) {
                this.mask &= ~(1 << A | 0)
            }

            disableAll() {
                this.mask = 0
            }

            test(A) {
                return 0 != (this.mask & A.mask)
            }

            isEnabled(A) {
                return 0 != (this.mask & (1 << A | 0))
            }
        }

        let qe = 0;
        const $e = new ce, At = new le, et = new Oe, tt = new ce, nt = new ce, rt = new ce, it = new le,
            at = new ce(1, 0, 0), st = new ce(0, 1, 0), ot = new ce(0, 0, 1), lt = {type: "added"},
            ct = {type: "removed"}, ut = {type: "childadded", child: null}, ht = {type: "childremoved", child: null};

        class dt extends EA {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {value: qe++}), this.uuid = FA(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = dt.DEFAULT_UP.clone();
                const A = new ce, e = new je, t = new le, n = new ce(1, 1, 1);
                e._onChange((function () {
                    t.setFromEuler(e, !1)
                })), t._onChange((function () {
                    e.setFromQuaternion(t, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {configurable: !0, enumerable: !0, value: A},
                    rotation: {configurable: !0, enumerable: !0, value: e},
                    quaternion: {configurable: !0, enumerable: !0, value: t},
                    scale: {configurable: !0, enumerable: !0, value: n},
                    modelViewMatrix: {value: new Oe},
                    normalMatrix: {value: new PA}
                }), this.matrix = new Oe, this.matrixWorld = new Oe, this.matrixAutoUpdate = dt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = dt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Ze, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }

            onBeforeShadow() {
            }

            onAfterShadow() {
            }

            onBeforeRender() {
            }

            onAfterRender() {
            }

            applyMatrix4(A) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(A), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }

            applyQuaternion(A) {
                return this.quaternion.premultiply(A), this
            }

            setRotationFromAxisAngle(A, e) {
                this.quaternion.setFromAxisAngle(A, e)
            }

            setRotationFromEuler(A) {
                this.quaternion.setFromEuler(A, !0)
            }

            setRotationFromMatrix(A) {
                this.quaternion.setFromRotationMatrix(A)
            }

            setRotationFromQuaternion(A) {
                this.quaternion.copy(A)
            }

            rotateOnAxis(A, e) {
                return At.setFromAxisAngle(A, e), this.quaternion.multiply(At), this
            }

            rotateOnWorldAxis(A, e) {
                return At.setFromAxisAngle(A, e), this.quaternion.premultiply(At), this
            }

            rotateX(A) {
                return this.rotateOnAxis(at, A)
            }

            rotateY(A) {
                return this.rotateOnAxis(st, A)
            }

            rotateZ(A) {
                return this.rotateOnAxis(ot, A)
            }

            translateOnAxis(A, e) {
                return $e.copy(A).applyQuaternion(this.quaternion), this.position.add($e.multiplyScalar(e)), this
            }

            translateX(A) {
                return this.translateOnAxis(at, A)
            }

            translateY(A) {
                return this.translateOnAxis(st, A)
            }

            translateZ(A) {
                return this.translateOnAxis(ot, A)
            }

            localToWorld(A) {
                return this.updateWorldMatrix(!0, !1), A.applyMatrix4(this.matrixWorld)
            }

            worldToLocal(A) {
                return this.updateWorldMatrix(!0, !1), A.applyMatrix4(et.copy(this.matrixWorld).invert())
            }

            lookAt(A, e, t) {
                A.isVector3 ? tt.copy(A) : tt.set(A, e, t);
                const n = this.parent;
                this.updateWorldMatrix(!0, !1), nt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? et.lookAt(nt, tt, this.up) : et.lookAt(tt, nt, this.up), this.quaternion.setFromRotationMatrix(et), n && (et.extractRotation(n.matrixWorld), At.setFromRotationMatrix(et), this.quaternion.premultiply(At.invert()))
            }

            add(A) {
                if (arguments.length > 1) {
                    for (let A = 0; A < arguments.length; A++) this.add(arguments[A]);
                    return this
                }
                return A === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", A), this) : (A && A.isObject3D ? (null !== A.parent && A.parent.remove(A), A.parent = this, this.children.push(A), A.dispatchEvent(lt), ut.child = A, this.dispatchEvent(ut), ut.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", A), this)
            }

            remove(A) {
                if (arguments.length > 1) {
                    for (let A = 0; A < arguments.length; A++) this.remove(arguments[A]);
                    return this
                }
                const e = this.children.indexOf(A);
                return -1 !== e && (A.parent = null, this.children.splice(e, 1), A.dispatchEvent(ct), ht.child = A, this.dispatchEvent(ht), ht.child = null), this
            }

            removeFromParent() {
                const A = this.parent;
                return null !== A && A.remove(this), this
            }

            clear() {
                return this.remove(...this.children)
            }

            attach(A) {
                return this.updateWorldMatrix(!0, !1), et.copy(this.matrixWorld).invert(), null !== A.parent && (A.parent.updateWorldMatrix(!0, !1), et.multiply(A.parent.matrixWorld)), A.applyMatrix4(et), this.add(A), A.updateWorldMatrix(!1, !0), this
            }

            getObjectById(A) {
                return this.getObjectByProperty("id", A)
            }

            getObjectByName(A) {
                return this.getObjectByProperty("name", A)
            }

            getObjectByProperty(A, e) {
                if (this[A] === e) return this;
                for (let t = 0, n = this.children.length; t < n; t++) {
                    const n = this.children[t].getObjectByProperty(A, e);
                    if (void 0 !== n) return n
                }
            }

            getObjectsByProperty(A, e, t = []) {
                this[A] === e && t.push(this);
                const n = this.children;
                for (let r = 0, i = n.length; r < i; r++) n[r].getObjectsByProperty(A, e, t);
                return t
            }

            getWorldPosition(A) {
                return this.updateWorldMatrix(!0, !1), A.setFromMatrixPosition(this.matrixWorld)
            }

            getWorldQuaternion(A) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nt, A, rt), A
            }

            getWorldScale(A) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nt, it, A), A
            }

            getWorldDirection(A) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return A.set(e[8], e[9], e[10]).normalize()
            }

            raycast() {
            }

            traverse(A) {
                A(this);
                const e = this.children;
                for (let t = 0, n = e.length; t < n; t++) e[t].traverse(A)
            }

            traverseVisible(A) {
                if (!1 === this.visible) return;
                A(this);
                const e = this.children;
                for (let t = 0, n = e.length; t < n; t++) e[t].traverseVisible(A)
            }

            traverseAncestors(A) {
                const e = this.parent;
                null !== e && (A(e), e.traverseAncestors(A))
            }

            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }

            updateMatrixWorld(A) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || A) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, A = !0);
                const e = this.children;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t];
                    !0 !== n.matrixWorldAutoUpdate && !0 !== A || n.updateMatrixWorld(A)
                }
            }

            updateWorldMatrix(A, e) {
                const t = this.parent;
                if (!0 === A && null !== t && !0 === t.matrixWorldAutoUpdate && t.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const A = this.children;
                    for (let e = 0, t = A.length; e < t; e++) {
                        const t = A[e];
                        !0 === t.matrixWorldAutoUpdate && t.updateWorldMatrix(!1, !0)
                    }
                }
            }

            toJSON(A) {
                const e = void 0 === A || "string" == typeof A, t = {};
                e && (A = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, t.metadata = {version: 4.6, type: "Object", generator: "Object3D.toJSON"});
                const n = {};

                function r(e, t) {
                    return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(A)), t.uuid
                }

                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((A => ({
                    boxInitialized: A.boxInitialized,
                    boxMin: A.box.min.toArray(),
                    boxMax: A.box.max.toArray(),
                    sphereInitialized: A.sphereInitialized,
                    sphereRadius: A.sphere.radius,
                    sphereCenter: A.sphere.center.toArray()
                }))), n.maxGeometryCount = this._maxGeometryCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(A), null !== this.boundingSphere && (n.boundingSphere = {
                    center: n.boundingSphere.center.toArray(),
                    radius: n.boundingSphere.radius
                }), null !== this.boundingBox && (n.boundingBox = {
                    min: n.boundingBox.min.toArray(),
                    max: n.boundingBox.max.toArray()
                })), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(A).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (n.environment = this.environment.toJSON(A).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
                    n.geometry = r(A.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const t = e.shapes;
                        if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            r(A.shapes, n)
                        } else r(A.shapes, t)
                    }
                }
                if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(A.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
                    const e = [];
                    for (let t = 0, n = this.material.length; t < n; t++) e.push(r(A.materials, this.material[t]));
                    n.material = e
                } else n.material = r(A.materials, this.material);
                if (this.children.length > 0) {
                    n.children = [];
                    for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(A).object)
                }
                if (this.animations.length > 0) {
                    n.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const t = this.animations[e];
                        n.animations.push(r(A.animations, t))
                    }
                }
                if (e) {
                    const e = i(A.geometries), n = i(A.materials), r = i(A.textures), a = i(A.images), s = i(A.shapes),
                        o = i(A.skeletons), l = i(A.animations), c = i(A.nodes);
                    e.length > 0 && (t.geometries = e), n.length > 0 && (t.materials = n), r.length > 0 && (t.textures = r), a.length > 0 && (t.images = a), s.length > 0 && (t.shapes = s), o.length > 0 && (t.skeletons = o), l.length > 0 && (t.animations = l), c.length > 0 && (t.nodes = c)
                }
                return t.object = n, t;

                function i(A) {
                    const e = [];
                    for (const t in A) {
                        const n = A[t];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }
            }

            clone(A) {
                return (new this.constructor).copy(this, A)
            }

            copy(A, e = !0) {
                if (this.name = A.name, this.up.copy(A.up), this.position.copy(A.position), this.rotation.order = A.rotation.order, this.quaternion.copy(A.quaternion), this.scale.copy(A.scale), this.matrix.copy(A.matrix), this.matrixWorld.copy(A.matrixWorld), this.matrixAutoUpdate = A.matrixAutoUpdate, this.matrixWorldAutoUpdate = A.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = A.matrixWorldNeedsUpdate, this.layers.mask = A.layers.mask, this.visible = A.visible, this.castShadow = A.castShadow, this.receiveShadow = A.receiveShadow, this.frustumCulled = A.frustumCulled, this.renderOrder = A.renderOrder, this.animations = A.animations.slice(), this.userData = JSON.parse(JSON.stringify(A.userData)), !0 === e) for (let e = 0; e < A.children.length; e++) {
                    const t = A.children[e];
                    this.add(t.clone())
                }
                return this
            }
        }

        dt.DEFAULT_UP = new ce(0, 1, 0), dt.DEFAULT_MATRIX_AUTO_UPDATE = !0, dt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const pt = new ce, ft = new ce, gt = new ce, mt = new ce, Bt = new ce, wt = new ce, vt = new ce, _t = new ce,
            Ct = new ce, Et = new ce;

        class Ut {
            constructor(A = new ce, e = new ce, t = new ce) {
                this.a = A, this.b = e, this.c = t
            }

            static getNormal(A, e, t, n) {
                n.subVectors(t, e), pt.subVectors(A, e), n.cross(pt);
                const r = n.lengthSq();
                return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
            }

            static getBarycoord(A, e, t, n, r) {
                pt.subVectors(n, e), ft.subVectors(t, e), gt.subVectors(A, e);
                const i = pt.dot(pt), a = pt.dot(ft), s = pt.dot(gt), o = ft.dot(ft), l = ft.dot(gt), c = i * o - a * a;
                if (0 === c) return r.set(0, 0, 0), null;
                const u = 1 / c, h = (o * s - a * l) * u, d = (i * l - a * s) * u;
                return r.set(1 - h - d, d, h)
            }

            static containsPoint(A, e, t, n) {
                return null !== this.getBarycoord(A, e, t, n, mt) && mt.x >= 0 && mt.y >= 0 && mt.x + mt.y <= 1
            }

            static getInterpolation(A, e, t, n, r, i, a, s) {
                return null === this.getBarycoord(A, e, t, n, mt) ? (s.x = 0, s.y = 0, "z" in s && (s.z = 0), "w" in s && (s.w = 0), null) : (s.setScalar(0), s.addScaledVector(r, mt.x), s.addScaledVector(i, mt.y), s.addScaledVector(a, mt.z), s)
            }

            static isFrontFacing(A, e, t, n) {
                return pt.subVectors(t, e), ft.subVectors(A, e), pt.cross(ft).dot(n) < 0
            }

            set(A, e, t) {
                return this.a.copy(A), this.b.copy(e), this.c.copy(t), this
            }

            setFromPointsAndIndices(A, e, t, n) {
                return this.a.copy(A[e]), this.b.copy(A[t]), this.c.copy(A[n]), this
            }

            setFromAttributeAndIndices(A, e, t, n) {
                return this.a.fromBufferAttribute(A, e), this.b.fromBufferAttribute(A, t), this.c.fromBufferAttribute(A, n), this
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(A) {
                return this.a.copy(A.a), this.b.copy(A.b), this.c.copy(A.c), this
            }

            getArea() {
                return pt.subVectors(this.c, this.b), ft.subVectors(this.a, this.b), .5 * pt.cross(ft).length()
            }

            getMidpoint(A) {
                return A.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }

            getNormal(A) {
                return Ut.getNormal(this.a, this.b, this.c, A)
            }

            getPlane(A) {
                return A.setFromCoplanarPoints(this.a, this.b, this.c)
            }

            getBarycoord(A, e) {
                return Ut.getBarycoord(A, this.a, this.b, this.c, e)
            }

            getInterpolation(A, e, t, n, r) {
                return Ut.getInterpolation(A, this.a, this.b, this.c, e, t, n, r)
            }

            containsPoint(A) {
                return Ut.containsPoint(A, this.a, this.b, this.c)
            }

            isFrontFacing(A) {
                return Ut.isFrontFacing(this.a, this.b, this.c, A)
            }

            intersectsBox(A) {
                return A.intersectsTriangle(this)
            }

            closestPointToPoint(A, e) {
                const t = this.a, n = this.b, r = this.c;
                let i, a;
                Bt.subVectors(n, t), wt.subVectors(r, t), _t.subVectors(A, t);
                const s = Bt.dot(_t), o = wt.dot(_t);
                if (s <= 0 && o <= 0) return e.copy(t);
                Ct.subVectors(A, n);
                const l = Bt.dot(Ct), c = wt.dot(Ct);
                if (l >= 0 && c <= l) return e.copy(n);
                const u = s * c - l * o;
                if (u <= 0 && s >= 0 && l <= 0) return i = s / (s - l), e.copy(t).addScaledVector(Bt, i);
                Et.subVectors(A, r);
                const h = Bt.dot(Et), d = wt.dot(Et);
                if (d >= 0 && h <= d) return e.copy(r);
                const p = h * o - s * d;
                if (p <= 0 && o >= 0 && d <= 0) return a = o / (o - d), e.copy(t).addScaledVector(wt, a);
                const f = l * d - h * c;
                if (f <= 0 && c - l >= 0 && h - d >= 0) return vt.subVectors(r, n), a = (c - l) / (c - l + (h - d)), e.copy(n).addScaledVector(vt, a);
                const g = 1 / (f + p + u);
                return i = p * g, a = u * g, e.copy(t).addScaledVector(Bt, i).addScaledVector(wt, a)
            }

            equals(A) {
                return A.a.equals(this.a) && A.b.equals(this.b) && A.c.equals(this.c)
            }
        }

        const yt = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }, xt = {h: 0, s: 0, l: 0}, Mt = {h: 0, s: 0, l: 0};

        function Ft(A, e, t) {
            return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? A + 6 * (e - A) * t : t < .5 ? e : t < 2 / 3 ? A + 6 * (e - A) * (2 / 3 - t) : A
        }

        class St {
            constructor(A, e, t) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(A, e, t)
            }

            set(A, e, t) {
                if (void 0 === e && void 0 === t) {
                    const e = A;
                    e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                } else this.setRGB(A, e, t);
                return this
            }

            setScalar(A) {
                return this.r = A, this.g = A, this.b = A, this
            }

            setHex(A, e = cA) {
                return A = Math.floor(A), this.r = (A >> 16 & 255) / 255, this.g = (A >> 8 & 255) / 255, this.b = (255 & A) / 255, YA.toWorkingColorSpace(this, e), this
            }

            setRGB(A, e, t, n = YA.workingColorSpace) {
                return this.r = A, this.g = e, this.b = t, YA.toWorkingColorSpace(this, n), this
            }

            setHSL(A, e, t, n = YA.workingColorSpace) {
                if (A = bA(A, 1), e = SA(e, 0, 1), t = SA(t, 0, 1), 0 === e) this.r = this.g = this.b = t; else {
                    const n = t <= .5 ? t * (1 + e) : t + e - t * e, r = 2 * t - n;
                    this.r = Ft(r, n, A + 1 / 3), this.g = Ft(r, n, A), this.b = Ft(r, n, A - 1 / 3)
                }
                return YA.toWorkingColorSpace(this, n), this
            }

            setStyle(A, e = cA) {
                function t(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + A + " will be ignored.")
                }

                let n;
                if (n = /^(\w+)\(([^\)]*)\)/.exec(A)) {
                    let r;
                    const i = n[1], a = n[2];
                    switch (i) {
                        case"rgb":
                        case"rgba":
                            if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return t(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                            if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return t(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                            break;
                        case"hsl":
                        case"hsla":
                            if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return t(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                            break;
                        default:
                            console.warn("THREE.Color: Unknown color model " + A)
                    }
                } else if (n = /^\#([A-Fa-f\d]+)$/.exec(A)) {
                    const t = n[1], r = t.length;
                    if (3 === r) return this.setRGB(parseInt(t.charAt(0), 16) / 15, parseInt(t.charAt(1), 16) / 15, parseInt(t.charAt(2), 16) / 15, e);
                    if (6 === r) return this.setHex(parseInt(t, 16), e);
                    console.warn("THREE.Color: Invalid hex color " + A)
                } else if (A && A.length > 0) return this.setColorName(A, e);
                return this
            }

            setColorName(A, e = cA) {
                const t = yt[A.toLowerCase()];
                return void 0 !== t ? this.setHex(t, e) : console.warn("THREE.Color: Unknown color " + A), this
            }

            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }

            copy(A) {
                return this.r = A.r, this.g = A.g, this.b = A.b, this
            }

            copySRGBToLinear(A) {
                return this.r = JA(A.r), this.g = JA(A.g), this.b = JA(A.b), this
            }

            copyLinearToSRGB(A) {
                return this.r = jA(A.r), this.g = jA(A.g), this.b = jA(A.b), this
            }

            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }

            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }

            getHex(A = cA) {
                return YA.fromWorkingColorSpace(bt.copy(this), A), 65536 * Math.round(SA(255 * bt.r, 0, 255)) + 256 * Math.round(SA(255 * bt.g, 0, 255)) + Math.round(SA(255 * bt.b, 0, 255))
            }

            getHexString(A = cA) {
                return ("000000" + this.getHex(A).toString(16)).slice(-6)
            }

            getHSL(A, e = YA.workingColorSpace) {
                YA.fromWorkingColorSpace(bt.copy(this), e);
                const t = bt.r, n = bt.g, r = bt.b, i = Math.max(t, n, r), a = Math.min(t, n, r);
                let s, o;
                const l = (a + i) / 2;
                if (a === i) s = 0, o = 0; else {
                    const A = i - a;
                    switch (o = l <= .5 ? A / (i + a) : A / (2 - i - a), i) {
                        case t:
                            s = (n - r) / A + (n < r ? 6 : 0);
                            break;
                        case n:
                            s = (r - t) / A + 2;
                            break;
                        case r:
                            s = (t - n) / A + 4
                    }
                    s /= 6
                }
                return A.h = s, A.s = o, A.l = l, A
            }

            getRGB(A, e = YA.workingColorSpace) {
                return YA.fromWorkingColorSpace(bt.copy(this), e), A.r = bt.r, A.g = bt.g, A.b = bt.b, A
            }

            getStyle(A = cA) {
                YA.fromWorkingColorSpace(bt.copy(this), A);
                const e = bt.r, t = bt.g, n = bt.b;
                return A !== cA ? `color(${A} ${e.toFixed(3)} ${t.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(255 * e)},${Math.round(255 * t)},${Math.round(255 * n)})`
            }

            offsetHSL(A, e, t) {
                return this.getHSL(xt), this.setHSL(xt.h + A, xt.s + e, xt.l + t)
            }

            add(A) {
                return this.r += A.r, this.g += A.g, this.b += A.b, this
            }

            addColors(A, e) {
                return this.r = A.r + e.r, this.g = A.g + e.g, this.b = A.b + e.b, this
            }

            addScalar(A) {
                return this.r += A, this.g += A, this.b += A, this
            }

            sub(A) {
                return this.r = Math.max(0, this.r - A.r), this.g = Math.max(0, this.g - A.g), this.b = Math.max(0, this.b - A.b), this
            }

            multiply(A) {
                return this.r *= A.r, this.g *= A.g, this.b *= A.b, this
            }

            multiplyScalar(A) {
                return this.r *= A, this.g *= A, this.b *= A, this
            }

            lerp(A, e) {
                return this.r += (A.r - this.r) * e, this.g += (A.g - this.g) * e, this.b += (A.b - this.b) * e, this
            }

            lerpColors(A, e, t) {
                return this.r = A.r + (e.r - A.r) * t, this.g = A.g + (e.g - A.g) * t, this.b = A.b + (e.b - A.b) * t, this
            }

            lerpHSL(A, e) {
                this.getHSL(xt), A.getHSL(Mt);
                const t = QA(xt.h, Mt.h, e), n = QA(xt.s, Mt.s, e), r = QA(xt.l, Mt.l, e);
                return this.setHSL(t, n, r), this
            }

            setFromVector3(A) {
                return this.r = A.x, this.g = A.y, this.b = A.z, this
            }

            applyMatrix3(A) {
                const e = this.r, t = this.g, n = this.b, r = A.elements;
                return this.r = r[0] * e + r[3] * t + r[6] * n, this.g = r[1] * e + r[4] * t + r[7] * n, this.b = r[2] * e + r[5] * t + r[8] * n, this
            }

            equals(A) {
                return A.r === this.r && A.g === this.g && A.b === this.b
            }

            fromArray(A, e = 0) {
                return this.r = A[e], this.g = A[e + 1], this.b = A[e + 2], this
            }

            toArray(A = [], e = 0) {
                return A[e] = this.r, A[e + 1] = this.g, A[e + 2] = this.b, A
            }

            fromBufferAttribute(A, e) {
                return this.r = A.getX(e), this.g = A.getY(e), this.b = A.getZ(e), this
            }

            toJSON() {
                return this.getHex()
            }

            * [Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }

        const bt = new St;
        St.NAMES = yt;
        let Qt = 0;

        class Tt extends EA {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {value: Qt++}), this.uuid = FA(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = E, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new St(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = BA, this.stencilZFail = BA, this.stencilZPass = BA, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }

            get alphaTest() {
                return this._alphaTest
            }

            set alphaTest(A) {
                this._alphaTest > 0 != A > 0 && this.version++, this._alphaTest = A
            }

            onBuild() {
            }

            onBeforeRender() {
            }

            onBeforeCompile() {
            }

            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }

            setValues(A) {
                if (void 0 !== A) for (const e in A) {
                    const t = A[e];
                    if (void 0 === t) {
                        console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                        continue
                    }
                    const n = this[e];
                    void 0 !== n ? n && n.isColor ? n.set(t) : n && n.isVector3 && t && t.isVector3 ? n.copy(t) : this[e] = t : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                }
            }

            toJSON(A) {
                const e = void 0 === A || "string" == typeof A;
                e && (A = {textures: {}, images: {}});
                const t = {metadata: {version: 4.6, type: "Material", generator: "Material.toJSON"}};

                function n(A) {
                    const e = [];
                    for (const t in A) {
                        const n = A[t];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }

                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), this.color && this.color.isColor && (t.color = this.color.getHex()), void 0 !== this.roughness && (t.roughness = this.roughness), void 0 !== this.metalness && (t.metalness = this.metalness), void 0 !== this.sheen && (t.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (t.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (t.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (t.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (t.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (t.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (t.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (t.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (t.shininess = this.shininess), void 0 !== this.clearcoat && (t.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (t.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (t.clearcoatMap = this.clearcoatMap.toJSON(A).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (t.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(A).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (t.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(A).uuid, t.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (t.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (t.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (t.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (t.iridescenceMap = this.iridescenceMap.toJSON(A).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (t.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(A).uuid), void 0 !== this.anisotropy && (t.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (t.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (t.anisotropyMap = this.anisotropyMap.toJSON(A).uuid), this.map && this.map.isTexture && (t.map = this.map.toJSON(A).uuid), this.matcap && this.matcap.isTexture && (t.matcap = this.matcap.toJSON(A).uuid), this.alphaMap && this.alphaMap.isTexture && (t.alphaMap = this.alphaMap.toJSON(A).uuid), this.lightMap && this.lightMap.isTexture && (t.lightMap = this.lightMap.toJSON(A).uuid, t.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (t.aoMap = this.aoMap.toJSON(A).uuid, t.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (t.bumpMap = this.bumpMap.toJSON(A).uuid, t.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (t.normalMap = this.normalMap.toJSON(A).uuid, t.normalMapType = this.normalMapType, t.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (t.displacementMap = this.displacementMap.toJSON(A).uuid, t.displacementScale = this.displacementScale, t.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (t.roughnessMap = this.roughnessMap.toJSON(A).uuid), this.metalnessMap && this.metalnessMap.isTexture && (t.metalnessMap = this.metalnessMap.toJSON(A).uuid), this.emissiveMap && this.emissiveMap.isTexture && (t.emissiveMap = this.emissiveMap.toJSON(A).uuid), this.specularMap && this.specularMap.isTexture && (t.specularMap = this.specularMap.toJSON(A).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (t.specularIntensityMap = this.specularIntensityMap.toJSON(A).uuid), this.specularColorMap && this.specularColorMap.isTexture && (t.specularColorMap = this.specularColorMap.toJSON(A).uuid), this.envMap && this.envMap.isTexture && (t.envMap = this.envMap.toJSON(A).uuid, void 0 !== this.combine && (t.combine = this.combine)), void 0 !== this.envMapRotation && (t.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (t.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (t.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (t.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (t.gradientMap = this.gradientMap.toJSON(A).uuid), void 0 !== this.transmission && (t.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (t.transmissionMap = this.transmissionMap.toJSON(A).uuid), void 0 !== this.thickness && (t.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (t.thicknessMap = this.thicknessMap.toJSON(A).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (t.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (t.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (t.size = this.size), null !== this.shadowSide && (t.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (t.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (t.blending = this.blending), 0 !== this.side && (t.side = this.side), !0 === this.vertexColors && (t.vertexColors = !0), this.opacity < 1 && (t.opacity = this.opacity), !0 === this.transparent && (t.transparent = !0), 204 !== this.blendSrc && (t.blendSrc = this.blendSrc), 205 !== this.blendDst && (t.blendDst = this.blendDst), this.blendEquation !== E && (t.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (t.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (t.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (t.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (t.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (t.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (t.depthFunc = this.depthFunc), !1 === this.depthTest && (t.depthTest = this.depthTest), !1 === this.depthWrite && (t.depthWrite = this.depthWrite), !1 === this.colorWrite && (t.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (t.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (t.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (t.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (t.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== BA && (t.stencilFail = this.stencilFail), this.stencilZFail !== BA && (t.stencilZFail = this.stencilZFail), this.stencilZPass !== BA && (t.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (t.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (t.rotation = this.rotation), !0 === this.polygonOffset && (t.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (t.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (t.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (t.linewidth = this.linewidth), void 0 !== this.dashSize && (t.dashSize = this.dashSize), void 0 !== this.gapSize && (t.gapSize = this.gapSize), void 0 !== this.scale && (t.scale = this.scale), !0 === this.dithering && (t.dithering = !0), this.alphaTest > 0 && (t.alphaTest = this.alphaTest), !0 === this.alphaHash && (t.alphaHash = !0), !0 === this.alphaToCoverage && (t.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (t.premultipliedAlpha = !0), !0 === this.forceSinglePass && (t.forceSinglePass = !0), !0 === this.wireframe && (t.wireframe = !0), this.wireframeLinewidth > 1 && (t.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (t.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (t.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (t.flatShading = !0),!1 === this.visible && (t.visible = !1),!1 === this.toneMapped && (t.toneMapped = !1),!1 === this.fog && (t.fog = !1),Object.keys(this.userData).length > 0 && (t.userData = this.userData),e) {
                    const e = n(A.textures), r = n(A.images);
                    e.length > 0 && (t.textures = e), r.length > 0 && (t.images = r)
                }
                return t
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(A) {
                this.name = A.name, this.blending = A.blending, this.side = A.side, this.vertexColors = A.vertexColors, this.opacity = A.opacity, this.transparent = A.transparent, this.blendSrc = A.blendSrc, this.blendDst = A.blendDst, this.blendEquation = A.blendEquation, this.blendSrcAlpha = A.blendSrcAlpha, this.blendDstAlpha = A.blendDstAlpha, this.blendEquationAlpha = A.blendEquationAlpha, this.blendColor.copy(A.blendColor), this.blendAlpha = A.blendAlpha, this.depthFunc = A.depthFunc, this.depthTest = A.depthTest, this.depthWrite = A.depthWrite, this.stencilWriteMask = A.stencilWriteMask, this.stencilFunc = A.stencilFunc, this.stencilRef = A.stencilRef, this.stencilFuncMask = A.stencilFuncMask, this.stencilFail = A.stencilFail, this.stencilZFail = A.stencilZFail, this.stencilZPass = A.stencilZPass, this.stencilWrite = A.stencilWrite;
                const e = A.clippingPlanes;
                let t = null;
                if (null !== e) {
                    const A = e.length;
                    t = new Array(A);
                    for (let n = 0; n !== A; ++n) t[n] = e[n].clone()
                }
                return this.clippingPlanes = t, this.clipIntersection = A.clipIntersection, this.clipShadows = A.clipShadows, this.shadowSide = A.shadowSide, this.colorWrite = A.colorWrite, this.precision = A.precision, this.polygonOffset = A.polygonOffset, this.polygonOffsetFactor = A.polygonOffsetFactor, this.polygonOffsetUnits = A.polygonOffsetUnits, this.dithering = A.dithering, this.alphaTest = A.alphaTest, this.alphaHash = A.alphaHash, this.alphaToCoverage = A.alphaToCoverage, this.premultipliedAlpha = A.premultipliedAlpha, this.forceSinglePass = A.forceSinglePass, this.visible = A.visible, this.toneMapped = A.toneMapped, this.userData = JSON.parse(JSON.stringify(A.userData)), this
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }

            set needsUpdate(A) {
                !0 === A && this.version++
            }
        }

        class It extends Tt {
            constructor(A) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new St(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new je, this.combine = U, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(A)
            }

            copy(A) {
                return super.copy(A), this.color.copy(A.color), this.map = A.map, this.lightMap = A.lightMap, this.lightMapIntensity = A.lightMapIntensity, this.aoMap = A.aoMap, this.aoMapIntensity = A.aoMapIntensity, this.specularMap = A.specularMap, this.alphaMap = A.alphaMap, this.envMap = A.envMap, this.envMapRotation.copy(A.envMapRotation), this.combine = A.combine, this.reflectivity = A.reflectivity, this.refractionRatio = A.refractionRatio, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.wireframeLinecap = A.wireframeLinecap, this.wireframeLinejoin = A.wireframeLinejoin, this.fog = A.fog, this
            }
        }

        const Lt = new ce, Rt = new DA;

        class Ht {
            constructor(A, e, t = !1) {
                if (Array.isArray(A)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = A, this.itemSize = e, this.count = void 0 !== A ? A.length / e : 0, this.normalized = t, this.usage = 35044, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.gpuType = J, this.version = 0
            }

            onUploadCallback() {
            }

            set needsUpdate(A) {
                !0 === A && this.version++
            }

            get updateRange() {
                return (A = "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.") in KA || (KA[A] = !0, console.warn(A)), this._updateRange;
                var A
            }

            setUsage(A) {
                return this.usage = A, this
            }

            addUpdateRange(A, e) {
                this.updateRanges.push({start: A, count: e})
            }

            clearUpdateRanges() {
                this.updateRanges.length = 0
            }

            copy(A) {
                return this.name = A.name, this.array = new A.array.constructor(A.array), this.itemSize = A.itemSize, this.count = A.count, this.normalized = A.normalized, this.usage = A.usage, this.gpuType = A.gpuType, this
            }

            copyAt(A, e, t) {
                A *= this.itemSize, t *= e.itemSize;
                for (let n = 0, r = this.itemSize; n < r; n++) this.array[A + n] = e.array[t + n];
                return this
            }

            copyArray(A) {
                return this.array.set(A), this
            }

            applyMatrix3(A) {
                if (2 === this.itemSize) for (let e = 0, t = this.count; e < t; e++) Rt.fromBufferAttribute(this, e), Rt.applyMatrix3(A), this.setXY(e, Rt.x, Rt.y); else if (3 === this.itemSize) for (let e = 0, t = this.count; e < t; e++) Lt.fromBufferAttribute(this, e), Lt.applyMatrix3(A), this.setXYZ(e, Lt.x, Lt.y, Lt.z);
                return this
            }

            applyMatrix4(A) {
                for (let e = 0, t = this.count; e < t; e++) Lt.fromBufferAttribute(this, e), Lt.applyMatrix4(A), this.setXYZ(e, Lt.x, Lt.y, Lt.z);
                return this
            }

            applyNormalMatrix(A) {
                for (let e = 0, t = this.count; e < t; e++) Lt.fromBufferAttribute(this, e), Lt.applyNormalMatrix(A), this.setXYZ(e, Lt.x, Lt.y, Lt.z);
                return this
            }

            transformDirection(A) {
                for (let e = 0, t = this.count; e < t; e++) Lt.fromBufferAttribute(this, e), Lt.transformDirection(A), this.setXYZ(e, Lt.x, Lt.y, Lt.z);
                return this
            }

            set(A, e = 0) {
                return this.array.set(A, e), this
            }

            getComponent(A, e) {
                let t = this.array[A * this.itemSize + e];
                return this.normalized && (t = LA(t, this.array)), t
            }

            setComponent(A, e, t) {
                return this.normalized && (t = RA(t, this.array)), this.array[A * this.itemSize + e] = t, this
            }

            getX(A) {
                let e = this.array[A * this.itemSize];
                return this.normalized && (e = LA(e, this.array)), e
            }

            setX(A, e) {
                return this.normalized && (e = RA(e, this.array)), this.array[A * this.itemSize] = e, this
            }

            getY(A) {
                let e = this.array[A * this.itemSize + 1];
                return this.normalized && (e = LA(e, this.array)), e
            }

            setY(A, e) {
                return this.normalized && (e = RA(e, this.array)), this.array[A * this.itemSize + 1] = e, this
            }

            getZ(A) {
                let e = this.array[A * this.itemSize + 2];
                return this.normalized && (e = LA(e, this.array)), e
            }

            setZ(A, e) {
                return this.normalized && (e = RA(e, this.array)), this.array[A * this.itemSize + 2] = e, this
            }

            getW(A) {
                let e = this.array[A * this.itemSize + 3];
                return this.normalized && (e = LA(e, this.array)), e
            }

            setW(A, e) {
                return this.normalized && (e = RA(e, this.array)), this.array[A * this.itemSize + 3] = e, this
            }

            setXY(A, e, t) {
                return A *= this.itemSize, this.normalized && (e = RA(e, this.array), t = RA(t, this.array)), this.array[A + 0] = e, this.array[A + 1] = t, this
            }

            setXYZ(A, e, t, n) {
                return A *= this.itemSize, this.normalized && (e = RA(e, this.array), t = RA(t, this.array), n = RA(n, this.array)), this.array[A + 0] = e, this.array[A + 1] = t, this.array[A + 2] = n, this
            }

            setXYZW(A, e, t, n, r) {
                return A *= this.itemSize, this.normalized && (e = RA(e, this.array), t = RA(t, this.array), n = RA(n, this.array), r = RA(r, this.array)), this.array[A + 0] = e, this.array[A + 1] = t, this.array[A + 2] = n, this.array[A + 3] = r, this
            }

            onUpload(A) {
                return this.onUploadCallback = A, this
            }

            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }

            toJSON() {
                const A = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (A.name = this.name), 35044 !== this.usage && (A.usage = this.usage), A
            }
        }

        class Dt extends Ht {
            constructor(A, e, t) {
                super(new Uint16Array(A), e, t)
            }
        }

        class Pt extends Ht {
            constructor(A, e, t) {
                super(new Uint32Array(A), e, t)
            }
        }

        class Nt extends Ht {
            constructor(A, e, t) {
                super(new Float32Array(A), e, t)
            }
        }

        let Ot = 0;
        const Gt = new Oe, Vt = new dt, Kt = new ce, kt = new de, zt = new de, Wt = new ce;

        class Xt extends EA {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {value: Ot++}), this.uuid = FA(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            getIndex() {
                return this.index
            }

            setIndex(A) {
                return Array.isArray(A) ? this.index = new (OA(A) ? Pt : Dt)(A, 1) : this.index = A, this
            }

            getAttribute(A) {
                return this.attributes[A]
            }

            setAttribute(A, e) {
                return this.attributes[A] = e, this
            }

            deleteAttribute(A) {
                return delete this.attributes[A], this
            }

            hasAttribute(A) {
                return void 0 !== this.attributes[A]
            }

            addGroup(A, e, t = 0) {
                this.groups.push({start: A, count: e, materialIndex: t})
            }

            clearGroups() {
                this.groups = []
            }

            setDrawRange(A, e) {
                this.drawRange.start = A, this.drawRange.count = e
            }

            applyMatrix4(A) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(A), e.needsUpdate = !0);
                const t = this.attributes.normal;
                if (void 0 !== t) {
                    const e = (new PA).getNormalMatrix(A);
                    t.applyNormalMatrix(e), t.needsUpdate = !0
                }
                const n = this.attributes.tangent;
                return void 0 !== n && (n.transformDirection(A), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }

            applyQuaternion(A) {
                return Gt.makeRotationFromQuaternion(A), this.applyMatrix4(Gt), this
            }

            rotateX(A) {
                return Gt.makeRotationX(A), this.applyMatrix4(Gt), this
            }

            rotateY(A) {
                return Gt.makeRotationY(A), this.applyMatrix4(Gt), this
            }

            rotateZ(A) {
                return Gt.makeRotationZ(A), this.applyMatrix4(Gt), this
            }

            translate(A, e, t) {
                return Gt.makeTranslation(A, e, t), this.applyMatrix4(Gt), this
            }

            scale(A, e, t) {
                return Gt.makeScale(A, e, t), this.applyMatrix4(Gt), this
            }

            lookAt(A) {
                return Vt.lookAt(A), Vt.updateMatrix(), this.applyMatrix4(Vt.matrix), this
            }

            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Kt).negate(), this.translate(Kt.x, Kt.y, Kt.z), this
            }

            setFromPoints(A) {
                const e = [];
                for (let t = 0, n = A.length; t < n; t++) {
                    const n = A[t];
                    e.push(n.x, n.y, n.z || 0)
                }
                return this.setAttribute("position", new Nt(e, 3)), this
            }

            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new de);
                const A = this.attributes.position, e = this.morphAttributes.position;
                if (A && A.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new ce(-1 / 0, -1 / 0, -1 / 0), new ce(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== A) {
                    if (this.boundingBox.setFromBufferAttribute(A), e) for (let A = 0, t = e.length; A < t; A++) {
                        const t = e[A];
                        kt.setFromBufferAttribute(t), this.morphTargetsRelative ? (Wt.addVectors(this.boundingBox.min, kt.min), this.boundingBox.expandByPoint(Wt), Wt.addVectors(this.boundingBox.max, kt.max), this.boundingBox.expandByPoint(Wt)) : (this.boundingBox.expandByPoint(kt.min), this.boundingBox.expandByPoint(kt.max))
                    }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }

            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Qe);
                const A = this.attributes.position, e = this.morphAttributes.position;
                if (A && A.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new ce, 1 / 0);
                if (A) {
                    const t = this.boundingSphere.center;
                    if (kt.setFromBufferAttribute(A), e) for (let A = 0, t = e.length; A < t; A++) {
                        const t = e[A];
                        zt.setFromBufferAttribute(t), this.morphTargetsRelative ? (Wt.addVectors(kt.min, zt.min), kt.expandByPoint(Wt), Wt.addVectors(kt.max, zt.max), kt.expandByPoint(Wt)) : (kt.expandByPoint(zt.min), kt.expandByPoint(zt.max))
                    }
                    kt.getCenter(t);
                    let n = 0;
                    for (let e = 0, r = A.count; e < r; e++) Wt.fromBufferAttribute(A, e), n = Math.max(n, t.distanceToSquared(Wt));
                    if (e) for (let r = 0, i = e.length; r < i; r++) {
                        const i = e[r], a = this.morphTargetsRelative;
                        for (let e = 0, r = i.count; e < r; e++) Wt.fromBufferAttribute(i, e), a && (Kt.fromBufferAttribute(A, e), Wt.add(Kt)), n = Math.max(n, t.distanceToSquared(Wt))
                    }
                    this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }

            computeTangents() {
                const A = this.index, e = this.attributes;
                if (null === A || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const t = e.position, n = e.normal, r = e.uv;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ht(new Float32Array(4 * t.count), 4));
                const i = this.getAttribute("tangent"), a = [], s = [];
                for (let A = 0; A < t.count; A++) a[A] = new ce, s[A] = new ce;
                const o = new ce, l = new ce, c = new ce, u = new DA, h = new DA, d = new DA, p = new ce, f = new ce;

                function g(A, e, n) {
                    o.fromBufferAttribute(t, A), l.fromBufferAttribute(t, e), c.fromBufferAttribute(t, n), u.fromBufferAttribute(r, A), h.fromBufferAttribute(r, e), d.fromBufferAttribute(r, n), l.sub(o), c.sub(o), h.sub(u), d.sub(u);
                    const i = 1 / (h.x * d.y - d.x * h.y);
                    isFinite(i) && (p.copy(l).multiplyScalar(d.y).addScaledVector(c, -h.y).multiplyScalar(i), f.copy(c).multiplyScalar(h.x).addScaledVector(l, -d.x).multiplyScalar(i), a[A].add(p), a[e].add(p), a[n].add(p), s[A].add(f), s[e].add(f), s[n].add(f))
                }

                let m = this.groups;
                0 === m.length && (m = [{start: 0, count: A.count}]);
                for (let e = 0, t = m.length; e < t; ++e) {
                    const t = m[e], n = t.start;
                    for (let e = n, r = n + t.count; e < r; e += 3) g(A.getX(e + 0), A.getX(e + 1), A.getX(e + 2))
                }
                const B = new ce, w = new ce, v = new ce, _ = new ce;

                function C(A) {
                    v.fromBufferAttribute(n, A), _.copy(v);
                    const e = a[A];
                    B.copy(e), B.sub(v.multiplyScalar(v.dot(e))).normalize(), w.crossVectors(_, e);
                    const t = w.dot(s[A]) < 0 ? -1 : 1;
                    i.setXYZW(A, B.x, B.y, B.z, t)
                }

                for (let e = 0, t = m.length; e < t; ++e) {
                    const t = m[e], n = t.start;
                    for (let e = n, r = n + t.count; e < r; e += 3) C(A.getX(e + 0)), C(A.getX(e + 1)), C(A.getX(e + 2))
                }
            }

            computeVertexNormals() {
                const A = this.index, e = this.getAttribute("position");
                if (void 0 !== e) {
                    let t = this.getAttribute("normal");
                    if (void 0 === t) t = new Ht(new Float32Array(3 * e.count), 3), this.setAttribute("normal", t); else for (let A = 0, e = t.count; A < e; A++) t.setXYZ(A, 0, 0, 0);
                    const n = new ce, r = new ce, i = new ce, a = new ce, s = new ce, o = new ce, l = new ce,
                        c = new ce;
                    if (A) for (let u = 0, h = A.count; u < h; u += 3) {
                        const h = A.getX(u + 0), d = A.getX(u + 1), p = A.getX(u + 2);
                        n.fromBufferAttribute(e, h), r.fromBufferAttribute(e, d), i.fromBufferAttribute(e, p), l.subVectors(i, r), c.subVectors(n, r), l.cross(c), a.fromBufferAttribute(t, h), s.fromBufferAttribute(t, d), o.fromBufferAttribute(t, p), a.add(l), s.add(l), o.add(l), t.setXYZ(h, a.x, a.y, a.z), t.setXYZ(d, s.x, s.y, s.z), t.setXYZ(p, o.x, o.y, o.z)
                    } else for (let A = 0, a = e.count; A < a; A += 3) n.fromBufferAttribute(e, A + 0), r.fromBufferAttribute(e, A + 1), i.fromBufferAttribute(e, A + 2), l.subVectors(i, r), c.subVectors(n, r), l.cross(c), t.setXYZ(A + 0, l.x, l.y, l.z), t.setXYZ(A + 1, l.x, l.y, l.z), t.setXYZ(A + 2, l.x, l.y, l.z);
                    this.normalizeNormals(), t.needsUpdate = !0
                }
            }

            normalizeNormals() {
                const A = this.attributes.normal;
                for (let e = 0, t = A.count; e < t; e++) Wt.fromBufferAttribute(A, e), Wt.normalize(), A.setXYZ(e, Wt.x, Wt.y, Wt.z)
            }

            toNonIndexed() {
                function A(A, e) {
                    const t = A.array, n = A.itemSize, r = A.normalized, i = new t.constructor(e.length * n);
                    let a = 0, s = 0;
                    for (let r = 0, o = e.length; r < o; r++) {
                        a = A.isInterleavedBufferAttribute ? e[r] * A.data.stride + A.offset : e[r] * n;
                        for (let A = 0; A < n; A++) i[s++] = t[a++]
                    }
                    return new Ht(i, n, r)
                }

                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new Xt, t = this.index.array, n = this.attributes;
                for (const r in n) {
                    const i = A(n[r], t);
                    e.setAttribute(r, i)
                }
                const r = this.morphAttributes;
                for (const n in r) {
                    const i = [], a = r[n];
                    for (let e = 0, n = a.length; e < n; e++) {
                        const n = A(a[e], t);
                        i.push(n)
                    }
                    e.morphAttributes[n] = i
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const i = this.groups;
                for (let A = 0, t = i.length; A < t; A++) {
                    const t = i[A];
                    e.addGroup(t.start, t.count, t.materialIndex)
                }
                return e
            }

            toJSON() {
                const A = {metadata: {version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
                if (A.uuid = this.uuid, A.type = this.type, "" !== this.name && (A.name = this.name), Object.keys(this.userData).length > 0 && (A.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const t in e) void 0 !== e[t] && (A[t] = e[t]);
                    return A
                }
                A.data = {attributes: {}};
                const e = this.index;
                null !== e && (A.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const t = this.attributes;
                for (const e in t) {
                    const n = t[e];
                    A.data.attributes[e] = n.toJSON(A.data)
                }
                const n = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const t = this.morphAttributes[e], i = [];
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        i.push(n.toJSON(A.data))
                    }
                    i.length > 0 && (n[e] = i, r = !0)
                }
                r && (A.data.morphAttributes = n, A.data.morphTargetsRelative = this.morphTargetsRelative);
                const i = this.groups;
                i.length > 0 && (A.data.groups = JSON.parse(JSON.stringify(i)));
                const a = this.boundingSphere;
                return null !== a && (A.data.boundingSphere = {center: a.center.toArray(), radius: a.radius}), A
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(A) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = A.name;
                const t = A.index;
                null !== t && this.setIndex(t.clone(e));
                const n = A.attributes;
                for (const A in n) {
                    const t = n[A];
                    this.setAttribute(A, t.clone(e))
                }
                const r = A.morphAttributes;
                for (const A in r) {
                    const t = [], n = r[A];
                    for (let A = 0, r = n.length; A < r; A++) t.push(n[A].clone(e));
                    this.morphAttributes[A] = t
                }
                this.morphTargetsRelative = A.morphTargetsRelative;
                const i = A.groups;
                for (let A = 0, e = i.length; A < e; A++) {
                    const e = i[A];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const a = A.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const s = A.boundingSphere;
                return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = A.drawRange.start, this.drawRange.count = A.drawRange.count, this.userData = A.userData, this
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }
        }

        const Yt = new Oe, Jt = new Ne, jt = new Qe, Zt = new ce, qt = new ce, $t = new ce, An = new ce, en = new ce,
            tn = new ce, nn = new DA, rn = new DA, an = new DA, sn = new ce, on = new ce, ln = new ce, cn = new ce,
            un = new ce;

        class hn extends dt {
            constructor(A = new Xt, e = new It) {
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = A, this.material = e, this.updateMorphTargets()
            }

            copy(A, e) {
                return super.copy(A, e), void 0 !== A.morphTargetInfluences && (this.morphTargetInfluences = A.morphTargetInfluences.slice()), void 0 !== A.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, A.morphTargetDictionary)), this.material = Array.isArray(A.material) ? A.material.slice() : A.material, this.geometry = A.geometry, this
            }

            updateMorphTargets() {
                const A = this.geometry.morphAttributes, e = Object.keys(A);
                if (e.length > 0) {
                    const t = A[e[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let A = 0, e = t.length; A < e; A++) {
                            const e = t[A].name || String(A);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = A
                        }
                    }
                }
            }

            getVertexPosition(A, e) {
                const t = this.geometry, n = t.attributes.position, r = t.morphAttributes.position,
                    i = t.morphTargetsRelative;
                e.fromBufferAttribute(n, A);
                const a = this.morphTargetInfluences;
                if (r && a) {
                    tn.set(0, 0, 0);
                    for (let t = 0, n = r.length; t < n; t++) {
                        const n = a[t], s = r[t];
                        0 !== n && (en.fromBufferAttribute(s, A), i ? tn.addScaledVector(en, n) : tn.addScaledVector(en.sub(e), n))
                    }
                    e.add(tn)
                }
                return e
            }

            raycast(A, e) {
                const t = this.geometry, n = this.material, r = this.matrixWorld;
                if (void 0 !== n) {
                    if (null === t.boundingSphere && t.computeBoundingSphere(), jt.copy(t.boundingSphere), jt.applyMatrix4(r), Jt.copy(A.ray).recast(A.near), !1 === jt.containsPoint(Jt.origin)) {
                        if (null === Jt.intersectSphere(jt, Zt)) return;
                        if (Jt.origin.distanceToSquared(Zt) > (A.far - A.near) ** 2) return
                    }
                    Yt.copy(r).invert(), Jt.copy(A.ray).applyMatrix4(Yt), null !== t.boundingBox && !1 === Jt.intersectsBox(t.boundingBox) || this._computeIntersections(A, e, Jt)
                }
            }

            _computeIntersections(A, e, t) {
                let n;
                const r = this.geometry, i = this.material, a = r.index, s = r.attributes.position, o = r.attributes.uv,
                    l = r.attributes.uv1, c = r.attributes.normal, u = r.groups, h = r.drawRange;
                if (null !== a) if (Array.isArray(i)) for (let r = 0, s = u.length; r < s; r++) {
                    const s = u[r], d = i[s.materialIndex];
                    for (let r = Math.max(s.start, h.start), i = Math.min(a.count, Math.min(s.start + s.count, h.start + h.count)); r < i; r += 3) n = dn(this, d, A, t, o, l, c, a.getX(r), a.getX(r + 1), a.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = s.materialIndex, e.push(n))
                } else for (let r = Math.max(0, h.start), s = Math.min(a.count, h.start + h.count); r < s; r += 3) n = dn(this, i, A, t, o, l, c, a.getX(r), a.getX(r + 1), a.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), e.push(n)); else if (void 0 !== s) if (Array.isArray(i)) for (let r = 0, a = u.length; r < a; r++) {
                    const a = u[r], d = i[a.materialIndex];
                    for (let r = Math.max(a.start, h.start), i = Math.min(s.count, Math.min(a.start + a.count, h.start + h.count)); r < i; r += 3) n = dn(this, d, A, t, o, l, c, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = a.materialIndex, e.push(n))
                } else for (let r = Math.max(0, h.start), a = Math.min(s.count, h.start + h.count); r < a; r += 3) n = dn(this, i, A, t, o, l, c, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), e.push(n))
            }
        }

        function dn(A, e, t, n, r, i, a, s, o, l) {
            A.getVertexPosition(s, qt), A.getVertexPosition(o, $t), A.getVertexPosition(l, An);
            const c = function (A, e, t, n, r, i, a, s) {
                let o;
                if (o = 1 === e.side ? n.intersectTriangle(a, i, r, !0, s) : n.intersectTriangle(r, i, a, 0 === e.side, s), null === o) return null;
                un.copy(s), un.applyMatrix4(A.matrixWorld);
                const l = t.ray.origin.distanceTo(un);
                return l < t.near || l > t.far ? null : {distance: l, point: un.clone(), object: A}
            }(A, e, t, n, qt, $t, An, cn);
            if (c) {
                r && (nn.fromBufferAttribute(r, s), rn.fromBufferAttribute(r, o), an.fromBufferAttribute(r, l), c.uv = Ut.getInterpolation(cn, qt, $t, An, nn, rn, an, new DA)), i && (nn.fromBufferAttribute(i, s), rn.fromBufferAttribute(i, o), an.fromBufferAttribute(i, l), c.uv1 = Ut.getInterpolation(cn, qt, $t, An, nn, rn, an, new DA)), a && (sn.fromBufferAttribute(a, s), on.fromBufferAttribute(a, o), ln.fromBufferAttribute(a, l), c.normal = Ut.getInterpolation(cn, qt, $t, An, sn, on, ln, new ce), c.normal.dot(n.direction) > 0 && c.normal.multiplyScalar(-1));
                const A = {a: s, b: o, c: l, normal: new ce, materialIndex: 0};
                Ut.getNormal(qt, $t, An, A.normal), c.face = A
            }
            return c
        }

        class pn extends Xt {
            constructor(A = 1, e = 1, t = 1, n = 1, r = 1, i = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: A,
                    height: e,
                    depth: t,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: i
                };
                const a = this;
                n = Math.floor(n), r = Math.floor(r), i = Math.floor(i);
                const s = [], o = [], l = [], c = [];
                let u = 0, h = 0;

                function d(A, e, t, n, r, i, d, p, f, g, m) {
                    const B = i / f, w = d / g, v = i / 2, _ = d / 2, C = p / 2, E = f + 1, U = g + 1;
                    let y = 0, x = 0;
                    const M = new ce;
                    for (let i = 0; i < U; i++) {
                        const a = i * w - _;
                        for (let s = 0; s < E; s++) {
                            const u = s * B - v;
                            M[A] = u * n, M[e] = a * r, M[t] = C, o.push(M.x, M.y, M.z), M[A] = 0, M[e] = 0, M[t] = p > 0 ? 1 : -1, l.push(M.x, M.y, M.z), c.push(s / f), c.push(1 - i / g), y += 1
                        }
                    }
                    for (let A = 0; A < g; A++) for (let e = 0; e < f; e++) {
                        const t = u + e + E * A, n = u + e + E * (A + 1), r = u + (e + 1) + E * (A + 1),
                            i = u + (e + 1) + E * A;
                        s.push(t, n, i), s.push(n, r, i), x += 6
                    }
                    a.addGroup(h, x, m), h += x, u += y
                }

                d("z", "y", "x", -1, -1, t, e, A, i, r, 0), d("z", "y", "x", 1, -1, t, e, -A, i, r, 1), d("x", "z", "y", 1, 1, A, t, e, n, i, 2), d("x", "z", "y", 1, -1, A, t, -e, n, i, 3), d("x", "y", "z", 1, -1, A, e, t, n, r, 4), d("x", "y", "z", -1, -1, A, e, -t, n, r, 5), this.setIndex(s), this.setAttribute("position", new Nt(o, 3)), this.setAttribute("normal", new Nt(l, 3)), this.setAttribute("uv", new Nt(c, 2))
            }

            copy(A) {
                return super.copy(A), this.parameters = Object.assign({}, A.parameters), this
            }

            static fromJSON(A) {
                return new pn(A.width, A.height, A.depth, A.widthSegments, A.heightSegments, A.depthSegments)
            }
        }

        function fn(A) {
            const e = {};
            for (const t in A) {
                e[t] = {};
                for (const n in A[t]) {
                    const r = A[t][n];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r
                }
            }
            return e
        }

        function gn(A) {
            const e = {};
            for (let t = 0; t < A.length; t++) {
                const n = fn(A[t]);
                for (const A in n) e[A] = n[A]
            }
            return e
        }

        function mn(A) {
            return null === A.getRenderTarget() ? A.outputColorSpace : YA.workingColorSpace
        }

        const Bn = {clone: fn, merge: gn};

        class wn extends Tt {
            constructor(A) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1,
                    clipCullDistance: !1,
                    multiDraw: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== A && this.setValues(A)
            }

            copy(A) {
                return super.copy(A), this.fragmentShader = A.fragmentShader, this.vertexShader = A.vertexShader, this.uniforms = fn(A.uniforms), this.uniformsGroups = function (A) {
                    const e = [];
                    for (let t = 0; t < A.length; t++) e.push(A[t].clone());
                    return e
                }(A.uniformsGroups), this.defines = Object.assign({}, A.defines), this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this.fog = A.fog, this.lights = A.lights, this.clipping = A.clipping, this.extensions = Object.assign({}, A.extensions), this.glslVersion = A.glslVersion, this
            }

            toJSON(A) {
                const e = super.toJSON(A);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const t in this.uniforms) {
                    const n = this.uniforms[t].value;
                    n && n.isTexture ? e.uniforms[t] = {
                        type: "t",
                        value: n.toJSON(A).uuid
                    } : n && n.isColor ? e.uniforms[t] = {
                        type: "c",
                        value: n.getHex()
                    } : n && n.isVector2 ? e.uniforms[t] = {
                        type: "v2",
                        value: n.toArray()
                    } : n && n.isVector3 ? e.uniforms[t] = {
                        type: "v3",
                        value: n.toArray()
                    } : n && n.isVector4 ? e.uniforms[t] = {
                        type: "v4",
                        value: n.toArray()
                    } : n && n.isMatrix3 ? e.uniforms[t] = {
                        type: "m3",
                        value: n.toArray()
                    } : n && n.isMatrix4 ? e.uniforms[t] = {type: "m4", value: n.toArray()} : e.uniforms[t] = {value: n}
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                const t = {};
                for (const A in this.extensions) !0 === this.extensions[A] && (t[A] = !0);
                return Object.keys(t).length > 0 && (e.extensions = t), e
            }
        }

        class vn extends dt {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Oe, this.projectionMatrix = new Oe, this.projectionMatrixInverse = new Oe, this.coordinateSystem = _A
            }

            copy(A, e) {
                return super.copy(A, e), this.matrixWorldInverse.copy(A.matrixWorldInverse), this.projectionMatrix.copy(A.projectionMatrix), this.projectionMatrixInverse.copy(A.projectionMatrixInverse), this.coordinateSystem = A.coordinateSystem, this
            }

            getWorldDirection(A) {
                return super.getWorldDirection(A).negate()
            }

            updateMatrixWorld(A) {
                super.updateMatrixWorld(A), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }

            updateWorldMatrix(A, e) {
                super.updateWorldMatrix(A, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        const _n = new ce, Cn = new DA, En = new DA;

        class Un extends vn {
            constructor(A = 50, e = 1, t = .1, n = 2e3) {
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = A, this.zoom = 1, this.near = t, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            copy(A, e) {
                return super.copy(A, e), this.fov = A.fov, this.zoom = A.zoom, this.near = A.near, this.far = A.far, this.focus = A.focus, this.aspect = A.aspect, this.view = null === A.view ? null : Object.assign({}, A.view), this.filmGauge = A.filmGauge, this.filmOffset = A.filmOffset, this
            }

            setFocalLength(A) {
                const e = .5 * this.getFilmHeight() / A;
                this.fov = 2 * MA * Math.atan(e), this.updateProjectionMatrix()
            }

            getFocalLength() {
                const A = Math.tan(.5 * xA * this.fov);
                return .5 * this.getFilmHeight() / A
            }

            getEffectiveFOV() {
                return 2 * MA * Math.atan(Math.tan(.5 * xA * this.fov) / this.zoom)
            }

            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }

            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }

            getViewBounds(A, e, t) {
                _n.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set(_n.x, _n.y).multiplyScalar(-A / _n.z), _n.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(_n.x, _n.y).multiplyScalar(-A / _n.z)
            }

            getViewSize(A, e) {
                return this.getViewBounds(A, Cn, En), e.subVectors(En, Cn)
            }

            setViewOffset(A, e, t, n, r, i) {
                this.aspect = A / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = A, this.view.fullHeight = e, this.view.offsetX = t, this.view.offsetY = n, this.view.width = r, this.view.height = i, this.updateProjectionMatrix()
            }

            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }

            updateProjectionMatrix() {
                const A = this.near;
                let e = A * Math.tan(.5 * xA * this.fov) / this.zoom, t = 2 * e, n = this.aspect * t, r = -.5 * n;
                const i = this.view;
                if (null !== this.view && this.view.enabled) {
                    const A = i.fullWidth, a = i.fullHeight;
                    r += i.offsetX * n / A, e -= i.offsetY * t / a, n *= i.width / A, t *= i.height / a
                }
                const a = this.filmOffset;
                0 !== a && (r += A * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - t, A, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }

            toJSON(A) {
                const e = super.toJSON(A);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }

        const yn = -90;

        class xn extends dt {
            constructor(A, e, t) {
                super(), this.type = "CubeCamera", this.renderTarget = t, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                const n = new Un(yn, 1, A, e);
                n.layers = this.layers, this.add(n);
                const r = new Un(yn, 1, A, e);
                r.layers = this.layers, this.add(r);
                const i = new Un(yn, 1, A, e);
                i.layers = this.layers, this.add(i);
                const a = new Un(yn, 1, A, e);
                a.layers = this.layers, this.add(a);
                const s = new Un(yn, 1, A, e);
                s.layers = this.layers, this.add(s);
                const o = new Un(yn, 1, A, e);
                o.layers = this.layers, this.add(o)
            }

            updateCoordinateSystem() {
                const A = this.coordinateSystem, e = this.children.concat(), [t, n, r, i, a, s] = e;
                for (const A of e) this.remove(A);
                if (A === _A) t.up.set(0, 1, 0), t.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), i.up.set(0, 0, 1), i.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), s.up.set(0, 1, 0), s.lookAt(0, 0, -1); else {
                    if (A !== CA) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + A);
                    t.up.set(0, -1, 0), t.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), i.up.set(0, 0, -1), i.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), s.up.set(0, -1, 0), s.lookAt(0, 0, -1)
                }
                for (const A of e) this.add(A), A.updateMatrixWorld()
            }

            update(A, e) {
                null === this.parent && this.updateMatrixWorld();
                const {renderTarget: t, activeMipmapLevel: n} = this;
                this.coordinateSystem !== A.coordinateSystem && (this.coordinateSystem = A.coordinateSystem, this.updateCoordinateSystem());
                const [r, i, a, s, o, l] = this.children, c = A.getRenderTarget(), u = A.getActiveCubeFace(),
                    h = A.getActiveMipmapLevel(), d = A.xr.enabled;
                A.xr.enabled = !1;
                const p = t.texture.generateMipmaps;
                t.texture.generateMipmaps = !1, A.setRenderTarget(t, 0, n), A.render(e, r), A.setRenderTarget(t, 1, n), A.render(e, i), A.setRenderTarget(t, 2, n), A.render(e, a), A.setRenderTarget(t, 3, n), A.render(e, s), A.setRenderTarget(t, 4, n), A.render(e, o), t.texture.generateMipmaps = p, A.setRenderTarget(t, 5, n), A.render(e, l), A.setRenderTarget(c, u, h), A.xr.enabled = d, t.texture.needsPMREMUpdate = !0
            }
        }

        class Mn extends ne {
            constructor(A, e, t, n, r, i, a, s, o, l) {
                super(A = void 0 !== A ? A : [], e = void 0 !== e ? e : R, t, n, r, i, a, s, o, l), this.isCubeTexture = !0, this.flipY = !1
            }

            get images() {
                return this.image
            }

            set images(A) {
                this.image = A
            }
        }

        class Fn extends ae {
            constructor(A = 1, e = {}) {
                super(A, A, e), this.isWebGLCubeRenderTarget = !0;
                const t = {width: A, height: A, depth: 1}, n = [t, t, t, t, t, t];
                this.texture = new Mn(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : K
            }

            fromEquirectangularTexture(A, e) {
                this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const t = {tEquirect: {value: null}},
                    n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                    i = new pn(5, 5, 5), a = new wn({
                        name: "CubemapFromEquirect",
                        uniforms: fn(t),
                        vertexShader: n,
                        fragmentShader: r,
                        side: 1,
                        blending: 0
                    });
                a.uniforms.tEquirect.value = e;
                const s = new hn(i, a), o = e.minFilter;
                return e.minFilter === z && (e.minFilter = K), new xn(1, 10, this).update(A, s), e.minFilter = o, s.geometry.dispose(), s.material.dispose(), this
            }

            clear(A, e, t, n) {
                const r = A.getRenderTarget();
                for (let r = 0; r < 6; r++) A.setRenderTarget(this, r), A.clear(e, t, n);
                A.setRenderTarget(r)
            }
        }

        const Sn = new ce, bn = new ce, Qn = new PA;

        class Tn {
            constructor(A = new ce(1, 0, 0), e = 0) {
                this.isPlane = !0, this.normal = A, this.constant = e
            }

            set(A, e) {
                return this.normal.copy(A), this.constant = e, this
            }

            setComponents(A, e, t, n) {
                return this.normal.set(A, e, t), this.constant = n, this
            }

            setFromNormalAndCoplanarPoint(A, e) {
                return this.normal.copy(A), this.constant = -e.dot(this.normal), this
            }

            setFromCoplanarPoints(A, e, t) {
                const n = Sn.subVectors(t, e).cross(bn.subVectors(A, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(n, A), this
            }

            copy(A) {
                return this.normal.copy(A.normal), this.constant = A.constant, this
            }

            normalize() {
                const A = 1 / this.normal.length();
                return this.normal.multiplyScalar(A), this.constant *= A, this
            }

            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }

            distanceToPoint(A) {
                return this.normal.dot(A) + this.constant
            }

            distanceToSphere(A) {
                return this.distanceToPoint(A.center) - A.radius
            }

            projectPoint(A, e) {
                return e.copy(A).addScaledVector(this.normal, -this.distanceToPoint(A))
            }

            intersectLine(A, e) {
                const t = A.delta(Sn), n = this.normal.dot(t);
                if (0 === n) return 0 === this.distanceToPoint(A.start) ? e.copy(A.start) : null;
                const r = -(A.start.dot(this.normal) + this.constant) / n;
                return r < 0 || r > 1 ? null : e.copy(A.start).addScaledVector(t, r)
            }

            intersectsLine(A) {
                const e = this.distanceToPoint(A.start), t = this.distanceToPoint(A.end);
                return e < 0 && t > 0 || t < 0 && e > 0
            }

            intersectsBox(A) {
                return A.intersectsPlane(this)
            }

            intersectsSphere(A) {
                return A.intersectsPlane(this)
            }

            coplanarPoint(A) {
                return A.copy(this.normal).multiplyScalar(-this.constant)
            }

            applyMatrix4(A, e) {
                const t = e || Qn.getNormalMatrix(A), n = this.coplanarPoint(Sn).applyMatrix4(A),
                    r = this.normal.applyMatrix3(t).normalize();
                return this.constant = -n.dot(r), this
            }

            translate(A) {
                return this.constant -= A.dot(this.normal), this
            }

            equals(A) {
                return A.normal.equals(this.normal) && A.constant === this.constant
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        const In = new Qe, Ln = new ce;

        class Rn {
            constructor(A = new Tn, e = new Tn, t = new Tn, n = new Tn, r = new Tn, i = new Tn) {
                this.planes = [A, e, t, n, r, i]
            }

            set(A, e, t, n, r, i) {
                const a = this.planes;
                return a[0].copy(A), a[1].copy(e), a[2].copy(t), a[3].copy(n), a[4].copy(r), a[5].copy(i), this
            }

            copy(A) {
                const e = this.planes;
                for (let t = 0; t < 6; t++) e[t].copy(A.planes[t]);
                return this
            }

            setFromProjectionMatrix(A, e = 2e3) {
                const t = this.planes, n = A.elements, r = n[0], i = n[1], a = n[2], s = n[3], o = n[4], l = n[5],
                    c = n[6], u = n[7], h = n[8], d = n[9], p = n[10], f = n[11], g = n[12], m = n[13], B = n[14],
                    w = n[15];
                if (t[0].setComponents(s - r, u - o, f - h, w - g).normalize(), t[1].setComponents(s + r, u + o, f + h, w + g).normalize(), t[2].setComponents(s + i, u + l, f + d, w + m).normalize(), t[3].setComponents(s - i, u - l, f - d, w - m).normalize(), t[4].setComponents(s - a, u - c, f - p, w - B).normalize(), e === _A) t[5].setComponents(s + a, u + c, f + p, w + B).normalize(); else {
                    if (e !== CA) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                    t[5].setComponents(a, c, p, B).normalize()
                }
                return this
            }

            intersectsObject(A) {
                if (void 0 !== A.boundingSphere) null === A.boundingSphere && A.computeBoundingSphere(), In.copy(A.boundingSphere).applyMatrix4(A.matrixWorld); else {
                    const e = A.geometry;
                    null === e.boundingSphere && e.computeBoundingSphere(), In.copy(e.boundingSphere).applyMatrix4(A.matrixWorld)
                }
                return this.intersectsSphere(In)
            }

            intersectsSprite(A) {
                return In.center.set(0, 0, 0), In.radius = .7071067811865476, In.applyMatrix4(A.matrixWorld), this.intersectsSphere(In)
            }

            intersectsSphere(A) {
                const e = this.planes, t = A.center, n = -A.radius;
                for (let A = 0; A < 6; A++) if (e[A].distanceToPoint(t) < n) return !1;
                return !0
            }

            intersectsBox(A) {
                const e = this.planes;
                for (let t = 0; t < 6; t++) {
                    const n = e[t];
                    if (Ln.x = n.normal.x > 0 ? A.max.x : A.min.x, Ln.y = n.normal.y > 0 ? A.max.y : A.min.y, Ln.z = n.normal.z > 0 ? A.max.z : A.min.z, n.distanceToPoint(Ln) < 0) return !1
                }
                return !0
            }

            containsPoint(A) {
                const e = this.planes;
                for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(A) < 0) return !1;
                return !0
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function Hn() {
            let A = null, e = !1, t = null, n = null;

            function r(e, i) {
                t(e, i), n = A.requestAnimationFrame(r)
            }

            return {
                start: function () {
                    !0 !== e && null !== t && (n = A.requestAnimationFrame(r), e = !0)
                }, stop: function () {
                    A.cancelAnimationFrame(n), e = !1
                }, setAnimationLoop: function (A) {
                    t = A
                }, setContext: function (e) {
                    A = e
                }
            }
        }

        function Dn(A, e) {
            const t = e.isWebGL2, n = new WeakMap;
            return {
                get: function (A) {
                    return A.isInterleavedBufferAttribute && (A = A.data), n.get(A)
                }, remove: function (e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const t = n.get(e);
                    t && (A.deleteBuffer(t.buffer), n.delete(e))
                }, update: function (e, r) {
                    if (e.isGLBufferAttribute) {
                        const A = n.get(e);
                        return void ((!A || A.version < e.version) && n.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const i = n.get(e);
                    if (void 0 === i) n.set(e, function (e, n) {
                        const r = e.array, i = e.usage, a = r.byteLength, s = A.createBuffer();
                        let o;
                        if (A.bindBuffer(n, s), A.bufferData(n, r, i), e.onUploadCallback(), r instanceof Float32Array) o = A.FLOAT; else if (r instanceof Uint16Array) if (e.isFloat16BufferAttribute) {
                            if (!t) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                            o = A.HALF_FLOAT
                        } else o = A.UNSIGNED_SHORT; else if (r instanceof Int16Array) o = A.SHORT; else if (r instanceof Uint32Array) o = A.UNSIGNED_INT; else if (r instanceof Int32Array) o = A.INT; else if (r instanceof Int8Array) o = A.BYTE; else if (r instanceof Uint8Array) o = A.UNSIGNED_BYTE; else {
                            if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                            o = A.UNSIGNED_BYTE
                        }
                        return {buffer: s, type: o, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version, size: a}
                    }(e, r)); else if (i.version < e.version) {
                        if (i.size !== e.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        !function (e, n, r) {
                            const i = n.array, a = n._updateRange, s = n.updateRanges;
                            if (A.bindBuffer(r, e), -1 === a.count && 0 === s.length && A.bufferSubData(r, 0, i), 0 !== s.length) {
                                for (let e = 0, n = s.length; e < n; e++) {
                                    const n = s[e];
                                    t ? A.bufferSubData(r, n.start * i.BYTES_PER_ELEMENT, i, n.start, n.count) : A.bufferSubData(r, n.start * i.BYTES_PER_ELEMENT, i.subarray(n.start, n.start + n.count))
                                }
                                n.clearUpdateRanges()
                            }
                            -1 !== a.count && (t ? A.bufferSubData(r, a.offset * i.BYTES_PER_ELEMENT, i, a.offset, a.count) : A.bufferSubData(r, a.offset * i.BYTES_PER_ELEMENT, i.subarray(a.offset, a.offset + a.count)), a.count = -1), n.onUploadCallback()
                        }(i.buffer, e, r), i.version = e.version
                    }
                }
            }
        }

        class Pn extends Xt {
            constructor(A = 1, e = 1, t = 1, n = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: A,
                    height: e,
                    widthSegments: t,
                    heightSegments: n
                };
                const r = A / 2, i = e / 2, a = Math.floor(t), s = Math.floor(n), o = a + 1, l = s + 1, c = A / a,
                    u = e / s, h = [], d = [], p = [], f = [];
                for (let A = 0; A < l; A++) {
                    const e = A * u - i;
                    for (let t = 0; t < o; t++) {
                        const n = t * c - r;
                        d.push(n, -e, 0), p.push(0, 0, 1), f.push(t / a), f.push(1 - A / s)
                    }
                }
                for (let A = 0; A < s; A++) for (let e = 0; e < a; e++) {
                    const t = e + o * A, n = e + o * (A + 1), r = e + 1 + o * (A + 1), i = e + 1 + o * A;
                    h.push(t, n, i), h.push(n, r, i)
                }
                this.setIndex(h), this.setAttribute("position", new Nt(d, 3)), this.setAttribute("normal", new Nt(p, 3)), this.setAttribute("uv", new Nt(f, 2))
            }

            copy(A) {
                return super.copy(A), this.parameters = Object.assign({}, A.parameters), this
            }

            static fromJSON(A) {
                return new Pn(A.width, A.height, A.widthSegments, A.heightSegments)
            }
        }

        const Nn = {
            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tfloat startCompression = 0.8 - 0.04;\n\tfloat desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min(color.r, min(color.g, color.b));\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max(color.r, max(color.g, color.b));\n\tif (peak < startCompression) return color;\n\tfloat d = 1. - startCompression;\n\tfloat newPeak = 1. - d * d / (peak + d - startCompression);\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n\treturn mix(color, vec3(1, 1, 1), g);\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
        }, On = {
            common: {
                diffuse: {value: new St(16777215)},
                opacity: {value: 1},
                map: {value: null},
                mapTransform: {value: new PA},
                alphaMap: {value: null},
                alphaMapTransform: {value: new PA},
                alphaTest: {value: 0}
            },
            specularmap: {specularMap: {value: null}, specularMapTransform: {value: new PA}},
            envmap: {
                envMap: {value: null},
                envMapRotation: {value: new PA},
                flipEnvMap: {value: -1},
                reflectivity: {value: 1},
                ior: {value: 1.5},
                refractionRatio: {value: .98}
            },
            aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}, aoMapTransform: {value: new PA}},
            lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}, lightMapTransform: {value: new PA}},
            bumpmap: {bumpMap: {value: null}, bumpMapTransform: {value: new PA}, bumpScale: {value: 1}},
            normalmap: {
                normalMap: {value: null},
                normalMapTransform: {value: new PA},
                normalScale: {value: new DA(1, 1)}
            },
            displacementmap: {
                displacementMap: {value: null},
                displacementMapTransform: {value: new PA},
                displacementScale: {value: 1},
                displacementBias: {value: 0}
            },
            emissivemap: {emissiveMap: {value: null}, emissiveMapTransform: {value: new PA}},
            metalnessmap: {metalnessMap: {value: null}, metalnessMapTransform: {value: new PA}},
            roughnessmap: {roughnessMap: {value: null}, roughnessMapTransform: {value: new PA}},
            gradientmap: {gradientMap: {value: null}},
            fog: {
                fogDensity: {value: 25e-5},
                fogNear: {value: 1},
                fogFar: {value: 2e3},
                fogColor: {value: new St(16777215)}
            },
            lights: {
                ambientLightColor: {value: []},
                lightProbe: {value: []},
                directionalLights: {value: [], properties: {direction: {}, color: {}}},
                directionalLightShadows: {
                    value: [],
                    properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
                },
                directionalShadowMap: {value: []},
                directionalShadowMatrix: {value: []},
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
                },
                spotLightMap: {value: []},
                spotShadowMap: {value: []},
                spotLightMatrix: {value: []},
                pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}},
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {value: []},
                pointShadowMatrix: {value: []},
                hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
                rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}},
                ltc_1: {value: null},
                ltc_2: {value: null}
            },
            points: {
                diffuse: {value: new St(16777215)},
                opacity: {value: 1},
                size: {value: 1},
                scale: {value: 1},
                map: {value: null},
                alphaMap: {value: null},
                alphaMapTransform: {value: new PA},
                alphaTest: {value: 0},
                uvTransform: {value: new PA}
            },
            sprite: {
                diffuse: {value: new St(16777215)},
                opacity: {value: 1},
                center: {value: new DA(.5, .5)},
                rotation: {value: 0},
                map: {value: null},
                mapTransform: {value: new PA},
                alphaMap: {value: null},
                alphaMapTransform: {value: new PA},
                alphaTest: {value: 0}
            }
        }, Gn = {
            basic: {
                uniforms: gn([On.common, On.specularmap, On.envmap, On.aomap, On.lightmap, On.fog]),
                vertexShader: Nn.meshbasic_vert,
                fragmentShader: Nn.meshbasic_frag
            },
            lambert: {
                uniforms: gn([On.common, On.specularmap, On.envmap, On.aomap, On.lightmap, On.emissivemap, On.bumpmap, On.normalmap, On.displacementmap, On.fog, On.lights, {emissive: {value: new St(0)}}]),
                vertexShader: Nn.meshlambert_vert,
                fragmentShader: Nn.meshlambert_frag
            },
            phong: {
                uniforms: gn([On.common, On.specularmap, On.envmap, On.aomap, On.lightmap, On.emissivemap, On.bumpmap, On.normalmap, On.displacementmap, On.fog, On.lights, {
                    emissive: {value: new St(0)},
                    specular: {value: new St(1118481)},
                    shininess: {value: 30}
                }]), vertexShader: Nn.meshphong_vert, fragmentShader: Nn.meshphong_frag
            },
            standard: {
                uniforms: gn([On.common, On.envmap, On.aomap, On.lightmap, On.emissivemap, On.bumpmap, On.normalmap, On.displacementmap, On.roughnessmap, On.metalnessmap, On.fog, On.lights, {
                    emissive: {value: new St(0)},
                    roughness: {value: 1},
                    metalness: {value: 0},
                    envMapIntensity: {value: 1}
                }]), vertexShader: Nn.meshphysical_vert, fragmentShader: Nn.meshphysical_frag
            },
            toon: {
                uniforms: gn([On.common, On.aomap, On.lightmap, On.emissivemap, On.bumpmap, On.normalmap, On.displacementmap, On.gradientmap, On.fog, On.lights, {emissive: {value: new St(0)}}]),
                vertexShader: Nn.meshtoon_vert,
                fragmentShader: Nn.meshtoon_frag
            },
            matcap: {
                uniforms: gn([On.common, On.bumpmap, On.normalmap, On.displacementmap, On.fog, {matcap: {value: null}}]),
                vertexShader: Nn.meshmatcap_vert,
                fragmentShader: Nn.meshmatcap_frag
            },
            points: {uniforms: gn([On.points, On.fog]), vertexShader: Nn.points_vert, fragmentShader: Nn.points_frag},
            dashed: {
                uniforms: gn([On.common, On.fog, {
                    scale: {value: 1},
                    dashSize: {value: 1},
                    totalSize: {value: 2}
                }]), vertexShader: Nn.linedashed_vert, fragmentShader: Nn.linedashed_frag
            },
            depth: {
                uniforms: gn([On.common, On.displacementmap]),
                vertexShader: Nn.depth_vert,
                fragmentShader: Nn.depth_frag
            },
            normal: {
                uniforms: gn([On.common, On.bumpmap, On.normalmap, On.displacementmap, {opacity: {value: 1}}]),
                vertexShader: Nn.meshnormal_vert,
                fragmentShader: Nn.meshnormal_frag
            },
            sprite: {uniforms: gn([On.sprite, On.fog]), vertexShader: Nn.sprite_vert, fragmentShader: Nn.sprite_frag},
            background: {
                uniforms: {uvTransform: {value: new PA}, t2D: {value: null}, backgroundIntensity: {value: 1}},
                vertexShader: Nn.background_vert,
                fragmentShader: Nn.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {value: null},
                    flipEnvMap: {value: -1},
                    backgroundBlurriness: {value: 0},
                    backgroundIntensity: {value: 1},
                    backgroundRotation: {value: new PA}
                }, vertexShader: Nn.backgroundCube_vert, fragmentShader: Nn.backgroundCube_frag
            },
            cube: {
                uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
                vertexShader: Nn.cube_vert,
                fragmentShader: Nn.cube_frag
            },
            equirect: {
                uniforms: {tEquirect: {value: null}},
                vertexShader: Nn.equirect_vert,
                fragmentShader: Nn.equirect_frag
            },
            distanceRGBA: {
                uniforms: gn([On.common, On.displacementmap, {
                    referencePosition: {value: new ce},
                    nearDistance: {value: 1},
                    farDistance: {value: 1e3}
                }]), vertexShader: Nn.distanceRGBA_vert, fragmentShader: Nn.distanceRGBA_frag
            },
            shadow: {
                uniforms: gn([On.lights, On.fog, {color: {value: new St(0)}, opacity: {value: 1}}]),
                vertexShader: Nn.shadow_vert,
                fragmentShader: Nn.shadow_frag
            }
        };
        Gn.physical = {
            uniforms: gn([Gn.standard.uniforms, {
                clearcoat: {value: 0},
                clearcoatMap: {value: null},
                clearcoatMapTransform: {value: new PA},
                clearcoatNormalMap: {value: null},
                clearcoatNormalMapTransform: {value: new PA},
                clearcoatNormalScale: {value: new DA(1, 1)},
                clearcoatRoughness: {value: 0},
                clearcoatRoughnessMap: {value: null},
                clearcoatRoughnessMapTransform: {value: new PA},
                iridescence: {value: 0},
                iridescenceMap: {value: null},
                iridescenceMapTransform: {value: new PA},
                iridescenceIOR: {value: 1.3},
                iridescenceThicknessMinimum: {value: 100},
                iridescenceThicknessMaximum: {value: 400},
                iridescenceThicknessMap: {value: null},
                iridescenceThicknessMapTransform: {value: new PA},
                sheen: {value: 0},
                sheenColor: {value: new St(0)},
                sheenColorMap: {value: null},
                sheenColorMapTransform: {value: new PA},
                sheenRoughness: {value: 1},
                sheenRoughnessMap: {value: null},
                sheenRoughnessMapTransform: {value: new PA},
                transmission: {value: 0},
                transmissionMap: {value: null},
                transmissionMapTransform: {value: new PA},
                transmissionSamplerSize: {value: new DA},
                transmissionSamplerMap: {value: null},
                thickness: {value: 0},
                thicknessMap: {value: null},
                thicknessMapTransform: {value: new PA},
                attenuationDistance: {value: 0},
                attenuationColor: {value: new St(0)},
                specularColor: {value: new St(1, 1, 1)},
                specularColorMap: {value: null},
                specularColorMapTransform: {value: new PA},
                specularIntensity: {value: 1},
                specularIntensityMap: {value: null},
                specularIntensityMapTransform: {value: new PA},
                anisotropyVector: {value: new DA},
                anisotropyMap: {value: null},
                anisotropyMapTransform: {value: new PA}
            }]), vertexShader: Nn.meshphysical_vert, fragmentShader: Nn.meshphysical_frag
        };
        const Vn = {r: 0, b: 0, g: 0}, Kn = new je, kn = new Oe;

        function zn(A, e, t, n, r, i, a) {
            const s = new St(0);
            let o, l, c = !0 === i ? 0 : 1, u = null, h = 0, d = null;

            function p(e, t) {
                e.getRGB(Vn, mn(A)), n.buffers.color.setClear(Vn.r, Vn.g, Vn.b, t, a)
            }

            return {
                getClearColor: function () {
                    return s
                }, setClearColor: function (A, e = 1) {
                    s.set(A), c = e, p(s, c)
                }, getClearAlpha: function () {
                    return c
                }, setClearAlpha: function (A) {
                    c = A, p(s, c)
                }, render: function (i, f) {
                    let g = !1, m = !0 === f.isScene ? f.background : null;
                    m && m.isTexture && (m = (f.backgroundBlurriness > 0 ? t : e).get(m)), null === m ? p(s, c) : m && m.isColor && (p(m, 1), g = !0);
                    const B = A.xr.getEnvironmentBlendMode();
                    "additive" === B ? n.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === B && n.buffers.color.setClear(0, 0, 0, 0, a), (A.autoClear || g) && A.clear(A.autoClearColor, A.autoClearDepth, A.autoClearStencil), m && (m.isCubeTexture || m.mapping === D) ? (void 0 === l && (l = new hn(new pn(1, 1, 1), new wn({
                        name: "BackgroundCubeMaterial",
                        uniforms: fn(Gn.backgroundCube.uniforms),
                        vertexShader: Gn.backgroundCube.vertexShader,
                        fragmentShader: Gn.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function (A, e, t) {
                        this.matrixWorld.copyPosition(t.matrixWorld)
                    }, Object.defineProperty(l.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), r.update(l)), Kn.copy(f.backgroundRotation), Kn.x *= -1, Kn.y *= -1, Kn.z *= -1, m.isCubeTexture && !1 === m.isRenderTargetTexture && (Kn.y *= -1, Kn.z *= -1), l.material.uniforms.envMap.value = m, l.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, l.material.uniforms.backgroundBlurriness.value = f.backgroundBlurriness, l.material.uniforms.backgroundIntensity.value = f.backgroundIntensity, l.material.uniforms.backgroundRotation.value.setFromMatrix4(kn.makeRotationFromEuler(Kn)), l.material.toneMapped = YA.getTransfer(m.colorSpace) !== fA, u === m && h === m.version && d === A.toneMapping || (l.material.needsUpdate = !0, u = m, h = m.version, d = A.toneMapping), l.layers.enableAll(), i.unshift(l, l.geometry, l.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new hn(new Pn(2, 2), new wn({
                        name: "BackgroundMaterial",
                        uniforms: fn(Gn.background.uniforms),
                        vertexShader: Gn.background.vertexShader,
                        fragmentShader: Gn.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), r.update(o)), o.material.uniforms.t2D.value = m, o.material.uniforms.backgroundIntensity.value = f.backgroundIntensity, o.material.toneMapped = YA.getTransfer(m.colorSpace) !== fA, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), u === m && h === m.version && d === A.toneMapping || (o.material.needsUpdate = !0, u = m, h = m.version, d = A.toneMapping), o.layers.enableAll(), i.unshift(o, o.geometry, o.material, 0, 0, null))
                }
            }
        }

        function Wn(A, e, t, n) {
            const r = A.getParameter(A.MAX_VERTEX_ATTRIBS), i = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                a = n.isWebGL2 || null !== i, s = {}, o = d(null);
            let l = o, c = !1;

            function u(e) {
                return n.isWebGL2 ? A.bindVertexArray(e) : i.bindVertexArrayOES(e)
            }

            function h(e) {
                return n.isWebGL2 ? A.deleteVertexArray(e) : i.deleteVertexArrayOES(e)
            }

            function d(A) {
                const e = [], t = [], n = [];
                for (let A = 0; A < r; A++) e[A] = 0, t[A] = 0, n[A] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: t,
                    attributeDivisors: n,
                    object: A,
                    attributes: {},
                    index: null
                }
            }

            function p() {
                const A = l.newAttributes;
                for (let e = 0, t = A.length; e < t; e++) A[e] = 0
            }

            function f(A) {
                g(A, 0)
            }

            function g(t, r) {
                const i = l.newAttributes, a = l.enabledAttributes, s = l.attributeDivisors;
                i[t] = 1, 0 === a[t] && (A.enableVertexAttribArray(t), a[t] = 1), s[t] !== r && ((n.isWebGL2 ? A : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, r), s[t] = r)
            }

            function m() {
                const e = l.newAttributes, t = l.enabledAttributes;
                for (let n = 0, r = t.length; n < r; n++) t[n] !== e[n] && (A.disableVertexAttribArray(n), t[n] = 0)
            }

            function B(e, t, n, r, i, a, s) {
                !0 === s ? A.vertexAttribIPointer(e, t, n, i, a) : A.vertexAttribPointer(e, t, n, r, i, a)
            }

            function w() {
                v(), c = !0, l !== o && (l = o, u(l.object))
            }

            function v() {
                o.geometry = null, o.program = null, o.wireframe = !1
            }

            return {
                setup: function (r, o, h, w, v) {
                    let _ = !1;
                    if (a) {
                        const e = function (e, t, r) {
                            const a = !0 === r.wireframe;
                            let o = s[e.id];
                            void 0 === o && (o = {}, s[e.id] = o);
                            let l = o[t.id];
                            void 0 === l && (l = {}, o[t.id] = l);
                            let c = l[a];
                            return void 0 === c && (c = d(n.isWebGL2 ? A.createVertexArray() : i.createVertexArrayOES()), l[a] = c), c
                        }(w, h, o);
                        l !== e && (l = e, u(l.object)), _ = function (A, e, t, n) {
                            const r = l.attributes, i = e.attributes;
                            let a = 0;
                            const s = t.getAttributes();
                            for (const e in s) if (s[e].location >= 0) {
                                const t = r[e];
                                let n = i[e];
                                if (void 0 === n && ("instanceMatrix" === e && A.instanceMatrix && (n = A.instanceMatrix), "instanceColor" === e && A.instanceColor && (n = A.instanceColor)), void 0 === t) return !0;
                                if (t.attribute !== n) return !0;
                                if (n && t.data !== n.data) return !0;
                                a++
                            }
                            return l.attributesNum !== a || l.index !== n
                        }(r, w, h, v), _ && function (A, e, t, n) {
                            const r = {}, i = e.attributes;
                            let a = 0;
                            const s = t.getAttributes();
                            for (const e in s) if (s[e].location >= 0) {
                                let t = i[e];
                                void 0 === t && ("instanceMatrix" === e && A.instanceMatrix && (t = A.instanceMatrix), "instanceColor" === e && A.instanceColor && (t = A.instanceColor));
                                const n = {};
                                n.attribute = t, t && t.data && (n.data = t.data), r[e] = n, a++
                            }
                            l.attributes = r, l.attributesNum = a, l.index = n
                        }(r, w, h, v)
                    } else {
                        const A = !0 === o.wireframe;
                        l.geometry === w.id && l.program === h.id && l.wireframe === A || (l.geometry = w.id, l.program = h.id, l.wireframe = A, _ = !0)
                    }
                    null !== v && t.update(v, A.ELEMENT_ARRAY_BUFFER), (_ || c) && (c = !1, function (r, i, a, s) {
                        if (!1 === n.isWebGL2 && (r.isInstancedMesh || s.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        p();
                        const o = s.attributes, l = a.getAttributes(), c = i.defaultAttributeValues;
                        for (const e in l) {
                            const i = l[e];
                            if (i.location >= 0) {
                                let a = o[e];
                                if (void 0 === a && ("instanceMatrix" === e && r.instanceMatrix && (a = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (a = r.instanceColor)), void 0 !== a) {
                                    const e = a.normalized, o = a.itemSize, l = t.get(a);
                                    if (void 0 === l) continue;
                                    const c = l.buffer, u = l.type, h = l.bytesPerElement,
                                        d = !0 === n.isWebGL2 && (u === A.INT || u === A.UNSIGNED_INT || 1013 === a.gpuType);
                                    if (a.isInterleavedBufferAttribute) {
                                        const t = a.data, n = t.stride, l = a.offset;
                                        if (t.isInstancedInterleavedBuffer) {
                                            for (let A = 0; A < i.locationSize; A++) g(i.location + A, t.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = t.meshPerAttribute * t.count)
                                        } else for (let A = 0; A < i.locationSize; A++) f(i.location + A);
                                        A.bindBuffer(A.ARRAY_BUFFER, c);
                                        for (let A = 0; A < i.locationSize; A++) B(i.location + A, o / i.locationSize, u, e, n * h, (l + o / i.locationSize * A) * h, d)
                                    } else {
                                        if (a.isInstancedBufferAttribute) {
                                            for (let A = 0; A < i.locationSize; A++) g(i.location + A, a.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)
                                        } else for (let A = 0; A < i.locationSize; A++) f(i.location + A);
                                        A.bindBuffer(A.ARRAY_BUFFER, c);
                                        for (let A = 0; A < i.locationSize; A++) B(i.location + A, o / i.locationSize, u, e, o * h, o / i.locationSize * A * h, d)
                                    }
                                } else if (void 0 !== c) {
                                    const t = c[e];
                                    if (void 0 !== t) switch (t.length) {
                                        case 2:
                                            A.vertexAttrib2fv(i.location, t);
                                            break;
                                        case 3:
                                            A.vertexAttrib3fv(i.location, t);
                                            break;
                                        case 4:
                                            A.vertexAttrib4fv(i.location, t);
                                            break;
                                        default:
                                            A.vertexAttrib1fv(i.location, t)
                                    }
                                }
                            }
                        }
                        m()
                    }(r, o, h, w), null !== v && A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, t.get(v).buffer))
                }, reset: w, resetDefaultState: v, dispose: function () {
                    w();
                    for (const A in s) {
                        const e = s[A];
                        for (const A in e) {
                            const t = e[A];
                            for (const A in t) h(t[A].object), delete t[A];
                            delete e[A]
                        }
                        delete s[A]
                    }
                }, releaseStatesOfGeometry: function (A) {
                    if (void 0 === s[A.id]) return;
                    const e = s[A.id];
                    for (const A in e) {
                        const t = e[A];
                        for (const A in t) h(t[A].object), delete t[A];
                        delete e[A]
                    }
                    delete s[A.id]
                }, releaseStatesOfProgram: function (A) {
                    for (const e in s) {
                        const t = s[e];
                        if (void 0 === t[A.id]) continue;
                        const n = t[A.id];
                        for (const A in n) h(n[A].object), delete n[A];
                        delete t[A.id]
                    }
                }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: m
            }
        }

        function Xn(A, e, t, n) {
            const r = n.isWebGL2;
            let i;
            this.setMode = function (A) {
                i = A
            }, this.render = function (e, n) {
                A.drawArrays(i, e, n), t.update(n, i, 1)
            }, this.renderInstances = function (n, a, s) {
                if (0 === s) return;
                let o, l;
                if (r) o = A, l = "drawArraysInstanced"; else if (o = e.get("ANGLE_instanced_arrays"), l = "drawArraysInstancedANGLE", null === o) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                o[l](i, n, a, s), t.update(a, i, s)
            }, this.renderMultiDraw = function (A, n, r) {
                if (0 === r) return;
                const a = e.get("WEBGL_multi_draw");
                if (null === a) for (let e = 0; e < r; e++) this.render(A[e], n[e]); else {
                    a.multiDrawArraysWEBGL(i, A, 0, n, 0, r);
                    let e = 0;
                    for (let A = 0; A < r; A++) e += n[A];
                    t.update(e, i, 1)
                }
            }
        }

        function Yn(A, e, t) {
            let n;

            function r(e) {
                if ("highp" === e) {
                    if (A.getShaderPrecisionFormat(A.VERTEX_SHADER, A.HIGH_FLOAT).precision > 0 && A.getShaderPrecisionFormat(A.FRAGMENT_SHADER, A.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && A.getShaderPrecisionFormat(A.VERTEX_SHADER, A.MEDIUM_FLOAT).precision > 0 && A.getShaderPrecisionFormat(A.FRAGMENT_SHADER, A.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }

            const i = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === A.constructor.name;
            let a = void 0 !== t.precision ? t.precision : "highp";
            const s = r(a);
            s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
            const o = i || e.has("WEBGL_draw_buffers"), l = !0 === t.logarithmicDepthBuffer,
                c = A.getParameter(A.MAX_TEXTURE_IMAGE_UNITS), u = A.getParameter(A.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                h = A.getParameter(A.MAX_TEXTURE_SIZE), d = A.getParameter(A.MAX_CUBE_MAP_TEXTURE_SIZE),
                p = A.getParameter(A.MAX_VERTEX_ATTRIBS), f = A.getParameter(A.MAX_VERTEX_UNIFORM_VECTORS),
                g = A.getParameter(A.MAX_VARYING_VECTORS), m = A.getParameter(A.MAX_FRAGMENT_UNIFORM_VECTORS),
                B = u > 0, w = i || e.has("OES_texture_float");
            return {
                isWebGL2: i,
                drawBuffers: o,
                getMaxAnisotropy: function () {
                    if (void 0 !== n) return n;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const t = e.get("EXT_texture_filter_anisotropic");
                        n = A.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else n = 0;
                    return n
                },
                getMaxPrecision: r,
                precision: a,
                logarithmicDepthBuffer: l,
                maxTextures: c,
                maxVertexTextures: u,
                maxTextureSize: h,
                maxCubemapSize: d,
                maxAttributes: p,
                maxVertexUniforms: f,
                maxVaryings: g,
                maxFragmentUniforms: m,
                vertexTextures: B,
                floatFragmentTextures: w,
                floatVertexTextures: B && w,
                maxSamples: i ? A.getParameter(A.MAX_SAMPLES) : 0
            }
        }

        function Jn(A) {
            const e = this;
            let t = null, n = 0, r = !1, i = !1;
            const a = new Tn, s = new PA, o = {value: null, needsUpdate: !1};

            function l(A, t, n, r) {
                const i = null !== A ? A.length : 0;
                let l = null;
                if (0 !== i) {
                    if (l = o.value, !0 !== r || null === l) {
                        const e = n + 4 * i, r = t.matrixWorldInverse;
                        s.getNormalMatrix(r), (null === l || l.length < e) && (l = new Float32Array(e));
                        for (let e = 0, t = n; e !== i; ++e, t += 4) a.copy(A[e]).applyMatrix4(r, s), a.normal.toArray(l, t), l[t + 3] = a.constant
                    }
                    o.value = l, o.needsUpdate = !0
                }
                return e.numPlanes = i, e.numIntersection = 0, l
            }

            this.uniform = o, this.numPlanes = 0, this.numIntersection = 0, this.init = function (A, e) {
                const t = 0 !== A.length || e || 0 !== n || r;
                return r = e, n = A.length, t
            }, this.beginShadows = function () {
                i = !0, l(null)
            }, this.endShadows = function () {
                i = !1
            }, this.setGlobalState = function (A, e) {
                t = l(A, e, 0)
            }, this.setState = function (a, s, c) {
                const u = a.clippingPlanes, h = a.clipIntersection, d = a.clipShadows, p = A.get(a);
                if (!r || null === u || 0 === u.length || i && !d) i ? l(null) : (o.value !== t && (o.value = t, o.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0); else {
                    const A = i ? 0 : n, e = 4 * A;
                    let r = p.clippingState || null;
                    o.value = r, r = l(u, s, e, c);
                    for (let A = 0; A !== e; ++A) r[A] = t[A];
                    p.clippingState = r, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += A
                }
            }
        }

        function jn(A) {
            let e = new WeakMap;

            function t(A, e) {
                return 303 === e ? A.mapping = R : 304 === e && (A.mapping = H), A
            }

            function n(A) {
                const t = A.target;
                t.removeEventListener("dispose", n);
                const r = e.get(t);
                void 0 !== r && (e.delete(t), r.dispose())
            }

            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const i = r.mapping;
                        if (303 === i || 304 === i) {
                            if (e.has(r)) return t(e.get(r).texture, r.mapping);
                            {
                                const i = r.image;
                                if (i && i.height > 0) {
                                    const a = new Fn(i.height);
                                    return a.fromEquirectangularTexture(A, r), e.set(r, a), r.addEventListener("dispose", n), t(a.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                }, dispose: function () {
                    e = new WeakMap
                }
            }
        }

        class Zn extends vn {
            constructor(A = -1, e = 1, t = 1, n = -1, r = .1, i = 2e3) {
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = A, this.right = e, this.top = t, this.bottom = n, this.near = r, this.far = i, this.updateProjectionMatrix()
            }

            copy(A, e) {
                return super.copy(A, e), this.left = A.left, this.right = A.right, this.top = A.top, this.bottom = A.bottom, this.near = A.near, this.far = A.far, this.zoom = A.zoom, this.view = null === A.view ? null : Object.assign({}, A.view), this
            }

            setViewOffset(A, e, t, n, r, i) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = A, this.view.fullHeight = e, this.view.offsetX = t, this.view.offsetY = n, this.view.width = r, this.view.height = i, this.updateProjectionMatrix()
            }

            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }

            updateProjectionMatrix() {
                const A = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
                    t = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
                let r = t - A, i = t + A, a = n + e, s = n - e;
                if (null !== this.view && this.view.enabled) {
                    const A = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += A * this.view.offsetX, i = r + A * this.view.width, a -= e * this.view.offsetY, s = a - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, i, a, s, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }

            toJSON(A) {
                const e = super.toJSON(A);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }

        const qn = [.125, .215, .35, .446, .526, .582], $n = new Zn, Ar = new St;
        let er = null, tr = 0, nr = 0;
        const rr = (1 + Math.sqrt(5)) / 2, ir = 1 / rr,
            ar = [new ce(1, 1, 1), new ce(-1, 1, 1), new ce(1, 1, -1), new ce(-1, 1, -1), new ce(0, rr, ir), new ce(0, rr, -ir), new ce(ir, 0, rr), new ce(-ir, 0, rr), new ce(rr, ir, 0), new ce(-rr, ir, 0)];

        class sr {
            constructor(A) {
                this._renderer = A, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }

            fromScene(A, e = 0, t = .1, n = 100) {
                er = this._renderer.getRenderTarget(), tr = this._renderer.getActiveCubeFace(), nr = this._renderer.getActiveMipmapLevel(), this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0, this._sceneToCubeUV(A, t, n, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
            }

            fromEquirectangular(A, e = null) {
                return this._fromTexture(A, e)
            }

            fromCubemap(A, e = null) {
                return this._fromTexture(A, e)
            }

            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = ur(), this._compileMaterial(this._cubemapMaterial))
            }

            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = cr(), this._compileMaterial(this._equirectMaterial))
            }

            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }

            _setSize(A) {
                this._lodMax = Math.floor(Math.log2(A)), this._cubeSize = Math.pow(2, this._lodMax)
            }

            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let A = 0; A < this._lodPlanes.length; A++) this._lodPlanes[A].dispose()
            }

            _cleanup(A) {
                this._renderer.setRenderTarget(er, tr, nr), A.scissorTest = !1, lr(A, 0, 0, A.width, A.height)
            }

            _fromTexture(A, e) {
                A.mapping === R || A.mapping === H ? this._setSize(0 === A.image.length ? 16 : A.image[0].width || A.image[0].image.width) : this._setSize(A.image.width / 4), er = this._renderer.getRenderTarget(), tr = this._renderer.getActiveCubeFace(), nr = this._renderer.getActiveMipmapLevel();
                const t = e || this._allocateTargets();
                return this._textureToCubeUV(A, t), this._applyPMREM(t), this._cleanup(t), t
            }

            _allocateTargets() {
                const A = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, t = {
                    magFilter: K,
                    minFilter: K,
                    generateMipmaps: !1,
                    type: j,
                    format: q,
                    colorSpace: uA,
                    depthBuffer: !1
                }, n = or(A, e, t);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== A || this._pingPongRenderTarget.height !== e) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = or(A, e, t);
                    const {_lodMax: n} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function (A) {
                        const e = [], t = [], n = [];
                        let r = A;
                        const i = A - 4 + 1 + qn.length;
                        for (let a = 0; a < i; a++) {
                            const i = Math.pow(2, r);
                            t.push(i);
                            let s = 1 / i;
                            a > A - 4 ? s = qn[a - A + 4 - 1] : 0 === a && (s = 0), n.push(s);
                            const o = 1 / (i - 2), l = -o, c = 1 + o, u = [l, l, c, l, c, c, l, l, c, c, l, c], h = 6,
                                d = 6, p = 3, f = 2, g = 1, m = new Float32Array(p * d * h),
                                B = new Float32Array(f * d * h), w = new Float32Array(g * d * h);
                            for (let A = 0; A < h; A++) {
                                const e = A % 3 * 2 / 3 - 1, t = A > 2 ? 0 : -1,
                                    n = [e, t, 0, e + 2 / 3, t, 0, e + 2 / 3, t + 1, 0, e, t, 0, e + 2 / 3, t + 1, 0, e, t + 1, 0];
                                m.set(n, p * d * A), B.set(u, f * d * A);
                                const r = [A, A, A, A, A, A];
                                w.set(r, g * d * A)
                            }
                            const v = new Xt;
                            v.setAttribute("position", new Ht(m, p)), v.setAttribute("uv", new Ht(B, f)), v.setAttribute("faceIndex", new Ht(w, g)), e.push(v), r > 4 && r--
                        }
                        return {lodPlanes: e, sizeLods: t, sigmas: n}
                    }(n)), this._blurMaterial = function (A, e, t) {
                        const n = new Float32Array(20), r = new ce(0, 1, 0);
                        return new wn({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / e,
                                CUBEUV_TEXEL_HEIGHT: 1 / t,
                                CUBEUV_MAX_MIP: `${A}.0`
                            },
                            uniforms: {
                                envMap: {value: null},
                                samples: {value: 1},
                                weights: {value: n},
                                latitudinal: {value: !1},
                                dTheta: {value: 0},
                                mipInt: {value: 0},
                                poleAxis: {value: r}
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(n, A, e)
                }
                return n
            }

            _compileMaterial(A) {
                const e = new hn(this._lodPlanes[0], A);
                this._renderer.compile(e, $n)
            }

            _sceneToCubeUV(A, e, t, n) {
                const r = new Un(90, 1, e, t), i = [1, -1, 1, 1, 1, 1], a = [1, 1, 1, -1, -1, -1], s = this._renderer,
                    o = s.autoClear, l = s.toneMapping;
                s.getClearColor(Ar), s.toneMapping = M, s.autoClear = !1;
                const c = new It({name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1}),
                    u = new hn(new pn, c);
                let h = !1;
                const d = A.background;
                d ? d.isColor && (c.color.copy(d), A.background = null, h = !0) : (c.color.copy(Ar), h = !0);
                for (let e = 0; e < 6; e++) {
                    const t = e % 3;
                    0 === t ? (r.up.set(0, i[e], 0), r.lookAt(a[e], 0, 0)) : 1 === t ? (r.up.set(0, 0, i[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, i[e], 0), r.lookAt(0, 0, a[e]));
                    const o = this._cubeSize;
                    lr(n, t * o, e > 2 ? o : 0, o, o), s.setRenderTarget(n), h && s.render(u, r), s.render(A, r)
                }
                u.geometry.dispose(), u.material.dispose(), s.toneMapping = l, s.autoClear = o, A.background = d
            }

            _textureToCubeUV(A, e) {
                const t = this._renderer, n = A.mapping === R || A.mapping === H;
                n ? (null === this._cubemapMaterial && (this._cubemapMaterial = ur()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === A.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = cr());
                const r = n ? this._cubemapMaterial : this._equirectMaterial, i = new hn(this._lodPlanes[0], r);
                r.uniforms.envMap.value = A;
                const a = this._cubeSize;
                lr(e, 0, 0, 3 * a, 2 * a), t.setRenderTarget(e), t.render(i, $n)
            }

            _applyPMREM(A) {
                const e = this._renderer, t = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < this._lodPlanes.length; e++) {
                    const t = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                        n = ar[(e - 1) % ar.length];
                    this._blur(A, e - 1, e, t, n)
                }
                e.autoClear = t
            }

            _blur(A, e, t, n, r) {
                const i = this._pingPongRenderTarget;
                this._halfBlur(A, i, e, t, n, "latitudinal", r), this._halfBlur(i, A, t, t, n, "longitudinal", r)
            }

            _halfBlur(A, e, t, n, r, i, a) {
                const s = this._renderer, o = this._blurMaterial;
                "latitudinal" !== i && "longitudinal" !== i && console.error("blur direction must be either latitudinal or longitudinal!");
                const l = new hn(this._lodPlanes[n], o), c = o.uniforms, u = this._sizeLods[t] - 1,
                    h = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39, d = r / h,
                    p = isFinite(r) ? 1 + Math.floor(3 * d) : 20;
                p > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
                const f = [];
                let g = 0;
                for (let A = 0; A < 20; ++A) {
                    const e = A / d, t = Math.exp(-e * e / 2);
                    f.push(t), 0 === A ? g += t : A < p && (g += 2 * t)
                }
                for (let A = 0; A < f.length; A++) f[A] = f[A] / g;
                c.envMap.value = A.texture, c.samples.value = p, c.weights.value = f, c.latitudinal.value = "latitudinal" === i, a && (c.poleAxis.value = a);
                const {_lodMax: m} = this;
                c.dTheta.value = h, c.mipInt.value = m - t;
                const B = this._sizeLods[n];
                lr(e, 3 * B * (n > m - 4 ? n - m + 4 : 0), 4 * (this._cubeSize - B), 3 * B, 2 * B), s.setRenderTarget(e), s.render(l, $n)
            }
        }

        function or(A, e, t) {
            const n = new ae(A, e, t);
            return n.texture.mapping = D, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
        }

        function lr(A, e, t, n, r) {
            A.viewport.set(e, t, n, r), A.scissor.set(e, t, n, r)
        }

        function cr() {
            return new wn({
                name: "EquirectangularToCubeUV",
                uniforms: {envMap: {value: null}},
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function ur() {
            return new wn({
                name: "CubemapToCubeUV",
                uniforms: {envMap: {value: null}, flipEnvMap: {value: -1}},
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function hr(A) {
            let e = new WeakMap, t = null;

            function n(A) {
                const t = A.target;
                t.removeEventListener("dispose", n);
                const r = e.get(t);
                void 0 !== r && (e.delete(t), r.dispose())
            }

            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const i = r.mapping, a = 303 === i || 304 === i, s = i === R || i === H;
                        if (a || s) {
                            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                r.needsPMREMUpdate = !1;
                                let n = e.get(r);
                                return null === t && (t = new sr(A)), n = a ? t.fromEquirectangular(r, n) : t.fromCubemap(r, n), e.set(r, n), n.texture
                            }
                            if (e.has(r)) return e.get(r).texture;
                            {
                                const i = r.image;
                                if (a && i && i.height > 0 || s && i && function (A) {
                                    let e = 0;
                                    for (let t = 0; t < 6; t++) void 0 !== A[t] && e++;
                                    return 6 === e
                                }(i)) {
                                    null === t && (t = new sr(A));
                                    const i = a ? t.fromEquirectangular(r) : t.fromCubemap(r);
                                    return e.set(r, i), r.addEventListener("dispose", n), i.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                }, dispose: function () {
                    e = new WeakMap, null !== t && (t.dispose(), t = null)
                }
            }
        }

        function dr(A) {
            const e = {};

            function t(t) {
                if (void 0 !== e[t]) return e[t];
                let n;
                switch (t) {
                    case"WEBGL_depth_texture":
                        n = A.getExtension("WEBGL_depth_texture") || A.getExtension("MOZ_WEBGL_depth_texture") || A.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case"EXT_texture_filter_anisotropic":
                        n = A.getExtension("EXT_texture_filter_anisotropic") || A.getExtension("MOZ_EXT_texture_filter_anisotropic") || A.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case"WEBGL_compressed_texture_s3tc":
                        n = A.getExtension("WEBGL_compressed_texture_s3tc") || A.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || A.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case"WEBGL_compressed_texture_pvrtc":
                        n = A.getExtension("WEBGL_compressed_texture_pvrtc") || A.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        n = A.getExtension(t)
                }
                return e[t] = n, n
            }

            return {
                has: function (A) {
                    return null !== t(A)
                }, init: function (A) {
                    A.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture")
                }, get: function (A) {
                    const e = t(A);
                    return null === e && console.warn("THREE.WebGLRenderer: " + A + " extension not supported."), e
                }
            }
        }

        function pr(A, e, t, n) {
            const r = {}, i = new WeakMap;

            function a(A) {
                const s = A.target;
                null !== s.index && e.remove(s.index);
                for (const A in s.attributes) e.remove(s.attributes[A]);
                for (const A in s.morphAttributes) {
                    const t = s.morphAttributes[A];
                    for (let A = 0, n = t.length; A < n; A++) e.remove(t[A])
                }
                s.removeEventListener("dispose", a), delete r[s.id];
                const o = i.get(s);
                o && (e.remove(o), i.delete(s)), n.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, t.memory.geometries--
            }

            function s(A) {
                const t = [], n = A.index, r = A.attributes.position;
                let a = 0;
                if (null !== n) {
                    const A = n.array;
                    a = n.version;
                    for (let e = 0, n = A.length; e < n; e += 3) {
                        const n = A[e + 0], r = A[e + 1], i = A[e + 2];
                        t.push(n, r, r, i, i, n)
                    }
                } else {
                    if (void 0 === r) return;
                    {
                        const A = r.array;
                        a = r.version;
                        for (let e = 0, n = A.length / 3 - 1; e < n; e += 3) {
                            const A = e + 0, n = e + 1, r = e + 2;
                            t.push(A, n, n, r, r, A)
                        }
                    }
                }
                const s = new (OA(t) ? Pt : Dt)(t, 1);
                s.version = a;
                const o = i.get(A);
                o && e.remove(o), i.set(A, s)
            }

            return {
                get: function (A, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, t.memory.geometries++), e
                }, update: function (t) {
                    const n = t.attributes;
                    for (const t in n) e.update(n[t], A.ARRAY_BUFFER);
                    const r = t.morphAttributes;
                    for (const t in r) {
                        const n = r[t];
                        for (let t = 0, r = n.length; t < r; t++) e.update(n[t], A.ARRAY_BUFFER)
                    }
                }, getWireframeAttribute: function (A) {
                    const e = i.get(A);
                    if (e) {
                        const t = A.index;
                        null !== t && e.version < t.version && s(A)
                    } else s(A);
                    return i.get(A)
                }
            }
        }

        function fr(A, e, t, n) {
            const r = n.isWebGL2;
            let i, a, s;
            this.setMode = function (A) {
                i = A
            }, this.setIndex = function (A) {
                a = A.type, s = A.bytesPerElement
            }, this.render = function (e, n) {
                A.drawElements(i, n, a, e * s), t.update(n, i, 1)
            }, this.renderInstances = function (n, o, l) {
                if (0 === l) return;
                let c, u;
                if (r) c = A, u = "drawElementsInstanced"; else if (c = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                c[u](i, o, a, n * s, l), t.update(o, i, l)
            }, this.renderMultiDraw = function (A, n, r) {
                if (0 === r) return;
                const o = e.get("WEBGL_multi_draw");
                if (null === o) for (let e = 0; e < r; e++) this.render(A[e] / s, n[e]); else {
                    o.multiDrawElementsWEBGL(i, n, 0, a, A, 0, r);
                    let e = 0;
                    for (let A = 0; A < r; A++) e += n[A];
                    t.update(e, i, 1)
                }
            }
        }

        function gr(A) {
            const e = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
            return {
                memory: {geometries: 0, textures: 0}, render: e, programs: null, autoReset: !0, reset: function () {
                    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                }, update: function (t, n, r) {
                    switch (e.calls++, n) {
                        case A.TRIANGLES:
                            e.triangles += r * (t / 3);
                            break;
                        case A.LINES:
                            e.lines += r * (t / 2);
                            break;
                        case A.LINE_STRIP:
                            e.lines += r * (t - 1);
                            break;
                        case A.LINE_LOOP:
                            e.lines += r * t;
                            break;
                        case A.POINTS:
                            e.points += r * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }

        function mr(A, e) {
            return A[0] - e[0]
        }

        function Br(A, e) {
            return Math.abs(e[1]) - Math.abs(A[1])
        }

        function wr(A, e, t) {
            const n = {}, r = new Float32Array(8), i = new WeakMap, a = new re, s = [];
            for (let A = 0; A < 8; A++) s[A] = [A, 0];
            return {
                update: function (o, l, c) {
                    const u = o.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const h = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color,
                            d = void 0 !== h ? h.length : 0;
                        let p = i.get(l);
                        if (void 0 === p || p.count !== d) {
                            void 0 !== p && p.texture.dispose();
                            const f = void 0 !== l.morphAttributes.position, g = void 0 !== l.morphAttributes.normal,
                                m = void 0 !== l.morphAttributes.color, B = l.morphAttributes.position || [],
                                w = l.morphAttributes.normal || [], v = l.morphAttributes.color || [];
                            let _ = 0;
                            !0 === f && (_ = 1), !0 === g && (_ = 2), !0 === m && (_ = 3);
                            let C = l.attributes.position.count * _, E = 1;
                            C > e.maxTextureSize && (E = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
                            const U = new Float32Array(C * E * 4 * d), y = new se(U, C, E, d);
                            y.type = J, y.needsUpdate = !0;
                            const x = 4 * _;
                            for (let F = 0; F < d; F++) {
                                const S = B[F], b = w[F], Q = v[F], T = C * E * 4 * F;
                                for (let I = 0; I < S.count; I++) {
                                    const L = I * x;
                                    !0 === f && (a.fromBufferAttribute(S, I), U[T + L + 0] = a.x, U[T + L + 1] = a.y, U[T + L + 2] = a.z, U[T + L + 3] = 0), !0 === g && (a.fromBufferAttribute(b, I), U[T + L + 4] = a.x, U[T + L + 5] = a.y, U[T + L + 6] = a.z, U[T + L + 7] = 0), !0 === m && (a.fromBufferAttribute(Q, I), U[T + L + 8] = a.x, U[T + L + 9] = a.y, U[T + L + 10] = a.z, U[T + L + 11] = 4 === Q.itemSize ? a.w : 1)
                                }
                            }

                            function M() {
                                y.dispose(), i.delete(l), l.removeEventListener("dispose", M)
                            }

                            p = {
                                count: d,
                                texture: y,
                                size: new DA(C, E)
                            }, i.set(l, p), l.addEventListener("dispose", M)
                        }
                        if (!0 === o.isInstancedMesh && null !== o.morphTexture) c.getUniforms().setValue(A, "morphTexture", o.morphTexture, t); else {
                            let R = 0;
                            for (let D = 0; D < u.length; D++) R += u[D];
                            const H = l.morphTargetsRelative ? 1 : 1 - R;
                            c.getUniforms().setValue(A, "morphTargetBaseInfluence", H), c.getUniforms().setValue(A, "morphTargetInfluences", u)
                        }
                        c.getUniforms().setValue(A, "morphTargetsTexture", p.texture, t), c.getUniforms().setValue(A, "morphTargetsTextureSize", p.size)
                    } else {
                        const P = void 0 === u ? 0 : u.length;
                        let N = n[l.id];
                        if (void 0 === N || N.length !== P) {
                            N = [];
                            for (let k = 0; k < P; k++) N[k] = [k, 0];
                            n[l.id] = N
                        }
                        for (let z = 0; z < P; z++) {
                            const W = N[z];
                            W[0] = z, W[1] = u[z]
                        }
                        N.sort(Br);
                        for (let X = 0; X < 8; X++) X < P && N[X][1] ? (s[X][0] = N[X][0], s[X][1] = N[X][1]) : (s[X][0] = Number.MAX_SAFE_INTEGER, s[X][1] = 0);
                        s.sort(mr);
                        const O = l.morphAttributes.position, G = l.morphAttributes.normal;
                        let V = 0;
                        for (let Y = 0; Y < 8; Y++) {
                            const j = s[Y], Z = j[0], q = j[1];
                            Z !== Number.MAX_SAFE_INTEGER && q ? (O && l.getAttribute("morphTarget" + Y) !== O[Z] && l.setAttribute("morphTarget" + Y, O[Z]), G && l.getAttribute("morphNormal" + Y) !== G[Z] && l.setAttribute("morphNormal" + Y, G[Z]), r[Y] = q, V += q) : (O && !0 === l.hasAttribute("morphTarget" + Y) && l.deleteAttribute("morphTarget" + Y), G && !0 === l.hasAttribute("morphNormal" + Y) && l.deleteAttribute("morphNormal" + Y), r[Y] = 0)
                        }
                        const K = l.morphTargetsRelative ? 1 : 1 - V;
                        c.getUniforms().setValue(A, "morphTargetBaseInfluence", K), c.getUniforms().setValue(A, "morphTargetInfluences", r)
                    }
                }
            }
        }

        function vr(A, e, t, n) {
            let r = new WeakMap;

            function i(A) {
                const e = A.target;
                e.removeEventListener("dispose", i), t.remove(e.instanceMatrix), null !== e.instanceColor && t.remove(e.instanceColor)
            }

            return {
                update: function (a) {
                    const s = n.render.frame, o = a.geometry, l = e.get(a, o);
                    if (r.get(l) !== s && (e.update(l), r.set(l, s)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", i) && a.addEventListener("dispose", i), r.get(a) !== s && (t.update(a.instanceMatrix, A.ARRAY_BUFFER), null !== a.instanceColor && t.update(a.instanceColor, A.ARRAY_BUFFER), r.set(a, s))), a.isSkinnedMesh) {
                        const A = a.skeleton;
                        r.get(A) !== s && (A.update(), r.set(A, s))
                    }
                    return l
                }, dispose: function () {
                    r = new WeakMap
                }
            }
        }

        class _r extends ne {
            constructor(A, e, t, n, r, i, a, s, o, l) {
                if ((l = void 0 !== l ? l : $) !== $ && l !== AA) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === t && l === $ && (t = Y), void 0 === t && l === AA && (t = Z), super(null, n, r, i, a, s, l, t, o), this.isDepthTexture = !0, this.image = {
                    width: A,
                    height: e
                }, this.magFilter = void 0 !== a ? a : G, this.minFilter = void 0 !== s ? s : G, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
            }

            copy(A) {
                return super.copy(A), this.compareFunction = A.compareFunction, this
            }

            toJSON(A) {
                const e = super.toJSON(A);
                return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
            }
        }

        const Cr = new ne, Er = new _r(1, 1);
        Er.compareFunction = 515;
        const Ur = new se, yr = new oe, xr = new Mn, Mr = [], Fr = [], Sr = new Float32Array(16),
            br = new Float32Array(9), Qr = new Float32Array(4);

        function Tr(A, e, t) {
            const n = A[0];
            if (n <= 0 || n > 0) return A;
            const r = e * t;
            let i = Mr[r];
            if (void 0 === i && (i = new Float32Array(r), Mr[r] = i), 0 !== e) {
                n.toArray(i, 0);
                for (let n = 1, r = 0; n !== e; ++n) r += t, A[n].toArray(i, r)
            }
            return i
        }

        function Ir(A, e) {
            if (A.length !== e.length) return !1;
            for (let t = 0, n = A.length; t < n; t++) if (A[t] !== e[t]) return !1;
            return !0
        }

        function Lr(A, e) {
            for (let t = 0, n = e.length; t < n; t++) A[t] = e[t]
        }

        function Rr(A, e) {
            let t = Fr[e];
            void 0 === t && (t = new Int32Array(e), Fr[e] = t);
            for (let n = 0; n !== e; ++n) t[n] = A.allocateTextureUnit();
            return t
        }

        function Hr(A, e) {
            const t = this.cache;
            t[0] !== e && (A.uniform1f(this.addr, e), t[0] = e)
        }

        function Dr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y || (A.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else {
                if (Ir(t, e)) return;
                A.uniform2fv(this.addr, e), Lr(t, e)
            }
        }

        function Pr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y && t[2] === e.z || (A.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else if (void 0 !== e.r) t[0] === e.r && t[1] === e.g && t[2] === e.b || (A.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b); else {
                if (Ir(t, e)) return;
                A.uniform3fv(this.addr, e), Lr(t, e)
            }
        }

        function Nr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (A.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else {
                if (Ir(t, e)) return;
                A.uniform4fv(this.addr, e), Lr(t, e)
            }
        }

        function Or(A, e) {
            const t = this.cache, n = e.elements;
            if (void 0 === n) {
                if (Ir(t, e)) return;
                A.uniformMatrix2fv(this.addr, !1, e), Lr(t, e)
            } else {
                if (Ir(t, n)) return;
                Qr.set(n), A.uniformMatrix2fv(this.addr, !1, Qr), Lr(t, n)
            }
        }

        function Gr(A, e) {
            const t = this.cache, n = e.elements;
            if (void 0 === n) {
                if (Ir(t, e)) return;
                A.uniformMatrix3fv(this.addr, !1, e), Lr(t, e)
            } else {
                if (Ir(t, n)) return;
                br.set(n), A.uniformMatrix3fv(this.addr, !1, br), Lr(t, n)
            }
        }

        function Vr(A, e) {
            const t = this.cache, n = e.elements;
            if (void 0 === n) {
                if (Ir(t, e)) return;
                A.uniformMatrix4fv(this.addr, !1, e), Lr(t, e)
            } else {
                if (Ir(t, n)) return;
                Sr.set(n), A.uniformMatrix4fv(this.addr, !1, Sr), Lr(t, n)
            }
        }

        function Kr(A, e) {
            const t = this.cache;
            t[0] !== e && (A.uniform1i(this.addr, e), t[0] = e)
        }

        function kr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y || (A.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else {
                if (Ir(t, e)) return;
                A.uniform2iv(this.addr, e), Lr(t, e)
            }
        }

        function zr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y && t[2] === e.z || (A.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else {
                if (Ir(t, e)) return;
                A.uniform3iv(this.addr, e), Lr(t, e)
            }
        }

        function Wr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (A.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else {
                if (Ir(t, e)) return;
                A.uniform4iv(this.addr, e), Lr(t, e)
            }
        }

        function Xr(A, e) {
            const t = this.cache;
            t[0] !== e && (A.uniform1ui(this.addr, e), t[0] = e)
        }

        function Yr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y || (A.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else {
                if (Ir(t, e)) return;
                A.uniform2uiv(this.addr, e), Lr(t, e)
            }
        }

        function Jr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y && t[2] === e.z || (A.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else {
                if (Ir(t, e)) return;
                A.uniform3uiv(this.addr, e), Lr(t, e)
            }
        }

        function jr(A, e) {
            const t = this.cache;
            if (void 0 !== e.x) t[0] === e.x && t[1] === e.y && t[2] === e.z && t[3] === e.w || (A.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else {
                if (Ir(t, e)) return;
                A.uniform4uiv(this.addr, e), Lr(t, e)
            }
        }

        function Zr(A, e, t) {
            const n = this.cache, r = t.allocateTextureUnit();
            n[0] !== r && (A.uniform1i(this.addr, r), n[0] = r);
            const i = this.type === A.SAMPLER_2D_SHADOW ? Er : Cr;
            t.setTexture2D(e || i, r)
        }

        function qr(A, e, t) {
            const n = this.cache, r = t.allocateTextureUnit();
            n[0] !== r && (A.uniform1i(this.addr, r), n[0] = r), t.setTexture3D(e || yr, r)
        }

        function $r(A, e, t) {
            const n = this.cache, r = t.allocateTextureUnit();
            n[0] !== r && (A.uniform1i(this.addr, r), n[0] = r), t.setTextureCube(e || xr, r)
        }

        function Ai(A, e, t) {
            const n = this.cache, r = t.allocateTextureUnit();
            n[0] !== r && (A.uniform1i(this.addr, r), n[0] = r), t.setTexture2DArray(e || Ur, r)
        }

        function ei(A, e) {
            A.uniform1fv(this.addr, e)
        }

        function ti(A, e) {
            const t = Tr(e, this.size, 2);
            A.uniform2fv(this.addr, t)
        }

        function ni(A, e) {
            const t = Tr(e, this.size, 3);
            A.uniform3fv(this.addr, t)
        }

        function ri(A, e) {
            const t = Tr(e, this.size, 4);
            A.uniform4fv(this.addr, t)
        }

        function ii(A, e) {
            const t = Tr(e, this.size, 4);
            A.uniformMatrix2fv(this.addr, !1, t)
        }

        function ai(A, e) {
            const t = Tr(e, this.size, 9);
            A.uniformMatrix3fv(this.addr, !1, t)
        }

        function si(A, e) {
            const t = Tr(e, this.size, 16);
            A.uniformMatrix4fv(this.addr, !1, t)
        }

        function oi(A, e) {
            A.uniform1iv(this.addr, e)
        }

        function li(A, e) {
            A.uniform2iv(this.addr, e)
        }

        function ci(A, e) {
            A.uniform3iv(this.addr, e)
        }

        function ui(A, e) {
            A.uniform4iv(this.addr, e)
        }

        function hi(A, e) {
            A.uniform1uiv(this.addr, e)
        }

        function di(A, e) {
            A.uniform2uiv(this.addr, e)
        }

        function pi(A, e) {
            A.uniform3uiv(this.addr, e)
        }

        function fi(A, e) {
            A.uniform4uiv(this.addr, e)
        }

        function gi(A, e, t) {
            const n = this.cache, r = e.length, i = Rr(t, r);
            Ir(n, i) || (A.uniform1iv(this.addr, i), Lr(n, i));
            for (let A = 0; A !== r; ++A) t.setTexture2D(e[A] || Cr, i[A])
        }

        function mi(A, e, t) {
            const n = this.cache, r = e.length, i = Rr(t, r);
            Ir(n, i) || (A.uniform1iv(this.addr, i), Lr(n, i));
            for (let A = 0; A !== r; ++A) t.setTexture3D(e[A] || yr, i[A])
        }

        function Bi(A, e, t) {
            const n = this.cache, r = e.length, i = Rr(t, r);
            Ir(n, i) || (A.uniform1iv(this.addr, i), Lr(n, i));
            for (let A = 0; A !== r; ++A) t.setTextureCube(e[A] || xr, i[A])
        }

        function wi(A, e, t) {
            const n = this.cache, r = e.length, i = Rr(t, r);
            Ir(n, i) || (A.uniform1iv(this.addr, i), Lr(n, i));
            for (let A = 0; A !== r; ++A) t.setTexture2DArray(e[A] || Ur, i[A])
        }

        class vi {
            constructor(A, e, t) {
                this.id = A, this.addr = t, this.cache = [], this.type = e.type, this.setValue = function (A) {
                    switch (A) {
                        case 5126:
                            return Hr;
                        case 35664:
                            return Dr;
                        case 35665:
                            return Pr;
                        case 35666:
                            return Nr;
                        case 35674:
                            return Or;
                        case 35675:
                            return Gr;
                        case 35676:
                            return Vr;
                        case 5124:
                        case 35670:
                            return Kr;
                        case 35667:
                        case 35671:
                            return kr;
                        case 35668:
                        case 35672:
                            return zr;
                        case 35669:
                        case 35673:
                            return Wr;
                        case 5125:
                            return Xr;
                        case 36294:
                            return Yr;
                        case 36295:
                            return Jr;
                        case 36296:
                            return jr;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Zr;
                        case 35679:
                        case 36299:
                        case 36307:
                            return qr;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return $r;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Ai
                    }
                }(e.type)
            }
        }

        class _i {
            constructor(A, e, t) {
                this.id = A, this.addr = t, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = function (A) {
                    switch (A) {
                        case 5126:
                            return ei;
                        case 35664:
                            return ti;
                        case 35665:
                            return ni;
                        case 35666:
                            return ri;
                        case 35674:
                            return ii;
                        case 35675:
                            return ai;
                        case 35676:
                            return si;
                        case 5124:
                        case 35670:
                            return oi;
                        case 35667:
                        case 35671:
                            return li;
                        case 35668:
                        case 35672:
                            return ci;
                        case 35669:
                        case 35673:
                            return ui;
                        case 5125:
                            return hi;
                        case 36294:
                            return di;
                        case 36295:
                            return pi;
                        case 36296:
                            return fi;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return gi;
                        case 35679:
                        case 36299:
                        case 36307:
                            return mi;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Bi;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return wi
                    }
                }(e.type)
            }
        }

        class Ci {
            constructor(A) {
                this.id = A, this.seq = [], this.map = {}
            }

            setValue(A, e, t) {
                const n = this.seq;
                for (let r = 0, i = n.length; r !== i; ++r) {
                    const i = n[r];
                    i.setValue(A, e[i.id], t)
                }
            }
        }

        const Ei = /(\w+)(\])?(\[|\.)?/g;

        function Ui(A, e) {
            A.seq.push(e), A.map[e.id] = e
        }

        function yi(A, e, t) {
            const n = A.name, r = n.length;
            for (Ei.lastIndex = 0; ;) {
                const i = Ei.exec(n), a = Ei.lastIndex;
                let s = i[1];
                const o = "]" === i[2], l = i[3];
                if (o && (s |= 0), void 0 === l || "[" === l && a + 2 === r) {
                    Ui(t, void 0 === l ? new vi(s, A, e) : new _i(s, A, e));
                    break
                }
                {
                    let A = t.map[s];
                    void 0 === A && (A = new Ci(s), Ui(t, A)), t = A
                }
            }
        }

        class xi {
            constructor(A, e) {
                this.seq = [], this.map = {};
                const t = A.getProgramParameter(e, A.ACTIVE_UNIFORMS);
                for (let n = 0; n < t; ++n) {
                    const t = A.getActiveUniform(e, n);
                    yi(t, A.getUniformLocation(e, t.name), this)
                }
            }

            setValue(A, e, t, n) {
                const r = this.map[e];
                void 0 !== r && r.setValue(A, t, n)
            }

            setOptional(A, e, t) {
                const n = e[t];
                void 0 !== n && this.setValue(A, t, n)
            }

            static upload(A, e, t, n) {
                for (let r = 0, i = e.length; r !== i; ++r) {
                    const i = e[r], a = t[i.id];
                    !1 !== a.needsUpdate && i.setValue(A, a.value, n)
                }
            }

            static seqWithValue(A, e) {
                const t = [];
                for (let n = 0, r = A.length; n !== r; ++n) {
                    const r = A[n];
                    r.id in e && t.push(r)
                }
                return t
            }
        }

        function Mi(A, e, t) {
            const n = A.createShader(e);
            return A.shaderSource(n, t), A.compileShader(n), n
        }

        const Fi = 37297;
        let Si = 0;

        function bi(A, e, t) {
            const n = A.getShaderParameter(e, A.COMPILE_STATUS), r = A.getShaderInfoLog(e).trim();
            if (n && "" === r) return "";
            const i = /ERROR: 0:(\d+)/.exec(r);
            if (i) {
                const n = parseInt(i[1]);
                return t.toUpperCase() + "\n\n" + r + "\n\n" + function (A, e) {
                    const t = A.split("\n"), n = [], r = Math.max(e - 6, 0), i = Math.min(e + 6, t.length);
                    for (let A = r; A < i; A++) {
                        const r = A + 1;
                        n.push(`${r === e ? ">" : " "} ${r}: ${t[A]}`)
                    }
                    return n.join("\n")
                }(A.getShaderSource(e), n)
            }
            return r
        }

        function Qi(A, e) {
            const t = function (A) {
                const e = YA.getPrimaries(YA.workingColorSpace), t = YA.getPrimaries(A);
                let n;
                switch (e === t ? n = "" : e === mA && t === gA ? n = "LinearDisplayP3ToLinearSRGB" : e === gA && t === mA && (n = "LinearSRGBToLinearDisplayP3"), A) {
                    case uA:
                    case dA:
                        return [n, "LinearTransferOETF"];
                    case cA:
                    case hA:
                        return [n, "sRGBTransferOETF"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space:", A), [n, "LinearTransferOETF"]
                }
            }(e);
            return `vec4 ${A}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
        }

        function Ti(A, e) {
            let t;
            switch (e) {
                case F:
                    t = "Linear";
                    break;
                case S:
                    t = "Reinhard";
                    break;
                case b:
                    t = "OptimizedCineon";
                    break;
                case Q:
                    t = "ACESFilmic";
                    break;
                case I:
                    t = "AgX";
                    break;
                case L:
                    t = "Neutral";
                    break;
                case T:
                    t = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
            }
            return "vec3 " + A + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
        }

        function Ii(A) {
            return "" !== A
        }

        function Li(A, e) {
            const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return A.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Ri(A, e) {
            return A.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }

        const Hi = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Di(A) {
            return A.replace(Hi, Ni)
        }

        const Pi = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);

        function Ni(A, e) {
            let t = Nn[e];
            if (void 0 === t) {
                const A = Pi.get(e);
                if (void 0 === A) throw new Error("Can not resolve #include <" + e + ">");
                t = Nn[A], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, A)
            }
            return Di(t)
        }

        const Oi = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Gi(A) {
            return A.replace(Oi, Vi)
        }

        function Vi(A, e, t, n) {
            let r = "";
            for (let A = parseInt(e); A < parseInt(t); A++) r += n.replace(/\[\s*i\s*\]/g, "[ " + A + " ]").replace(/UNROLLED_LOOP_INDEX/g, A);
            return r
        }

        function Ki(A) {
            let e = `precision ${A.precision} float;\n\tprecision ${A.precision} int;\n\tprecision ${A.precision} sampler2D;\n\tprecision ${A.precision} samplerCube;\n\t`;
            return A.isWebGL2 && (e += `precision ${A.precision} sampler3D;\n\t\tprecision ${A.precision} sampler2DArray;\n\t\tprecision ${A.precision} sampler2DShadow;\n\t\tprecision ${A.precision} samplerCubeShadow;\n\t\tprecision ${A.precision} sampler2DArrayShadow;\n\t\tprecision ${A.precision} isampler2D;\n\t\tprecision ${A.precision} isampler3D;\n\t\tprecision ${A.precision} isamplerCube;\n\t\tprecision ${A.precision} isampler2DArray;\n\t\tprecision ${A.precision} usampler2D;\n\t\tprecision ${A.precision} usampler3D;\n\t\tprecision ${A.precision} usamplerCube;\n\t\tprecision ${A.precision} usampler2DArray;\n\t\t`), "highp" === A.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === A.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === A.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function ki(A, e, t, n) {
            const r = A.getContext(), i = t.defines;
            let a = t.vertexShader, s = t.fragmentShader;
            const o = function (A) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return A.shadowMapType === v ? e = "SHADOWMAP_TYPE_PCF" : A.shadowMapType === _ ? e = "SHADOWMAP_TYPE_PCF_SOFT" : A.shadowMapType === C && (e = "SHADOWMAP_TYPE_VSM"), e
            }(t), l = function (A) {
                let e = "ENVMAP_TYPE_CUBE";
                if (A.envMap) switch (A.envMapMode) {
                    case R:
                    case H:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case D:
                        e = "ENVMAP_TYPE_CUBE_UV"
                }
                return e
            }(t), c = function (A) {
                let e = "ENVMAP_MODE_REFLECTION";
                return A.envMap && A.envMapMode === H && (e = "ENVMAP_MODE_REFRACTION"), e
            }(t), u = function (A) {
                let e = "ENVMAP_BLENDING_NONE";
                if (A.envMap) switch (A.combine) {
                    case U:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case y:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case x:
                        e = "ENVMAP_BLENDING_ADD"
                }
                return e
            }(t), h = function (A) {
                const e = A.envMapCubeUVHeight;
                if (null === e) return null;
                const t = Math.log2(e) - 2, n = 1 / e;
                return {texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)), texelHeight: n, maxMip: t}
            }(t), d = t.isWebGL2 ? "" : function (A) {
                return [A.extensionDerivatives || A.envMapCubeUVHeight || A.bumpMap || A.normalMapTangentSpace || A.clearcoatNormalMap || A.flatShading || A.alphaToCoverage || "physical" === A.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (A.extensionFragDepth || A.logarithmicDepthBuffer) && A.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", A.extensionDrawBuffers && A.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (A.extensionShaderTextureLOD || A.envMap || A.transmission) && A.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ii).join("\n")
            }(t), p = function (A) {
                return [A.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", A.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Ii).join("\n")
            }(t), f = function (A) {
                const e = [];
                for (const t in A) {
                    const n = A[t];
                    !1 !== n && e.push("#define " + t + " " + n)
                }
                return e.join("\n")
            }(i), g = r.createProgram();
            let m, B, w = t.glslVersion ? "#version " + t.glslVersion + "\n" : "";
            t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f].filter(Ii).join("\n"), m.length > 0 && (m += "\n"), B = [d, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f].filter(Ii).join("\n"), B.length > 0 && (B += "\n")) : (m = [Ki(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && !1 === t.flatShading ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && !1 === t.flatShading ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + o : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ii).join("\n"), B = [d, Ki(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, f, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + l : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && !1 === t.flatShading ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + o : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== M ? "#define TONE_MAPPING" : "", t.toneMapping !== M ? Nn.tonemapping_pars_fragment : "", t.toneMapping !== M ? Ti("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Nn.colorspace_pars_fragment, Qi("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", "\n"].filter(Ii).join("\n")), a = Di(a), a = Li(a, t), a = Ri(a, t), s = Di(s), s = Li(s, t), s = Ri(s, t), a = Gi(a), s = Gi(s), t.isWebGL2 && !0 !== t.isRawShaderMaterial && (w = "#version 300 es\n", m = [p, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m, B = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === wA ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === wA ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + B);
            const E = w + m + a, F = w + B + s, S = Mi(r, r.VERTEX_SHADER, E), b = Mi(r, r.FRAGMENT_SHADER, F);

            function Q(e) {
                if (A.debug.checkShaderErrors) {
                    const t = r.getProgramInfoLog(g).trim(), n = r.getShaderInfoLog(S).trim(),
                        i = r.getShaderInfoLog(b).trim();
                    let a = !0, s = !0;
                    if (!1 === r.getProgramParameter(g, r.LINK_STATUS)) if (a = !1, "function" == typeof A.debug.onShaderError) A.debug.onShaderError(r, g, S, b); else {
                        const A = bi(r, S, "vertex"), n = bi(r, b, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + e.name + "\nMaterial Type: " + e.type + "\n\nProgram Info Log: " + t + "\n" + A + "\n" + n)
                    } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== n && "" !== i || (s = !1);
                    s && (e.diagnostics = {
                        runnable: a,
                        programLog: t,
                        vertexShader: {log: n, prefix: m},
                        fragmentShader: {log: i, prefix: B}
                    })
                }
                r.deleteShader(S), r.deleteShader(b), T = new xi(r, g), I = function (A, e) {
                    const t = {}, n = A.getProgramParameter(e, A.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < n; r++) {
                        const n = A.getActiveAttrib(e, r), i = n.name;
                        let a = 1;
                        n.type === A.FLOAT_MAT2 && (a = 2), n.type === A.FLOAT_MAT3 && (a = 3), n.type === A.FLOAT_MAT4 && (a = 4), t[i] = {
                            type: n.type,
                            location: A.getAttribLocation(e, i),
                            locationSize: a
                        }
                    }
                    return t
                }(r, g)
            }

            let T, I;
            r.attachShader(g, S), r.attachShader(g, b), void 0 !== t.index0AttributeName ? r.bindAttribLocation(g, 0, t.index0AttributeName) : !0 === t.morphTargets && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g), this.getUniforms = function () {
                return void 0 === T && Q(this), T
            }, this.getAttributes = function () {
                return void 0 === I && Q(this), I
            };
            let L = !1 === t.rendererExtensionParallelShaderCompile;
            return this.isReady = function () {
                return !1 === L && (L = r.getProgramParameter(g, Fi)), L
            }, this.destroy = function () {
                n.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0
            }, this.type = t.shaderType, this.name = t.shaderName, this.id = Si++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = S, this.fragmentShader = b, this
        }

        let zi = 0;

        class Wi {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }

            update(A) {
                const e = A.vertexShader, t = A.fragmentShader, n = this._getShaderStage(e),
                    r = this._getShaderStage(t), i = this._getShaderCacheForMaterial(A);
                return !1 === i.has(n) && (i.add(n), n.usedTimes++), !1 === i.has(r) && (i.add(r), r.usedTimes++), this
            }

            remove(A) {
                const e = this.materialCache.get(A);
                for (const A of e) A.usedTimes--, 0 === A.usedTimes && this.shaderCache.delete(A.code);
                return this.materialCache.delete(A), this
            }

            getVertexShaderID(A) {
                return this._getShaderStage(A.vertexShader).id
            }

            getFragmentShaderID(A) {
                return this._getShaderStage(A.fragmentShader).id
            }

            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }

            _getShaderCacheForMaterial(A) {
                const e = this.materialCache;
                let t = e.get(A);
                return void 0 === t && (t = new Set, e.set(A, t)), t
            }

            _getShaderStage(A) {
                const e = this.shaderCache;
                let t = e.get(A);
                return void 0 === t && (t = new Xi(A), e.set(A, t)), t
            }
        }

        class Xi {
            constructor(A) {
                this.id = zi++, this.code = A, this.usedTimes = 0
            }
        }

        function Yi(A, e, t, n, r, i, a) {
            const s = new Ze, o = new Wi, l = new Set, c = [], u = r.isWebGL2, h = r.logarithmicDepthBuffer,
                d = r.vertexTextures;
            let p = r.precision;
            const f = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };

            function g(A) {
                return l.add(A), 0 === A ? "uv" : `uv${A}`
            }

            return {
                getParameters: function (i, s, c, m, B) {
                    const w = m.fog, v = B.geometry, _ = i.isMeshStandardMaterial ? m.environment : null,
                        C = (i.isMeshStandardMaterial ? t : e).get(i.envMap || _),
                        E = C && C.mapping === D ? C.image.height : null, U = f[i.type];
                    null !== i.precision && (p = r.getMaxPrecision(i.precision), p !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", p, "instead."));
                    const y = v.morphAttributes.position || v.morphAttributes.normal || v.morphAttributes.color,
                        x = void 0 !== y ? y.length : 0;
                    let F, S, b, Q, T = 0;
                    if (void 0 !== v.morphAttributes.position && (T = 1), void 0 !== v.morphAttributes.normal && (T = 2), void 0 !== v.morphAttributes.color && (T = 3), U) {
                        const A = Gn[U];
                        F = A.vertexShader, S = A.fragmentShader
                    } else F = i.vertexShader, S = i.fragmentShader, o.update(i), b = o.getVertexShaderID(i), Q = o.getFragmentShaderID(i);
                    const I = A.getRenderTarget(), L = !0 === B.isInstancedMesh, R = !0 === B.isBatchedMesh,
                        H = !!i.map, P = !!i.matcap, N = !!C, O = !!i.aoMap, G = !!i.lightMap, V = !!i.bumpMap,
                        K = !!i.normalMap, k = !!i.displacementMap, z = !!i.emissiveMap, W = !!i.metalnessMap,
                        X = !!i.roughnessMap, Y = i.anisotropy > 0, J = i.clearcoat > 0, j = i.iridescence > 0,
                        Z = i.sheen > 0, q = i.transmission > 0, $ = Y && !!i.anisotropyMap, AA = J && !!i.clearcoatMap,
                        eA = J && !!i.clearcoatNormalMap, tA = J && !!i.clearcoatRoughnessMap,
                        nA = j && !!i.iridescenceMap, rA = j && !!i.iridescenceThicknessMap,
                        iA = Z && !!i.sheenColorMap, aA = Z && !!i.sheenRoughnessMap, sA = !!i.specularMap,
                        oA = !!i.specularColorMap, lA = !!i.specularIntensityMap, cA = q && !!i.transmissionMap,
                        hA = q && !!i.thicknessMap, dA = !!i.gradientMap, pA = !!i.alphaMap, gA = i.alphaTest > 0,
                        mA = !!i.alphaHash, BA = !!i.extensions;
                    let wA = M;
                    i.toneMapped && (null !== I && !0 !== I.isXRRenderTarget || (wA = A.toneMapping));
                    const vA = {
                        isWebGL2: u,
                        shaderID: U,
                        shaderType: i.type,
                        shaderName: i.name,
                        vertexShader: F,
                        fragmentShader: S,
                        defines: i.defines,
                        customVertexShaderID: b,
                        customFragmentShaderID: Q,
                        isRawShaderMaterial: !0 === i.isRawShaderMaterial,
                        glslVersion: i.glslVersion,
                        precision: p,
                        batching: R,
                        instancing: L,
                        instancingColor: L && null !== B.instanceColor,
                        instancingMorph: L && null !== B.morphTexture,
                        supportsVertexTextures: d,
                        outputColorSpace: null === I ? A.outputColorSpace : !0 === I.isXRRenderTarget ? I.texture.colorSpace : uA,
                        alphaToCoverage: !!i.alphaToCoverage,
                        map: H,
                        matcap: P,
                        envMap: N,
                        envMapMode: N && C.mapping,
                        envMapCubeUVHeight: E,
                        aoMap: O,
                        lightMap: G,
                        bumpMap: V,
                        normalMap: K,
                        displacementMap: d && k,
                        emissiveMap: z,
                        normalMapObjectSpace: K && 1 === i.normalMapType,
                        normalMapTangentSpace: K && 0 === i.normalMapType,
                        metalnessMap: W,
                        roughnessMap: X,
                        anisotropy: Y,
                        anisotropyMap: $,
                        clearcoat: J,
                        clearcoatMap: AA,
                        clearcoatNormalMap: eA,
                        clearcoatRoughnessMap: tA,
                        iridescence: j,
                        iridescenceMap: nA,
                        iridescenceThicknessMap: rA,
                        sheen: Z,
                        sheenColorMap: iA,
                        sheenRoughnessMap: aA,
                        specularMap: sA,
                        specularColorMap: oA,
                        specularIntensityMap: lA,
                        transmission: q,
                        transmissionMap: cA,
                        thicknessMap: hA,
                        gradientMap: dA,
                        opaque: !1 === i.transparent && 1 === i.blending && !1 === i.alphaToCoverage,
                        alphaMap: pA,
                        alphaTest: gA,
                        alphaHash: mA,
                        combine: i.combine,
                        mapUv: H && g(i.map.channel),
                        aoMapUv: O && g(i.aoMap.channel),
                        lightMapUv: G && g(i.lightMap.channel),
                        bumpMapUv: V && g(i.bumpMap.channel),
                        normalMapUv: K && g(i.normalMap.channel),
                        displacementMapUv: k && g(i.displacementMap.channel),
                        emissiveMapUv: z && g(i.emissiveMap.channel),
                        metalnessMapUv: W && g(i.metalnessMap.channel),
                        roughnessMapUv: X && g(i.roughnessMap.channel),
                        anisotropyMapUv: $ && g(i.anisotropyMap.channel),
                        clearcoatMapUv: AA && g(i.clearcoatMap.channel),
                        clearcoatNormalMapUv: eA && g(i.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: tA && g(i.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: nA && g(i.iridescenceMap.channel),
                        iridescenceThicknessMapUv: rA && g(i.iridescenceThicknessMap.channel),
                        sheenColorMapUv: iA && g(i.sheenColorMap.channel),
                        sheenRoughnessMapUv: aA && g(i.sheenRoughnessMap.channel),
                        specularMapUv: sA && g(i.specularMap.channel),
                        specularColorMapUv: oA && g(i.specularColorMap.channel),
                        specularIntensityMapUv: lA && g(i.specularIntensityMap.channel),
                        transmissionMapUv: cA && g(i.transmissionMap.channel),
                        thicknessMapUv: hA && g(i.thicknessMap.channel),
                        alphaMapUv: pA && g(i.alphaMap.channel),
                        vertexTangents: !!v.attributes.tangent && (K || Y),
                        vertexColors: i.vertexColors,
                        vertexAlphas: !0 === i.vertexColors && !!v.attributes.color && 4 === v.attributes.color.itemSize,
                        pointsUvs: !0 === B.isPoints && !!v.attributes.uv && (H || pA),
                        fog: !!w,
                        useFog: !0 === i.fog,
                        fogExp2: !!w && w.isFogExp2,
                        flatShading: !0 === i.flatShading,
                        sizeAttenuation: !0 === i.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === B.isSkinnedMesh,
                        morphTargets: void 0 !== v.morphAttributes.position,
                        morphNormals: void 0 !== v.morphAttributes.normal,
                        morphColors: void 0 !== v.morphAttributes.color,
                        morphTargetsCount: x,
                        morphTextureStride: T,
                        numDirLights: s.directional.length,
                        numPointLights: s.point.length,
                        numSpotLights: s.spot.length,
                        numSpotLightMaps: s.spotLightMap.length,
                        numRectAreaLights: s.rectArea.length,
                        numHemiLights: s.hemi.length,
                        numDirLightShadows: s.directionalShadowMap.length,
                        numPointLightShadows: s.pointShadowMap.length,
                        numSpotLightShadows: s.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                        numLightProbes: s.numLightProbes,
                        numClippingPlanes: a.numPlanes,
                        numClipIntersection: a.numIntersection,
                        dithering: i.dithering,
                        shadowMapEnabled: A.shadowMap.enabled && c.length > 0,
                        shadowMapType: A.shadowMap.type,
                        toneMapping: wA,
                        useLegacyLights: A._useLegacyLights,
                        decodeVideoTexture: H && !0 === i.map.isVideoTexture && YA.getTransfer(i.map.colorSpace) === fA,
                        premultipliedAlpha: i.premultipliedAlpha,
                        doubleSided: 2 === i.side,
                        flipSided: 1 === i.side,
                        useDepthPacking: i.depthPacking >= 0,
                        depthPacking: i.depthPacking || 0,
                        index0AttributeName: i.index0AttributeName,
                        extensionDerivatives: BA && !0 === i.extensions.derivatives,
                        extensionFragDepth: BA && !0 === i.extensions.fragDepth,
                        extensionDrawBuffers: BA && !0 === i.extensions.drawBuffers,
                        extensionShaderTextureLOD: BA && !0 === i.extensions.shaderTextureLOD,
                        extensionClipCullDistance: BA && !0 === i.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"),
                        extensionMultiDraw: BA && !0 === i.extensions.multiDraw && n.has("WEBGL_multi_draw"),
                        rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
                        rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: i.customProgramCacheKey()
                    };
                    return vA.vertexUv1s = l.has(1), vA.vertexUv2s = l.has(2), vA.vertexUv3s = l.has(3), l.clear(), vA
                }, getProgramCacheKey: function (e) {
                    const t = [];
                    if (e.shaderID ? t.push(e.shaderID) : (t.push(e.customVertexShaderID), t.push(e.customFragmentShaderID)), void 0 !== e.defines) for (const A in e.defines) t.push(A), t.push(e.defines[A]);
                    return !1 === e.isRawShaderMaterial && (function (A, e) {
                        A.push(e.precision), A.push(e.outputColorSpace), A.push(e.envMapMode), A.push(e.envMapCubeUVHeight), A.push(e.mapUv), A.push(e.alphaMapUv), A.push(e.lightMapUv), A.push(e.aoMapUv), A.push(e.bumpMapUv), A.push(e.normalMapUv), A.push(e.displacementMapUv), A.push(e.emissiveMapUv), A.push(e.metalnessMapUv), A.push(e.roughnessMapUv), A.push(e.anisotropyMapUv), A.push(e.clearcoatMapUv), A.push(e.clearcoatNormalMapUv), A.push(e.clearcoatRoughnessMapUv), A.push(e.iridescenceMapUv), A.push(e.iridescenceThicknessMapUv), A.push(e.sheenColorMapUv), A.push(e.sheenRoughnessMapUv), A.push(e.specularMapUv), A.push(e.specularColorMapUv), A.push(e.specularIntensityMapUv), A.push(e.transmissionMapUv), A.push(e.thicknessMapUv), A.push(e.combine), A.push(e.fogExp2), A.push(e.sizeAttenuation), A.push(e.morphTargetsCount), A.push(e.morphAttributeCount), A.push(e.numDirLights), A.push(e.numPointLights), A.push(e.numSpotLights), A.push(e.numSpotLightMaps), A.push(e.numHemiLights), A.push(e.numRectAreaLights), A.push(e.numDirLightShadows), A.push(e.numPointLightShadows), A.push(e.numSpotLightShadows), A.push(e.numSpotLightShadowsWithMaps), A.push(e.numLightProbes), A.push(e.shadowMapType), A.push(e.toneMapping), A.push(e.numClippingPlanes), A.push(e.numClipIntersection), A.push(e.depthPacking)
                    }(t, e), function (A, e) {
                        s.disableAll(), e.isWebGL2 && s.enable(0), e.supportsVertexTextures && s.enable(1), e.instancing && s.enable(2), e.instancingColor && s.enable(3), e.instancingMorph && s.enable(4), e.matcap && s.enable(5), e.envMap && s.enable(6), e.normalMapObjectSpace && s.enable(7), e.normalMapTangentSpace && s.enable(8), e.clearcoat && s.enable(9), e.iridescence && s.enable(10), e.alphaTest && s.enable(11), e.vertexColors && s.enable(12), e.vertexAlphas && s.enable(13), e.vertexUv1s && s.enable(14), e.vertexUv2s && s.enable(15), e.vertexUv3s && s.enable(16), e.vertexTangents && s.enable(17), e.anisotropy && s.enable(18), e.alphaHash && s.enable(19), e.batching && s.enable(20), A.push(s.mask), s.disableAll(), e.fog && s.enable(0), e.useFog && s.enable(1), e.flatShading && s.enable(2), e.logarithmicDepthBuffer && s.enable(3), e.skinning && s.enable(4), e.morphTargets && s.enable(5), e.morphNormals && s.enable(6), e.morphColors && s.enable(7), e.premultipliedAlpha && s.enable(8), e.shadowMapEnabled && s.enable(9), e.useLegacyLights && s.enable(10), e.doubleSided && s.enable(11), e.flipSided && s.enable(12), e.useDepthPacking && s.enable(13), e.dithering && s.enable(14), e.transmission && s.enable(15), e.sheen && s.enable(16), e.opaque && s.enable(17), e.pointsUvs && s.enable(18), e.decodeVideoTexture && s.enable(19), e.alphaToCoverage && s.enable(20), A.push(s.mask)
                    }(t, e), t.push(A.outputColorSpace)), t.push(e.customProgramCacheKey), t.join()
                }, getUniforms: function (A) {
                    const e = f[A.type];
                    let t;
                    if (e) {
                        const A = Gn[e];
                        t = Bn.clone(A.uniforms)
                    } else t = A.uniforms;
                    return t
                }, acquireProgram: function (e, t) {
                    let n;
                    for (let A = 0, e = c.length; A < e; A++) {
                        const e = c[A];
                        if (e.cacheKey === t) {
                            n = e, ++n.usedTimes;
                            break
                        }
                    }
                    return void 0 === n && (n = new ki(A, t, e, i), c.push(n)), n
                }, releaseProgram: function (A) {
                    if (0 == --A.usedTimes) {
                        const e = c.indexOf(A);
                        c[e] = c[c.length - 1], c.pop(), A.destroy()
                    }
                }, releaseShaderCache: function (A) {
                    o.remove(A)
                }, programs: c, dispose: function () {
                    o.dispose()
                }
            }
        }

        function Ji() {
            let A = new WeakMap;
            return {
                get: function (e) {
                    let t = A.get(e);
                    return void 0 === t && (t = {}, A.set(e, t)), t
                }, remove: function (e) {
                    A.delete(e)
                }, update: function (e, t, n) {
                    A.get(e)[t] = n
                }, dispose: function () {
                    A = new WeakMap
                }
            }
        }

        function ji(A, e) {
            return A.groupOrder !== e.groupOrder ? A.groupOrder - e.groupOrder : A.renderOrder !== e.renderOrder ? A.renderOrder - e.renderOrder : A.material.id !== e.material.id ? A.material.id - e.material.id : A.z !== e.z ? A.z - e.z : A.id - e.id
        }

        function Zi(A, e) {
            return A.groupOrder !== e.groupOrder ? A.groupOrder - e.groupOrder : A.renderOrder !== e.renderOrder ? A.renderOrder - e.renderOrder : A.z !== e.z ? e.z - A.z : A.id - e.id
        }

        function qi() {
            const A = [];
            let e = 0;
            const t = [], n = [], r = [];

            function i(t, n, r, i, a, s) {
                let o = A[e];
                return void 0 === o ? (o = {
                    id: t.id,
                    object: t,
                    geometry: n,
                    material: r,
                    groupOrder: i,
                    renderOrder: t.renderOrder,
                    z: a,
                    group: s
                }, A[e] = o) : (o.id = t.id, o.object = t, o.geometry = n, o.material = r, o.groupOrder = i, o.renderOrder = t.renderOrder, o.z = a, o.group = s), e++, o
            }

            return {
                opaque: t, transmissive: n, transparent: r, init: function () {
                    e = 0, t.length = 0, n.length = 0, r.length = 0
                }, push: function (A, e, a, s, o, l) {
                    const c = i(A, e, a, s, o, l);
                    a.transmission > 0 ? n.push(c) : !0 === a.transparent ? r.push(c) : t.push(c)
                }, unshift: function (A, e, a, s, o, l) {
                    const c = i(A, e, a, s, o, l);
                    a.transmission > 0 ? n.unshift(c) : !0 === a.transparent ? r.unshift(c) : t.unshift(c)
                }, finish: function () {
                    for (let t = e, n = A.length; t < n; t++) {
                        const e = A[t];
                        if (null === e.id) break;
                        e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                    }
                }, sort: function (A, e) {
                    t.length > 1 && t.sort(A || ji), n.length > 1 && n.sort(e || Zi), r.length > 1 && r.sort(e || Zi)
                }
            }
        }

        function $i() {
            let A = new WeakMap;
            return {
                get: function (e, t) {
                    const n = A.get(e);
                    let r;
                    return void 0 === n ? (r = new qi, A.set(e, [r])) : t >= n.length ? (r = new qi, n.push(r)) : r = n[t], r
                }, dispose: function () {
                    A = new WeakMap
                }
            }
        }

        function Aa() {
            const A = {};
            return {
                get: function (e) {
                    if (void 0 !== A[e.id]) return A[e.id];
                    let t;
                    switch (e.type) {
                        case"DirectionalLight":
                            t = {direction: new ce, color: new St};
                            break;
                        case"SpotLight":
                            t = {
                                position: new ce,
                                direction: new ce,
                                color: new St,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case"PointLight":
                            t = {position: new ce, color: new St, distance: 0, decay: 0};
                            break;
                        case"HemisphereLight":
                            t = {direction: new ce, skyColor: new St, groundColor: new St};
                            break;
                        case"RectAreaLight":
                            t = {color: new St, position: new ce, halfWidth: new ce, halfHeight: new ce}
                    }
                    return A[e.id] = t, t
                }
            }
        }

        let ea = 0;

        function ta(A, e) {
            return (e.castShadow ? 2 : 0) - (A.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (A.map ? 1 : 0)
        }

        function na(A, e) {
            const t = new Aa, n = function () {
                const A = {};
                return {
                    get: function (e) {
                        if (void 0 !== A[e.id]) return A[e.id];
                        let t;
                        switch (e.type) {
                            case"DirectionalLight":
                            case"SpotLight":
                                t = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new DA};
                                break;
                            case"PointLight":
                                t = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new DA,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return A[e.id] = t, t
                    }
                }
            }(), r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let A = 0; A < 9; A++) r.probe.push(new ce);
            const i = new ce, a = new Oe, s = new Oe;
            return {
                setup: function (i, a) {
                    let s = 0, o = 0, l = 0;
                    for (let A = 0; A < 9; A++) r.probe[A].set(0, 0, 0);
                    let c = 0, u = 0, h = 0, d = 0, p = 0, f = 0, g = 0, m = 0, B = 0, w = 0, v = 0;
                    i.sort(ta);
                    const _ = !0 === a ? Math.PI : 1;
                    for (let A = 0, e = i.length; A < e; A++) {
                        const e = i[A], a = e.color, C = e.intensity, E = e.distance,
                            U = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) s += a.r * C * _, o += a.g * C * _, l += a.b * C * _; else if (e.isLightProbe) {
                            for (let A = 0; A < 9; A++) r.probe[A].addScaledVector(e.sh.coefficients[A], C);
                            v++
                        } else if (e.isDirectionalLight) {
                            const A = t.get(e);
                            if (A.color.copy(e.color).multiplyScalar(e.intensity * _), e.castShadow) {
                                const A = e.shadow, t = n.get(e);
                                t.shadowBias = A.bias, t.shadowNormalBias = A.normalBias, t.shadowRadius = A.radius, t.shadowMapSize = A.mapSize, r.directionalShadow[c] = t, r.directionalShadowMap[c] = U, r.directionalShadowMatrix[c] = e.shadow.matrix, f++
                            }
                            r.directional[c] = A, c++
                        } else if (e.isSpotLight) {
                            const A = t.get(e);
                            A.position.setFromMatrixPosition(e.matrixWorld), A.color.copy(a).multiplyScalar(C * _), A.distance = E, A.coneCos = Math.cos(e.angle), A.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), A.decay = e.decay, r.spot[h] = A;
                            const i = e.shadow;
                            if (e.map && (r.spotLightMap[B] = e.map, B++, i.updateMatrices(e), e.castShadow && w++), r.spotLightMatrix[h] = i.matrix, e.castShadow) {
                                const A = n.get(e);
                                A.shadowBias = i.bias, A.shadowNormalBias = i.normalBias, A.shadowRadius = i.radius, A.shadowMapSize = i.mapSize, r.spotShadow[h] = A, r.spotShadowMap[h] = U, m++
                            }
                            h++
                        } else if (e.isRectAreaLight) {
                            const A = t.get(e);
                            A.color.copy(a).multiplyScalar(C), A.halfWidth.set(.5 * e.width, 0, 0), A.halfHeight.set(0, .5 * e.height, 0), r.rectArea[d] = A, d++
                        } else if (e.isPointLight) {
                            const A = t.get(e);
                            if (A.color.copy(e.color).multiplyScalar(e.intensity * _), A.distance = e.distance, A.decay = e.decay, e.castShadow) {
                                const A = e.shadow, t = n.get(e);
                                t.shadowBias = A.bias, t.shadowNormalBias = A.normalBias, t.shadowRadius = A.radius, t.shadowMapSize = A.mapSize, t.shadowCameraNear = A.camera.near, t.shadowCameraFar = A.camera.far, r.pointShadow[u] = t, r.pointShadowMap[u] = U, r.pointShadowMatrix[u] = e.shadow.matrix, g++
                            }
                            r.point[u] = A, u++
                        } else if (e.isHemisphereLight) {
                            const A = t.get(e);
                            A.skyColor.copy(e.color).multiplyScalar(C * _), A.groundColor.copy(e.groundColor).multiplyScalar(C * _), r.hemi[p] = A, p++
                        }
                    }
                    d > 0 && (e.isWebGL2 ? !0 === A.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = On.LTC_FLOAT_1, r.rectAreaLTC2 = On.LTC_FLOAT_2) : (r.rectAreaLTC1 = On.LTC_HALF_1, r.rectAreaLTC2 = On.LTC_HALF_2) : !0 === A.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = On.LTC_FLOAT_1, r.rectAreaLTC2 = On.LTC_FLOAT_2) : !0 === A.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = On.LTC_HALF_1, r.rectAreaLTC2 = On.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = s, r.ambient[1] = o, r.ambient[2] = l;
                    const C = r.hash;
                    C.directionalLength === c && C.pointLength === u && C.spotLength === h && C.rectAreaLength === d && C.hemiLength === p && C.numDirectionalShadows === f && C.numPointShadows === g && C.numSpotShadows === m && C.numSpotMaps === B && C.numLightProbes === v || (r.directional.length = c, r.spot.length = h, r.rectArea.length = d, r.point.length = u, r.hemi.length = p, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = m, r.spotShadowMap.length = m, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = m + B - w, r.spotLightMap.length = B, r.numSpotLightShadowsWithMaps = w, r.numLightProbes = v, C.directionalLength = c, C.pointLength = u, C.spotLength = h, C.rectAreaLength = d, C.hemiLength = p, C.numDirectionalShadows = f, C.numPointShadows = g, C.numSpotShadows = m, C.numSpotMaps = B, C.numLightProbes = v, r.version = ea++)
                }, setupView: function (A, e) {
                    let t = 0, n = 0, o = 0, l = 0, c = 0;
                    const u = e.matrixWorldInverse;
                    for (let e = 0, h = A.length; e < h; e++) {
                        const h = A[e];
                        if (h.isDirectionalLight) {
                            const A = r.directional[t];
                            A.direction.setFromMatrixPosition(h.matrixWorld), i.setFromMatrixPosition(h.target.matrixWorld), A.direction.sub(i), A.direction.transformDirection(u), t++
                        } else if (h.isSpotLight) {
                            const A = r.spot[o];
                            A.position.setFromMatrixPosition(h.matrixWorld), A.position.applyMatrix4(u), A.direction.setFromMatrixPosition(h.matrixWorld), i.setFromMatrixPosition(h.target.matrixWorld), A.direction.sub(i), A.direction.transformDirection(u), o++
                        } else if (h.isRectAreaLight) {
                            const A = r.rectArea[l];
                            A.position.setFromMatrixPosition(h.matrixWorld), A.position.applyMatrix4(u), s.identity(), a.copy(h.matrixWorld), a.premultiply(u), s.extractRotation(a), A.halfWidth.set(.5 * h.width, 0, 0), A.halfHeight.set(0, .5 * h.height, 0), A.halfWidth.applyMatrix4(s), A.halfHeight.applyMatrix4(s), l++
                        } else if (h.isPointLight) {
                            const A = r.point[n];
                            A.position.setFromMatrixPosition(h.matrixWorld), A.position.applyMatrix4(u), n++
                        } else if (h.isHemisphereLight) {
                            const A = r.hemi[c];
                            A.direction.setFromMatrixPosition(h.matrixWorld), A.direction.transformDirection(u), c++
                        }
                    }
                }, state: r
            }
        }

        function ra(A, e) {
            const t = new na(A, e), n = [], r = [];
            return {
                init: function () {
                    n.length = 0, r.length = 0
                }, state: {lightsArray: n, shadowsArray: r, lights: t}, setupLights: function (A) {
                    t.setup(n, A)
                }, setupLightsView: function (A) {
                    t.setupView(n, A)
                }, pushLight: function (A) {
                    n.push(A)
                }, pushShadow: function (A) {
                    r.push(A)
                }
            }
        }

        function ia(A, e) {
            let t = new WeakMap;
            return {
                get: function (n, r = 0) {
                    const i = t.get(n);
                    let a;
                    return void 0 === i ? (a = new ra(A, e), t.set(n, [a])) : r >= i.length ? (a = new ra(A, e), i.push(a)) : a = i[r], a
                }, dispose: function () {
                    t = new WeakMap
                }
            }
        }

        class aa extends Tt {
            constructor(A) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(A)
            }

            copy(A) {
                return super.copy(A), this.depthPacking = A.depthPacking, this.map = A.map, this.alphaMap = A.alphaMap, this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this.wireframe = A.wireframe, this.wireframeLinewidth = A.wireframeLinewidth, this
            }
        }

        class sa extends Tt {
            constructor(A) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(A)
            }

            copy(A) {
                return super.copy(A), this.map = A.map, this.alphaMap = A.alphaMap, this.displacementMap = A.displacementMap, this.displacementScale = A.displacementScale, this.displacementBias = A.displacementBias, this
            }
        }

        function oa(A, e, t) {
            let n = new Rn;
            const r = new DA, i = new DA, a = new re, s = new aa({depthPacking: 3201}), o = new sa, l = {},
                c = t.maxTextureSize, u = {0: 1, 1: 0, 2: 2}, h = new wn({
                    defines: {VSM_SAMPLES: 8},
                    uniforms: {shadow_pass: {value: null}, resolution: {value: new DA}, radius: {value: 4}},
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }), d = h.clone();
            d.defines.HORIZONTAL_PASS = 1;
            const p = new Xt;
            p.setAttribute("position", new Ht(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const f = new hn(p, h), g = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = v;
            let m = this.type;

            function B(t, n) {
                const i = e.update(f);
                h.defines.VSM_SAMPLES !== t.blurSamples && (h.defines.VSM_SAMPLES = t.blurSamples, d.defines.VSM_SAMPLES = t.blurSamples, h.needsUpdate = !0, d.needsUpdate = !0), null === t.mapPass && (t.mapPass = new ae(r.x, r.y)), h.uniforms.shadow_pass.value = t.map.texture, h.uniforms.resolution.value = t.mapSize, h.uniforms.radius.value = t.radius, A.setRenderTarget(t.mapPass), A.clear(), A.renderBufferDirect(n, null, i, h, f, null), d.uniforms.shadow_pass.value = t.mapPass.texture, d.uniforms.resolution.value = t.mapSize, d.uniforms.radius.value = t.radius, A.setRenderTarget(t.map), A.clear(), A.renderBufferDirect(n, null, i, d, f, null)
            }

            function w(e, t, n, r) {
                let i = null;
                const a = !0 === n.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (void 0 !== a) i = a; else if (i = !0 === n.isPointLight ? o : s, A.localClippingEnabled && !0 === t.clipShadows && Array.isArray(t.clippingPlanes) && 0 !== t.clippingPlanes.length || t.displacementMap && 0 !== t.displacementScale || t.alphaMap && t.alphaTest > 0 || t.map && t.alphaTest > 0) {
                    const A = i.uuid, e = t.uuid;
                    let n = l[A];
                    void 0 === n && (n = {}, l[A] = n);
                    let r = n[e];
                    void 0 === r && (r = i.clone(), n[e] = r, t.addEventListener("dispose", E)), i = r
                }
                return i.visible = t.visible, i.wireframe = t.wireframe, i.side = r === C ? null !== t.shadowSide ? t.shadowSide : t.side : null !== t.shadowSide ? t.shadowSide : u[t.side], i.alphaMap = t.alphaMap, i.alphaTest = t.alphaTest, i.map = t.map, i.clipShadows = t.clipShadows, i.clippingPlanes = t.clippingPlanes, i.clipIntersection = t.clipIntersection, i.displacementMap = t.displacementMap, i.displacementScale = t.displacementScale, i.displacementBias = t.displacementBias, i.wireframeLinewidth = t.wireframeLinewidth, i.linewidth = t.linewidth, !0 === n.isPointLight && !0 === i.isMeshDistanceMaterial && (A.properties.get(i).light = n), i
            }

            function _(t, r, i, a, s) {
                if (!1 === t.visible) return;
                if (t.layers.test(r.layers) && (t.isMesh || t.isLine || t.isPoints) && (t.castShadow || t.receiveShadow && s === C) && (!t.frustumCulled || n.intersectsObject(t))) {
                    t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld);
                    const n = e.update(t), o = t.material;
                    if (Array.isArray(o)) {
                        const e = n.groups;
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l], u = o[c.materialIndex];
                            if (u && u.visible) {
                                const e = w(t, u, a, s);
                                t.onBeforeShadow(A, t, r, i, n, e, c), A.renderBufferDirect(i, null, n, e, t, c), t.onAfterShadow(A, t, r, i, n, e, c)
                            }
                        }
                    } else if (o.visible) {
                        const e = w(t, o, a, s);
                        t.onBeforeShadow(A, t, r, i, n, e, null), A.renderBufferDirect(i, null, n, e, t, null), t.onAfterShadow(A, t, r, i, n, e, null)
                    }
                }
                const o = t.children;
                for (let A = 0, e = o.length; A < e; A++) _(o[A], r, i, a, s)
            }

            function E(A) {
                A.target.removeEventListener("dispose", E);
                for (const e in l) {
                    const t = l[e], n = A.target.uuid;
                    n in t && (t[n].dispose(), delete t[n])
                }
            }

            this.render = function (e, t, s) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === e.length) return;
                const o = A.getRenderTarget(), l = A.getActiveCubeFace(), u = A.getActiveMipmapLevel(), h = A.state;
                h.setBlending(0), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                const d = m !== C && this.type === C, p = m === C && this.type !== C;
                for (let o = 0, l = e.length; o < l; o++) {
                    const l = e[o], u = l.shadow;
                    if (void 0 === u) {
                        console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                        continue
                    }
                    if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                    r.copy(u.mapSize);
                    const f = u.getFrameExtents();
                    if (r.multiply(f), i.copy(u.mapSize), (r.x > c || r.y > c) && (r.x > c && (i.x = Math.floor(c / f.x), r.x = i.x * f.x, u.mapSize.x = i.x), r.y > c && (i.y = Math.floor(c / f.y), r.y = i.y * f.y, u.mapSize.y = i.y)), null === u.map || !0 === d || !0 === p) {
                        const A = this.type !== C ? {minFilter: G, magFilter: G} : {};
                        null !== u.map && u.map.dispose(), u.map = new ae(r.x, r.y, A), u.map.texture.name = l.name + ".shadowMap", u.camera.updateProjectionMatrix()
                    }
                    A.setRenderTarget(u.map), A.clear();
                    const g = u.getViewportCount();
                    for (let A = 0; A < g; A++) {
                        const e = u.getViewport(A);
                        a.set(i.x * e.x, i.y * e.y, i.x * e.z, i.y * e.w), h.viewport(a), u.updateMatrices(l, A), n = u.getFrustum(), _(t, s, u.camera, l, this.type)
                    }
                    !0 !== u.isPointLightShadow && this.type === C && B(u, s), u.needsUpdate = !1
                }
                m = this.type, g.needsUpdate = !1, A.setRenderTarget(o, l, u)
            }
        }

        function la(A, e, t) {
            const n = t.isWebGL2, r = new function () {
                let e = !1;
                const t = new re;
                let n = null;
                const r = new re(0, 0, 0, 0);
                return {
                    setMask: function (t) {
                        n === t || e || (A.colorMask(t, t, t, t), n = t)
                    }, setLocked: function (A) {
                        e = A
                    }, setClear: function (e, n, i, a, s) {
                        !0 === s && (e *= a, n *= a, i *= a), t.set(e, n, i, a), !1 === r.equals(t) && (A.clearColor(e, n, i, a), r.copy(t))
                    }, reset: function () {
                        e = !1, n = null, r.set(-1, 0, 0, 0)
                    }
                }
            }, i = new function () {
                let e = !1, t = null, n = null, r = null;
                return {
                    setTest: function (e) {
                        e ? K(A.DEPTH_TEST) : k(A.DEPTH_TEST)
                    }, setMask: function (n) {
                        t === n || e || (A.depthMask(n), t = n)
                    }, setFunc: function (e) {
                        if (n !== e) {
                            switch (e) {
                                case 0:
                                    A.depthFunc(A.NEVER);
                                    break;
                                case 1:
                                    A.depthFunc(A.ALWAYS);
                                    break;
                                case 2:
                                    A.depthFunc(A.LESS);
                                    break;
                                case 3:
                                default:
                                    A.depthFunc(A.LEQUAL);
                                    break;
                                case 4:
                                    A.depthFunc(A.EQUAL);
                                    break;
                                case 5:
                                    A.depthFunc(A.GEQUAL);
                                    break;
                                case 6:
                                    A.depthFunc(A.GREATER);
                                    break;
                                case 7:
                                    A.depthFunc(A.NOTEQUAL)
                            }
                            n = e
                        }
                    }, setLocked: function (A) {
                        e = A
                    }, setClear: function (e) {
                        r !== e && (A.clearDepth(e), r = e)
                    }, reset: function () {
                        e = !1, t = null, n = null, r = null
                    }
                }
            }, a = new function () {
                let e = !1, t = null, n = null, r = null, i = null, a = null, s = null, o = null, l = null;
                return {
                    setTest: function (t) {
                        e || (t ? K(A.STENCIL_TEST) : k(A.STENCIL_TEST))
                    }, setMask: function (n) {
                        t === n || e || (A.stencilMask(n), t = n)
                    }, setFunc: function (e, t, a) {
                        n === e && r === t && i === a || (A.stencilFunc(e, t, a), n = e, r = t, i = a)
                    }, setOp: function (e, t, n) {
                        a === e && s === t && o === n || (A.stencilOp(e, t, n), a = e, s = t, o = n)
                    }, setLocked: function (A) {
                        e = A
                    }, setClear: function (e) {
                        l !== e && (A.clearStencil(e), l = e)
                    }, reset: function () {
                        e = !1, t = null, n = null, r = null, i = null, a = null, s = null, o = null, l = null
                    }
                }
            }, s = new WeakMap, o = new WeakMap;
            let l = {}, c = {}, u = new WeakMap, h = [], d = null, p = !1, f = null, g = null, m = null, B = null,
                w = null, v = null, _ = null, C = new St(0, 0, 0), U = 0, y = !1, x = null, M = null, F = null,
                S = null, b = null;
            const Q = A.getParameter(A.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let T = !1, I = 0;
            const L = A.getParameter(A.VERSION);
            -1 !== L.indexOf("WebGL") ? (I = parseFloat(/^WebGL (\d)/.exec(L)[1]), T = I >= 1) : -1 !== L.indexOf("OpenGL ES") && (I = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), T = I >= 2);
            let R = null, H = {};
            const D = A.getParameter(A.SCISSOR_BOX), P = A.getParameter(A.VIEWPORT), N = (new re).fromArray(D),
                O = (new re).fromArray(P);

            function G(e, t, r, i) {
                const a = new Uint8Array(4), s = A.createTexture();
                A.bindTexture(e, s), A.texParameteri(e, A.TEXTURE_MIN_FILTER, A.NEAREST), A.texParameteri(e, A.TEXTURE_MAG_FILTER, A.NEAREST);
                for (let s = 0; s < r; s++) !n || e !== A.TEXTURE_3D && e !== A.TEXTURE_2D_ARRAY ? A.texImage2D(t + s, 0, A.RGBA, 1, 1, 0, A.RGBA, A.UNSIGNED_BYTE, a) : A.texImage3D(t, 0, A.RGBA, 1, 1, i, 0, A.RGBA, A.UNSIGNED_BYTE, a);
                return s
            }

            const V = {};

            function K(e) {
                !0 !== l[e] && (A.enable(e), l[e] = !0)
            }

            function k(e) {
                !1 !== l[e] && (A.disable(e), l[e] = !1)
            }

            V[A.TEXTURE_2D] = G(A.TEXTURE_2D, A.TEXTURE_2D, 1), V[A.TEXTURE_CUBE_MAP] = G(A.TEXTURE_CUBE_MAP, A.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (V[A.TEXTURE_2D_ARRAY] = G(A.TEXTURE_2D_ARRAY, A.TEXTURE_2D_ARRAY, 1, 1), V[A.TEXTURE_3D] = G(A.TEXTURE_3D, A.TEXTURE_3D, 1, 1)), r.setClear(0, 0, 0, 1), i.setClear(1), a.setClear(0), K(A.DEPTH_TEST), i.setFunc(3), Y(!1), J(1), K(A.CULL_FACE), X(0);
            const z = {[E]: A.FUNC_ADD, 101: A.FUNC_SUBTRACT, 102: A.FUNC_REVERSE_SUBTRACT};
            if (n) z[103] = A.MIN, z[104] = A.MAX; else {
                const A = e.get("EXT_blend_minmax");
                null !== A && (z[103] = A.MIN_EXT, z[104] = A.MAX_EXT)
            }
            const W = {
                200: A.ZERO,
                201: A.ONE,
                202: A.SRC_COLOR,
                204: A.SRC_ALPHA,
                210: A.SRC_ALPHA_SATURATE,
                208: A.DST_COLOR,
                206: A.DST_ALPHA,
                203: A.ONE_MINUS_SRC_COLOR,
                205: A.ONE_MINUS_SRC_ALPHA,
                209: A.ONE_MINUS_DST_COLOR,
                207: A.ONE_MINUS_DST_ALPHA,
                211: A.CONSTANT_COLOR,
                212: A.ONE_MINUS_CONSTANT_COLOR,
                213: A.CONSTANT_ALPHA,
                214: A.ONE_MINUS_CONSTANT_ALPHA
            };

            function X(e, t, n, r, i, a, s, o, l, c) {
                if (0 !== e) {
                    if (!1 === p && (K(A.BLEND), p = !0), 5 === e) i = i || t, a = a || n, s = s || r, t === g && i === w || (A.blendEquationSeparate(z[t], z[i]), g = t, w = i), n === m && r === B && a === v && s === _ || (A.blendFuncSeparate(W[n], W[r], W[a], W[s]), m = n, B = r, v = a, _ = s), !1 !== o.equals(C) && l === U || (A.blendColor(o.r, o.g, o.b, l), C.copy(o), U = l), f = e, y = !1; else if (e !== f || c !== y) {
                        if (g === E && w === E || (A.blendEquation(A.FUNC_ADD), g = E, w = E), c) switch (e) {
                            case 1:
                                A.blendFuncSeparate(A.ONE, A.ONE_MINUS_SRC_ALPHA, A.ONE, A.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                A.blendFunc(A.ONE, A.ONE);
                                break;
                            case 3:
                                A.blendFuncSeparate(A.ZERO, A.ONE_MINUS_SRC_COLOR, A.ZERO, A.ONE);
                                break;
                            case 4:
                                A.blendFuncSeparate(A.ZERO, A.SRC_COLOR, A.ZERO, A.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                A.blendFuncSeparate(A.SRC_ALPHA, A.ONE_MINUS_SRC_ALPHA, A.ONE, A.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                A.blendFunc(A.SRC_ALPHA, A.ONE);
                                break;
                            case 3:
                                A.blendFuncSeparate(A.ZERO, A.ONE_MINUS_SRC_COLOR, A.ZERO, A.ONE);
                                break;
                            case 4:
                                A.blendFunc(A.ZERO, A.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        m = null, B = null, v = null, _ = null, C.set(0, 0, 0), U = 0, f = e, y = c
                    }
                } else !0 === p && (k(A.BLEND), p = !1)
            }

            function Y(e) {
                x !== e && (e ? A.frontFace(A.CW) : A.frontFace(A.CCW), x = e)
            }

            function J(e) {
                0 !== e ? (K(A.CULL_FACE), e !== M && (1 === e ? A.cullFace(A.BACK) : 2 === e ? A.cullFace(A.FRONT) : A.cullFace(A.FRONT_AND_BACK))) : k(A.CULL_FACE), M = e
            }

            function j(e, t, n) {
                e ? (K(A.POLYGON_OFFSET_FILL), S === t && b === n || (A.polygonOffset(t, n), S = t, b = n)) : k(A.POLYGON_OFFSET_FILL)
            }

            return {
                buffers: {color: r, depth: i, stencil: a}, enable: K, disable: k, bindFramebuffer: function (e, t) {
                    return c[e] !== t && (A.bindFramebuffer(e, t), c[e] = t, n && (e === A.DRAW_FRAMEBUFFER && (c[A.FRAMEBUFFER] = t), e === A.FRAMEBUFFER && (c[A.DRAW_FRAMEBUFFER] = t)), !0)
                }, drawBuffers: function (n, r) {
                    let i = h, a = !1;
                    if (n) {
                        i = u.get(r), void 0 === i && (i = [], u.set(r, i));
                        const e = n.textures;
                        if (i.length !== e.length || i[0] !== A.COLOR_ATTACHMENT0) {
                            for (let t = 0, n = e.length; t < n; t++) i[t] = A.COLOR_ATTACHMENT0 + t;
                            i.length = e.length, a = !0
                        }
                    } else i[0] !== A.BACK && (i[0] = A.BACK, a = !0);
                    if (a) if (t.isWebGL2) A.drawBuffers(i); else {
                        if (!0 !== e.has("WEBGL_draw_buffers")) throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension");
                        e.get("WEBGL_draw_buffers").drawBuffersWEBGL(i)
                    }
                }, useProgram: function (e) {
                    return d !== e && (A.useProgram(e), d = e, !0)
                }, setBlending: X, setMaterial: function (e, t) {
                    2 === e.side ? k(A.CULL_FACE) : K(A.CULL_FACE);
                    let n = 1 === e.side;
                    t && (n = !n), Y(n), 1 === e.blending && !1 === e.transparent ? X(0) : X(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.blendColor, e.blendAlpha, e.premultipliedAlpha), i.setFunc(e.depthFunc), i.setTest(e.depthTest), i.setMask(e.depthWrite), r.setMask(e.colorWrite);
                    const s = e.stencilWrite;
                    a.setTest(s), s && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), j(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? K(A.SAMPLE_ALPHA_TO_COVERAGE) : k(A.SAMPLE_ALPHA_TO_COVERAGE)
                }, setFlipSided: Y, setCullFace: J, setLineWidth: function (e) {
                    e !== F && (T && A.lineWidth(e), F = e)
                }, setPolygonOffset: j, setScissorTest: function (e) {
                    e ? K(A.SCISSOR_TEST) : k(A.SCISSOR_TEST)
                }, activeTexture: function (e) {
                    void 0 === e && (e = A.TEXTURE0 + Q - 1), R !== e && (A.activeTexture(e), R = e)
                }, bindTexture: function (e, t, n) {
                    void 0 === n && (n = null === R ? A.TEXTURE0 + Q - 1 : R);
                    let r = H[n];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, H[n] = r), r.type === e && r.texture === t || (R !== n && (A.activeTexture(n), R = n), A.bindTexture(e, t || V[e]), r.type = e, r.texture = t)
                }, unbindTexture: function () {
                    const e = H[R];
                    void 0 !== e && void 0 !== e.type && (A.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                }, compressedTexImage2D: function () {
                    try {
                        A.compressedTexImage2D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, compressedTexImage3D: function () {
                    try {
                        A.compressedTexImage3D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, texImage2D: function () {
                    try {
                        A.texImage2D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, texImage3D: function () {
                    try {
                        A.texImage3D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, updateUBOMapping: function (e, t) {
                    let n = o.get(t);
                    void 0 === n && (n = new WeakMap, o.set(t, n));
                    let r = n.get(e);
                    void 0 === r && (r = A.getUniformBlockIndex(t, e.name), n.set(e, r))
                }, uniformBlockBinding: function (e, t) {
                    const n = o.get(t).get(e);
                    s.get(t) !== n && (A.uniformBlockBinding(t, n, e.__bindingPointIndex), s.set(t, n))
                }, texStorage2D: function () {
                    try {
                        A.texStorage2D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, texStorage3D: function () {
                    try {
                        A.texStorage3D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, texSubImage2D: function () {
                    try {
                        A.texSubImage2D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, texSubImage3D: function () {
                    try {
                        A.texSubImage3D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, compressedTexSubImage2D: function () {
                    try {
                        A.compressedTexSubImage2D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, compressedTexSubImage3D: function () {
                    try {
                        A.compressedTexSubImage3D.apply(A, arguments)
                    } catch (A) {
                        console.error("THREE.WebGLState:", A)
                    }
                }, scissor: function (e) {
                    !1 === N.equals(e) && (A.scissor(e.x, e.y, e.z, e.w), N.copy(e))
                }, viewport: function (e) {
                    !1 === O.equals(e) && (A.viewport(e.x, e.y, e.z, e.w), O.copy(e))
                }, reset: function () {
                    A.disable(A.BLEND), A.disable(A.CULL_FACE), A.disable(A.DEPTH_TEST), A.disable(A.POLYGON_OFFSET_FILL), A.disable(A.SCISSOR_TEST), A.disable(A.STENCIL_TEST), A.disable(A.SAMPLE_ALPHA_TO_COVERAGE), A.blendEquation(A.FUNC_ADD), A.blendFunc(A.ONE, A.ZERO), A.blendFuncSeparate(A.ONE, A.ZERO, A.ONE, A.ZERO), A.blendColor(0, 0, 0, 0), A.colorMask(!0, !0, !0, !0), A.clearColor(0, 0, 0, 0), A.depthMask(!0), A.depthFunc(A.LESS), A.clearDepth(1), A.stencilMask(4294967295), A.stencilFunc(A.ALWAYS, 0, 4294967295), A.stencilOp(A.KEEP, A.KEEP, A.KEEP), A.clearStencil(0), A.cullFace(A.BACK), A.frontFace(A.CCW), A.polygonOffset(0, 0), A.activeTexture(A.TEXTURE0), A.bindFramebuffer(A.FRAMEBUFFER, null), !0 === n && (A.bindFramebuffer(A.DRAW_FRAMEBUFFER, null), A.bindFramebuffer(A.READ_FRAMEBUFFER, null)), A.useProgram(null), A.lineWidth(1), A.scissor(0, 0, A.canvas.width, A.canvas.height), A.viewport(0, 0, A.canvas.width, A.canvas.height), l = {}, R = null, H = {}, c = {}, u = new WeakMap, h = [], d = null, p = !1, f = null, g = null, m = null, B = null, w = null, v = null, _ = null, C = new St(0, 0, 0), U = 0, y = !1, x = null, M = null, F = null, S = null, b = null, N.set(0, 0, A.canvas.width, A.canvas.height), O.set(0, 0, A.canvas.width, A.canvas.height), r.reset(), i.reset(), a.reset()
                }
            }
        }

        function ca(A, e, t, n, r, i, a) {
            const s = r.isWebGL2,
                o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), c = new DA,
                u = new WeakMap;
            let h;
            const d = new WeakMap;
            let p = !1;
            try {
                p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (A) {
            }

            function f(A, e) {
                return p ? new OffscreenCanvas(A, e) : GA("canvas")
            }

            function g(A, e, t, n) {
                let r = 1;
                const i = nA(A);
                if ((i.width > n || i.height > n) && (r = n / Math.max(i.width, i.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && A instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && A instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && A instanceof ImageBitmap || "undefined" != typeof VideoFrame && A instanceof VideoFrame) {
                        const n = e ? IA : Math.floor, a = n(r * i.width), s = n(r * i.height);
                        void 0 === h && (h = f(a, s));
                        const o = t ? f(a, s) : h;
                        return o.width = a, o.height = s, o.getContext("2d").drawImage(A, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + i.width + "x" + i.height + ") to (" + a + "x" + s + ")."), o
                    }
                    return "data" in A && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + i.width + "x" + i.height + ")."), A
                }
                return A
            }

            function m(A) {
                const e = nA(A);
                return TA(e.width) && TA(e.height)
            }

            function B(A, e) {
                return A.generateMipmaps && e && A.minFilter !== G && A.minFilter !== K
            }

            function w(e) {
                A.generateMipmap(e)
            }

            function v(t, n, r, i, a = !1) {
                if (!1 === s) return n;
                if (null !== t) {
                    if (void 0 !== A[t]) return A[t];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + t + "'")
                }
                let o = n;
                if (n === A.RED && (r === A.FLOAT && (o = A.R32F), r === A.HALF_FLOAT && (o = A.R16F), r === A.UNSIGNED_BYTE && (o = A.R8)), n === A.RED_INTEGER && (r === A.UNSIGNED_BYTE && (o = A.R8UI), r === A.UNSIGNED_SHORT && (o = A.R16UI), r === A.UNSIGNED_INT && (o = A.R32UI), r === A.BYTE && (o = A.R8I), r === A.SHORT && (o = A.R16I), r === A.INT && (o = A.R32I)), n === A.RG && (r === A.FLOAT && (o = A.RG32F), r === A.HALF_FLOAT && (o = A.RG16F), r === A.UNSIGNED_BYTE && (o = A.RG8)), n === A.RG_INTEGER && (r === A.UNSIGNED_BYTE && (o = A.RG8UI), r === A.UNSIGNED_SHORT && (o = A.RG16UI), r === A.UNSIGNED_INT && (o = A.RG32UI), r === A.BYTE && (o = A.RG8I), r === A.SHORT && (o = A.RG16I), r === A.INT && (o = A.RG32I)), n === A.RGBA) {
                    const e = a ? pA : YA.getTransfer(i);
                    r === A.FLOAT && (o = A.RGBA32F), r === A.HALF_FLOAT && (o = A.RGBA16F), r === A.UNSIGNED_BYTE && (o = e === fA ? A.SRGB8_ALPHA8 : A.RGBA8), r === A.UNSIGNED_SHORT_4_4_4_4 && (o = A.RGBA4), r === A.UNSIGNED_SHORT_5_5_5_1 && (o = A.RGB5_A1)
                }
                return o !== A.R16F && o !== A.R32F && o !== A.RG16F && o !== A.RG32F && o !== A.RGBA16F && o !== A.RGBA32F || e.get("EXT_color_buffer_float"), o
            }

            function _(A, e, t) {
                return !0 === B(A, t) || A.isFramebufferTexture && A.minFilter !== G && A.minFilter !== K ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== A.mipmaps && A.mipmaps.length > 0 ? A.mipmaps.length : A.isCompressedTexture && Array.isArray(A.image) ? e.mipmaps.length : 1
            }

            function C(e) {
                return e === G || 1004 === e || e === V ? A.NEAREST : A.LINEAR
            }

            function E(A) {
                const e = A.target;
                e.removeEventListener("dispose", E), function (A) {
                    const e = n.get(A);
                    if (void 0 === e.__webglInit) return;
                    const t = A.source, r = d.get(t);
                    if (r) {
                        const n = r[e.__cacheKey];
                        n.usedTimes--, 0 === n.usedTimes && y(A), 0 === Object.keys(r).length && d.delete(t)
                    }
                    n.remove(A)
                }(e), e.isVideoTexture && u.delete(e)
            }

            function U(e) {
                const t = e.target;
                t.removeEventListener("dispose", U), function (e) {
                    const t = n.get(e);
                    if (e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++) {
                        if (Array.isArray(t.__webglFramebuffer[e])) for (let n = 0; n < t.__webglFramebuffer[e].length; n++) A.deleteFramebuffer(t.__webglFramebuffer[e][n]); else A.deleteFramebuffer(t.__webglFramebuffer[e]);
                        t.__webglDepthbuffer && A.deleteRenderbuffer(t.__webglDepthbuffer[e])
                    } else {
                        if (Array.isArray(t.__webglFramebuffer)) for (let e = 0; e < t.__webglFramebuffer.length; e++) A.deleteFramebuffer(t.__webglFramebuffer[e]); else A.deleteFramebuffer(t.__webglFramebuffer);
                        if (t.__webglDepthbuffer && A.deleteRenderbuffer(t.__webglDepthbuffer), t.__webglMultisampledFramebuffer && A.deleteFramebuffer(t.__webglMultisampledFramebuffer), t.__webglColorRenderbuffer) for (let e = 0; e < t.__webglColorRenderbuffer.length; e++) t.__webglColorRenderbuffer[e] && A.deleteRenderbuffer(t.__webglColorRenderbuffer[e]);
                        t.__webglDepthRenderbuffer && A.deleteRenderbuffer(t.__webglDepthRenderbuffer)
                    }
                    const r = e.textures;
                    for (let e = 0, t = r.length; e < t; e++) {
                        const t = n.get(r[e]);
                        t.__webglTexture && (A.deleteTexture(t.__webglTexture), a.memory.textures--), n.remove(r[e])
                    }
                    n.remove(e)
                }(t)
            }

            function y(e) {
                const t = n.get(e);
                A.deleteTexture(t.__webglTexture);
                const r = e.source;
                delete d.get(r)[t.__cacheKey], a.memory.textures--
            }

            let x = 0;

            function M(e, r) {
                const i = n.get(e);
                if (e.isVideoTexture && function (A) {
                    const e = a.render.frame;
                    u.get(A) !== e && (u.set(A, e), A.update())
                }(e), !1 === e.isRenderTargetTexture && e.version > 0 && i.__version !== e.version) {
                    const A = e.image;
                    if (null === A) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else {
                        if (!1 !== A.complete) return void I(i, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                t.bindTexture(A.TEXTURE_2D, i.__webglTexture, A.TEXTURE0 + r)
            }

            const F = {[P]: A.REPEAT, [N]: A.CLAMP_TO_EDGE, [O]: A.MIRRORED_REPEAT}, S = {
                [G]: A.NEAREST,
                1004: A.NEAREST_MIPMAP_NEAREST,
                [V]: A.NEAREST_MIPMAP_LINEAR,
                [K]: A.LINEAR,
                [k]: A.LINEAR_MIPMAP_NEAREST,
                [z]: A.LINEAR_MIPMAP_LINEAR
            }, b = {
                512: A.NEVER,
                519: A.ALWAYS,
                513: A.LESS,
                515: A.LEQUAL,
                514: A.EQUAL,
                518: A.GEQUAL,
                516: A.GREATER,
                517: A.NOTEQUAL
            };

            function Q(t, i, a) {
                if (i.type !== J || !1 !== e.has("OES_texture_float_linear") || i.magFilter !== K && i.magFilter !== k && i.magFilter !== V && i.magFilter !== z && i.minFilter !== K && i.minFilter !== k && i.minFilter !== V && i.minFilter !== z || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), a ? (A.texParameteri(t, A.TEXTURE_WRAP_S, F[i.wrapS]), A.texParameteri(t, A.TEXTURE_WRAP_T, F[i.wrapT]), t !== A.TEXTURE_3D && t !== A.TEXTURE_2D_ARRAY || A.texParameteri(t, A.TEXTURE_WRAP_R, F[i.wrapR]), A.texParameteri(t, A.TEXTURE_MAG_FILTER, S[i.magFilter]), A.texParameteri(t, A.TEXTURE_MIN_FILTER, S[i.minFilter])) : (A.texParameteri(t, A.TEXTURE_WRAP_S, A.CLAMP_TO_EDGE), A.texParameteri(t, A.TEXTURE_WRAP_T, A.CLAMP_TO_EDGE), t !== A.TEXTURE_3D && t !== A.TEXTURE_2D_ARRAY || A.texParameteri(t, A.TEXTURE_WRAP_R, A.CLAMP_TO_EDGE), i.wrapS === N && i.wrapT === N || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), A.texParameteri(t, A.TEXTURE_MAG_FILTER, C(i.magFilter)), A.texParameteri(t, A.TEXTURE_MIN_FILTER, C(i.minFilter)), i.minFilter !== G && i.minFilter !== K && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), i.compareFunction && (A.texParameteri(t, A.TEXTURE_COMPARE_MODE, A.COMPARE_REF_TO_TEXTURE), A.texParameteri(t, A.TEXTURE_COMPARE_FUNC, b[i.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    if (i.magFilter === G) return;
                    if (i.minFilter !== V && i.minFilter !== z) return;
                    if (i.type === J && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === s && i.type === j && !1 === e.has("OES_texture_half_float_linear")) return;
                    if (i.anisotropy > 1 || n.get(i).__currentAnisotropy) {
                        const a = e.get("EXT_texture_filter_anisotropic");
                        A.texParameterf(t, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, r.getMaxAnisotropy())), n.get(i).__currentAnisotropy = i.anisotropy
                    }
                }
            }

            function T(e, t) {
                let n = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", E));
                const r = t.source;
                let i = d.get(r);
                void 0 === i && (i = {}, d.set(r, i));
                const s = function (A) {
                    const e = [];
                    return e.push(A.wrapS), e.push(A.wrapT), e.push(A.wrapR || 0), e.push(A.magFilter), e.push(A.minFilter), e.push(A.anisotropy), e.push(A.internalFormat), e.push(A.format), e.push(A.type), e.push(A.generateMipmaps), e.push(A.premultiplyAlpha), e.push(A.flipY), e.push(A.unpackAlignment), e.push(A.colorSpace), e.join()
                }(t);
                if (s !== e.__cacheKey) {
                    void 0 === i[s] && (i[s] = {
                        texture: A.createTexture(),
                        usedTimes: 0
                    }, a.memory.textures++, n = !0), i[s].usedTimes++;
                    const r = i[e.__cacheKey];
                    void 0 !== r && (i[e.__cacheKey].usedTimes--, 0 === r.usedTimes && y(t)), e.__cacheKey = s, e.__webglTexture = i[s].texture
                }
                return n
            }

            function I(e, a, o) {
                let l = A.TEXTURE_2D;
                (a.isDataArrayTexture || a.isCompressedArrayTexture) && (l = A.TEXTURE_2D_ARRAY), a.isData3DTexture && (l = A.TEXTURE_3D);
                const c = T(e, a), u = a.source;
                t.bindTexture(l, e.__webglTexture, A.TEXTURE0 + o);
                const h = n.get(u);
                if (u.version !== h.__version || !0 === c) {
                    t.activeTexture(A.TEXTURE0 + o);
                    const e = YA.getPrimaries(YA.workingColorSpace),
                        n = a.colorSpace === lA ? null : YA.getPrimaries(a.colorSpace),
                        d = a.colorSpace === lA || e === n ? A.NONE : A.BROWSER_DEFAULT_WEBGL;
                    A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL, a.flipY), A.pixelStorei(A.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), A.pixelStorei(A.UNPACK_ALIGNMENT, a.unpackAlignment), A.pixelStorei(A.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                    const p = function (A) {
                        return !s && (A.wrapS !== N || A.wrapT !== N || A.minFilter !== G && A.minFilter !== K)
                    }(a) && !1 === m(a.image);
                    let f = g(a.image, p, !1, r.maxTextureSize);
                    f = tA(a, f);
                    const C = m(f) || s, E = i.convert(a.format, a.colorSpace);
                    let U, y = i.convert(a.type), x = v(a.internalFormat, E, y, a.colorSpace, a.isVideoTexture);
                    Q(l, a, C);
                    const M = a.mipmaps, F = s && !0 !== a.isVideoTexture && 36196 !== x,
                        S = void 0 === h.__version || !0 === c, b = u.dataReady, T = _(a, f, C);
                    if (a.isDepthTexture) x = A.DEPTH_COMPONENT, s ? x = a.type === J ? A.DEPTH_COMPONENT32F : a.type === Y ? A.DEPTH_COMPONENT24 : a.type === Z ? A.DEPTH24_STENCIL8 : A.DEPTH_COMPONENT16 : a.type === J && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), a.format === $ && x === A.DEPTH_COMPONENT && a.type !== X && a.type !== Y && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), a.type = Y, y = i.convert(a.type)), a.format === AA && x === A.DEPTH_COMPONENT && (x = A.DEPTH_STENCIL, a.type !== Z && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), a.type = Z, y = i.convert(a.type))), S && (F ? t.texStorage2D(A.TEXTURE_2D, 1, x, f.width, f.height) : t.texImage2D(A.TEXTURE_2D, 0, x, f.width, f.height, 0, E, y, null)); else if (a.isDataTexture) if (M.length > 0 && C) {
                        F && S && t.texStorage2D(A.TEXTURE_2D, T, x, M[0].width, M[0].height);
                        for (let e = 0, n = M.length; e < n; e++) U = M[e], F ? b && t.texSubImage2D(A.TEXTURE_2D, e, 0, 0, U.width, U.height, E, y, U.data) : t.texImage2D(A.TEXTURE_2D, e, x, U.width, U.height, 0, E, y, U.data);
                        a.generateMipmaps = !1
                    } else F ? (S && t.texStorage2D(A.TEXTURE_2D, T, x, f.width, f.height), b && t.texSubImage2D(A.TEXTURE_2D, 0, 0, 0, f.width, f.height, E, y, f.data)) : t.texImage2D(A.TEXTURE_2D, 0, x, f.width, f.height, 0, E, y, f.data); else if (a.isCompressedTexture) if (a.isCompressedArrayTexture) {
                        F && S && t.texStorage3D(A.TEXTURE_2D_ARRAY, T, x, M[0].width, M[0].height, f.depth);
                        for (let e = 0, n = M.length; e < n; e++) U = M[e], a.format !== q ? null !== E ? F ? b && t.compressedTexSubImage3D(A.TEXTURE_2D_ARRAY, e, 0, 0, 0, U.width, U.height, f.depth, E, U.data, 0, 0) : t.compressedTexImage3D(A.TEXTURE_2D_ARRAY, e, x, U.width, U.height, f.depth, 0, U.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : F ? b && t.texSubImage3D(A.TEXTURE_2D_ARRAY, e, 0, 0, 0, U.width, U.height, f.depth, E, y, U.data) : t.texImage3D(A.TEXTURE_2D_ARRAY, e, x, U.width, U.height, f.depth, 0, E, y, U.data)
                    } else {
                        F && S && t.texStorage2D(A.TEXTURE_2D, T, x, M[0].width, M[0].height);
                        for (let e = 0, n = M.length; e < n; e++) U = M[e], a.format !== q ? null !== E ? F ? b && t.compressedTexSubImage2D(A.TEXTURE_2D, e, 0, 0, U.width, U.height, E, U.data) : t.compressedTexImage2D(A.TEXTURE_2D, e, x, U.width, U.height, 0, U.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : F ? b && t.texSubImage2D(A.TEXTURE_2D, e, 0, 0, U.width, U.height, E, y, U.data) : t.texImage2D(A.TEXTURE_2D, e, x, U.width, U.height, 0, E, y, U.data)
                    } else if (a.isDataArrayTexture) F ? (S && t.texStorage3D(A.TEXTURE_2D_ARRAY, T, x, f.width, f.height, f.depth), b && t.texSubImage3D(A.TEXTURE_2D_ARRAY, 0, 0, 0, 0, f.width, f.height, f.depth, E, y, f.data)) : t.texImage3D(A.TEXTURE_2D_ARRAY, 0, x, f.width, f.height, f.depth, 0, E, y, f.data); else if (a.isData3DTexture) F ? (S && t.texStorage3D(A.TEXTURE_3D, T, x, f.width, f.height, f.depth), b && t.texSubImage3D(A.TEXTURE_3D, 0, 0, 0, 0, f.width, f.height, f.depth, E, y, f.data)) : t.texImage3D(A.TEXTURE_3D, 0, x, f.width, f.height, f.depth, 0, E, y, f.data); else if (a.isFramebufferTexture) {
                        if (S) if (F) t.texStorage2D(A.TEXTURE_2D, T, x, f.width, f.height); else {
                            let e = f.width, n = f.height;
                            for (let r = 0; r < T; r++) t.texImage2D(A.TEXTURE_2D, r, x, e, n, 0, E, y, null), e >>= 1, n >>= 1
                        }
                    } else if (M.length > 0 && C) {
                        if (F && S) {
                            const e = nA(M[0]);
                            t.texStorage2D(A.TEXTURE_2D, T, x, e.width, e.height)
                        }
                        for (let e = 0, n = M.length; e < n; e++) U = M[e], F ? b && t.texSubImage2D(A.TEXTURE_2D, e, 0, 0, E, y, U) : t.texImage2D(A.TEXTURE_2D, e, x, E, y, U);
                        a.generateMipmaps = !1
                    } else if (F) {
                        if (S) {
                            const e = nA(f);
                            t.texStorage2D(A.TEXTURE_2D, T, x, e.width, e.height)
                        }
                        b && t.texSubImage2D(A.TEXTURE_2D, 0, 0, 0, E, y, f)
                    } else t.texImage2D(A.TEXTURE_2D, 0, x, E, y, f);
                    B(a, C) && w(l), h.__version = u.version, a.onUpdate && a.onUpdate(a)
                }
                e.__version = a.version
            }

            function L(e, r, a, s, l, c) {
                const u = i.convert(a.format, a.colorSpace), h = i.convert(a.type),
                    d = v(a.internalFormat, u, h, a.colorSpace);
                if (!n.get(r).__hasExternalTextures) {
                    const e = Math.max(1, r.width >> c), n = Math.max(1, r.height >> c);
                    l === A.TEXTURE_3D || l === A.TEXTURE_2D_ARRAY ? t.texImage3D(l, c, d, e, n, r.depth, 0, u, h, null) : t.texImage2D(l, c, d, e, n, 0, u, h, null)
                }
                t.bindFramebuffer(A.FRAMEBUFFER, e), eA(r) ? o.framebufferTexture2DMultisampleEXT(A.FRAMEBUFFER, s, l, n.get(a).__webglTexture, 0, D(r)) : (l === A.TEXTURE_2D || l >= A.TEXTURE_CUBE_MAP_POSITIVE_X && l <= A.TEXTURE_CUBE_MAP_NEGATIVE_Z) && A.framebufferTexture2D(A.FRAMEBUFFER, s, l, n.get(a).__webglTexture, c), t.bindFramebuffer(A.FRAMEBUFFER, null)
            }

            function R(e, t, n) {
                if (A.bindRenderbuffer(A.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer) {
                    let r = !0 === s ? A.DEPTH_COMPONENT24 : A.DEPTH_COMPONENT16;
                    if (n || eA(t)) {
                        const e = t.depthTexture;
                        e && e.isDepthTexture && (e.type === J ? r = A.DEPTH_COMPONENT32F : e.type === Y && (r = A.DEPTH_COMPONENT24));
                        const n = D(t);
                        eA(t) ? o.renderbufferStorageMultisampleEXT(A.RENDERBUFFER, n, r, t.width, t.height) : A.renderbufferStorageMultisample(A.RENDERBUFFER, n, r, t.width, t.height)
                    } else A.renderbufferStorage(A.RENDERBUFFER, r, t.width, t.height);
                    A.framebufferRenderbuffer(A.FRAMEBUFFER, A.DEPTH_ATTACHMENT, A.RENDERBUFFER, e)
                } else if (t.depthBuffer && t.stencilBuffer) {
                    const r = D(t);
                    n && !1 === eA(t) ? A.renderbufferStorageMultisample(A.RENDERBUFFER, r, A.DEPTH24_STENCIL8, t.width, t.height) : eA(t) ? o.renderbufferStorageMultisampleEXT(A.RENDERBUFFER, r, A.DEPTH24_STENCIL8, t.width, t.height) : A.renderbufferStorage(A.RENDERBUFFER, A.DEPTH_STENCIL, t.width, t.height), A.framebufferRenderbuffer(A.FRAMEBUFFER, A.DEPTH_STENCIL_ATTACHMENT, A.RENDERBUFFER, e)
                } else {
                    const e = t.textures;
                    for (let r = 0; r < e.length; r++) {
                        const a = e[r], s = i.convert(a.format, a.colorSpace), l = i.convert(a.type),
                            c = v(a.internalFormat, s, l, a.colorSpace), u = D(t);
                        n && !1 === eA(t) ? A.renderbufferStorageMultisample(A.RENDERBUFFER, u, c, t.width, t.height) : eA(t) ? o.renderbufferStorageMultisampleEXT(A.RENDERBUFFER, u, c, t.width, t.height) : A.renderbufferStorage(A.RENDERBUFFER, c, t.width, t.height)
                    }
                }
                A.bindRenderbuffer(A.RENDERBUFFER, null)
            }

            function H(e) {
                const r = n.get(e), i = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                    !function (e, r) {
                        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (t.bindFramebuffer(A.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), M(r.depthTexture, 0);
                        const i = n.get(r.depthTexture).__webglTexture, a = D(r);
                        if (r.depthTexture.format === $) eA(r) ? o.framebufferTexture2DMultisampleEXT(A.FRAMEBUFFER, A.DEPTH_ATTACHMENT, A.TEXTURE_2D, i, 0, a) : A.framebufferTexture2D(A.FRAMEBUFFER, A.DEPTH_ATTACHMENT, A.TEXTURE_2D, i, 0); else {
                            if (r.depthTexture.format !== AA) throw new Error("Unknown depthTexture format");
                            eA(r) ? o.framebufferTexture2DMultisampleEXT(A.FRAMEBUFFER, A.DEPTH_STENCIL_ATTACHMENT, A.TEXTURE_2D, i, 0, a) : A.framebufferTexture2D(A.FRAMEBUFFER, A.DEPTH_STENCIL_ATTACHMENT, A.TEXTURE_2D, i, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (i) {
                    r.__webglDepthbuffer = [];
                    for (let n = 0; n < 6; n++) t.bindFramebuffer(A.FRAMEBUFFER, r.__webglFramebuffer[n]), r.__webglDepthbuffer[n] = A.createRenderbuffer(), R(r.__webglDepthbuffer[n], e, !1)
                } else t.bindFramebuffer(A.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = A.createRenderbuffer(), R(r.__webglDepthbuffer, e, !1);
                t.bindFramebuffer(A.FRAMEBUFFER, null)
            }

            function D(A) {
                return Math.min(r.maxSamples, A.samples)
            }

            function eA(A) {
                const t = n.get(A);
                return s && A.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== t.__useRenderToTexture
            }

            function tA(A, t) {
                const n = A.colorSpace, r = A.format, i = A.type;
                return !0 === A.isCompressedTexture || !0 === A.isVideoTexture || A.format === vA || n !== uA && n !== lA && (YA.getTransfer(n) === fA ? !1 === s ? !0 === e.has("EXT_sRGB") && r === q ? (A.format = vA, A.minFilter = K, A.generateMipmaps = !1) : t = qA.sRGBToLinear(t) : r === q && i === W || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)), t
            }

            function nA(A) {
                return "undefined" != typeof HTMLImageElement && A instanceof HTMLImageElement ? (c.width = A.naturalWidth || A.width, c.height = A.naturalHeight || A.height) : "undefined" != typeof VideoFrame && A instanceof VideoFrame ? (c.width = A.displayWidth, c.height = A.displayHeight) : (c.width = A.width, c.height = A.height), c
            }

            this.allocateTextureUnit = function () {
                const A = x;
                return A >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + A + " texture units while this GPU supports only " + r.maxTextures), x += 1, A
            }, this.resetTextureUnits = function () {
                x = 0
            }, this.setTexture2D = M, this.setTexture2DArray = function (e, r) {
                const i = n.get(e);
                e.version > 0 && i.__version !== e.version ? I(i, e, r) : t.bindTexture(A.TEXTURE_2D_ARRAY, i.__webglTexture, A.TEXTURE0 + r)
            }, this.setTexture3D = function (e, r) {
                const i = n.get(e);
                e.version > 0 && i.__version !== e.version ? I(i, e, r) : t.bindTexture(A.TEXTURE_3D, i.__webglTexture, A.TEXTURE0 + r)
            }, this.setTextureCube = function (e, a) {
                const o = n.get(e);
                e.version > 0 && o.__version !== e.version ? function (e, a, o) {
                    if (6 !== a.image.length) return;
                    const l = T(e, a), c = a.source;
                    t.bindTexture(A.TEXTURE_CUBE_MAP, e.__webglTexture, A.TEXTURE0 + o);
                    const u = n.get(c);
                    if (c.version !== u.__version || !0 === l) {
                        t.activeTexture(A.TEXTURE0 + o);
                        const e = YA.getPrimaries(YA.workingColorSpace),
                            n = a.colorSpace === lA ? null : YA.getPrimaries(a.colorSpace),
                            h = a.colorSpace === lA || e === n ? A.NONE : A.BROWSER_DEFAULT_WEBGL;
                        A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL, a.flipY), A.pixelStorei(A.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), A.pixelStorei(A.UNPACK_ALIGNMENT, a.unpackAlignment), A.pixelStorei(A.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                        const d = a.isCompressedTexture || a.image[0].isCompressedTexture,
                            p = a.image[0] && a.image[0].isDataTexture, f = [];
                        for (let A = 0; A < 6; A++) f[A] = d || p ? p ? a.image[A].image : a.image[A] : g(a.image[A], !1, !0, r.maxCubemapSize), f[A] = tA(a, f[A]);
                        const C = f[0], E = m(C) || s, U = i.convert(a.format, a.colorSpace), y = i.convert(a.type),
                            x = v(a.internalFormat, U, y, a.colorSpace), M = s && !0 !== a.isVideoTexture,
                            F = void 0 === u.__version || !0 === l, S = c.dataReady;
                        let b, T = _(a, C, E);
                        if (Q(A.TEXTURE_CUBE_MAP, a, E), d) {
                            M && F && t.texStorage2D(A.TEXTURE_CUBE_MAP, T, x, C.width, C.height);
                            for (let e = 0; e < 6; e++) {
                                b = f[e].mipmaps;
                                for (let n = 0; n < b.length; n++) {
                                    const r = b[n];
                                    a.format !== q ? null !== U ? M ? S && t.compressedTexSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, 0, 0, r.width, r.height, U, r.data) : t.compressedTexImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, x, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : M ? S && t.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, 0, 0, r.width, r.height, U, y, r.data) : t.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, x, r.width, r.height, 0, U, y, r.data)
                                }
                            }
                        } else {
                            if (b = a.mipmaps, M && F) {
                                b.length > 0 && T++;
                                const e = nA(f[0]);
                                t.texStorage2D(A.TEXTURE_CUBE_MAP, T, x, e.width, e.height)
                            }
                            for (let e = 0; e < 6; e++) if (p) {
                                M ? S && t.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, f[e].width, f[e].height, U, y, f[e].data) : t.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, x, f[e].width, f[e].height, 0, U, y, f[e].data);
                                for (let n = 0; n < b.length; n++) {
                                    const r = b[n].image[e].image;
                                    M ? S && t.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, 0, 0, r.width, r.height, U, y, r.data) : t.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, x, r.width, r.height, 0, U, y, r.data)
                                }
                            } else {
                                M ? S && t.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, U, y, f[e]) : t.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, x, U, y, f[e]);
                                for (let n = 0; n < b.length; n++) {
                                    const r = b[n];
                                    M ? S && t.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, 0, 0, U, y, r.image[e]) : t.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, x, U, y, r.image[e])
                                }
                            }
                        }
                        B(a, E) && w(A.TEXTURE_CUBE_MAP), u.__version = c.version, a.onUpdate && a.onUpdate(a)
                    }
                    e.__version = a.version
                }(o, e, a) : t.bindTexture(A.TEXTURE_CUBE_MAP, o.__webglTexture, A.TEXTURE0 + a)
            }, this.rebindTextures = function (e, t, r) {
                const i = n.get(e);
                void 0 !== t && L(i.__webglFramebuffer, e, e.texture, A.COLOR_ATTACHMENT0, A.TEXTURE_2D, 0), void 0 !== r && H(e)
            }, this.setupRenderTarget = function (e) {
                const o = e.texture, l = n.get(e), c = n.get(o);
                e.addEventListener("dispose", U);
                const u = e.textures, h = !0 === e.isWebGLCubeRenderTarget, d = u.length > 1, p = m(e) || s;
                if (d || (void 0 === c.__webglTexture && (c.__webglTexture = A.createTexture()), c.__version = o.version, a.memory.textures++), h) {
                    l.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++) if (s && o.mipmaps && o.mipmaps.length > 0) {
                        l.__webglFramebuffer[e] = [];
                        for (let t = 0; t < o.mipmaps.length; t++) l.__webglFramebuffer[e][t] = A.createFramebuffer()
                    } else l.__webglFramebuffer[e] = A.createFramebuffer()
                } else {
                    if (s && o.mipmaps && o.mipmaps.length > 0) {
                        l.__webglFramebuffer = [];
                        for (let e = 0; e < o.mipmaps.length; e++) l.__webglFramebuffer[e] = A.createFramebuffer()
                    } else l.__webglFramebuffer = A.createFramebuffer();
                    if (d) if (r.drawBuffers) for (let e = 0, t = u.length; e < t; e++) {
                        const t = n.get(u[e]);
                        void 0 === t.__webglTexture && (t.__webglTexture = A.createTexture(), a.memory.textures++)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (s && e.samples > 0 && !1 === eA(e)) {
                        l.__webglMultisampledFramebuffer = A.createFramebuffer(), l.__webglColorRenderbuffer = [], t.bindFramebuffer(A.FRAMEBUFFER, l.__webglMultisampledFramebuffer);
                        for (let t = 0; t < u.length; t++) {
                            const n = u[t];
                            l.__webglColorRenderbuffer[t] = A.createRenderbuffer(), A.bindRenderbuffer(A.RENDERBUFFER, l.__webglColorRenderbuffer[t]);
                            const r = i.convert(n.format, n.colorSpace), a = i.convert(n.type),
                                s = v(n.internalFormat, r, a, n.colorSpace, !0 === e.isXRRenderTarget), o = D(e);
                            A.renderbufferStorageMultisample(A.RENDERBUFFER, o, s, e.width, e.height), A.framebufferRenderbuffer(A.FRAMEBUFFER, A.COLOR_ATTACHMENT0 + t, A.RENDERBUFFER, l.__webglColorRenderbuffer[t])
                        }
                        A.bindRenderbuffer(A.RENDERBUFFER, null), e.depthBuffer && (l.__webglDepthRenderbuffer = A.createRenderbuffer(), R(l.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(A.FRAMEBUFFER, null)
                    }
                }
                if (h) {
                    t.bindTexture(A.TEXTURE_CUBE_MAP, c.__webglTexture), Q(A.TEXTURE_CUBE_MAP, o, p);
                    for (let t = 0; t < 6; t++) if (s && o.mipmaps && o.mipmaps.length > 0) for (let n = 0; n < o.mipmaps.length; n++) L(l.__webglFramebuffer[t][n], e, o, A.COLOR_ATTACHMENT0, A.TEXTURE_CUBE_MAP_POSITIVE_X + t, n); else L(l.__webglFramebuffer[t], e, o, A.COLOR_ATTACHMENT0, A.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0);
                    B(o, p) && w(A.TEXTURE_CUBE_MAP), t.unbindTexture()
                } else if (d) {
                    for (let r = 0, i = u.length; r < i; r++) {
                        const i = u[r], a = n.get(i);
                        t.bindTexture(A.TEXTURE_2D, a.__webglTexture), Q(A.TEXTURE_2D, i, p), L(l.__webglFramebuffer, e, i, A.COLOR_ATTACHMENT0 + r, A.TEXTURE_2D, 0), B(i, p) && w(A.TEXTURE_2D)
                    }
                    t.unbindTexture()
                } else {
                    let n = A.TEXTURE_2D;
                    if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (s ? n = e.isWebGL3DRenderTarget ? A.TEXTURE_3D : A.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(n, c.__webglTexture), Q(n, o, p), s && o.mipmaps && o.mipmaps.length > 0) for (let t = 0; t < o.mipmaps.length; t++) L(l.__webglFramebuffer[t], e, o, A.COLOR_ATTACHMENT0, n, t); else L(l.__webglFramebuffer, e, o, A.COLOR_ATTACHMENT0, n, 0);
                    B(o, p) && w(n), t.unbindTexture()
                }
                e.depthBuffer && H(e)
            }, this.updateRenderTargetMipmap = function (e) {
                const r = m(e) || s, i = e.textures;
                for (let a = 0, s = i.length; a < s; a++) {
                    const s = i[a];
                    if (B(s, r)) {
                        const r = e.isWebGLCubeRenderTarget ? A.TEXTURE_CUBE_MAP : A.TEXTURE_2D,
                            i = n.get(s).__webglTexture;
                        t.bindTexture(r, i), w(r), t.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function (e) {
                if (s && e.samples > 0 && !1 === eA(e)) {
                    const r = e.textures, i = e.width, a = e.height;
                    let s = A.COLOR_BUFFER_BIT;
                    const o = [], c = e.stencilBuffer ? A.DEPTH_STENCIL_ATTACHMENT : A.DEPTH_ATTACHMENT, u = n.get(e),
                        h = r.length > 1;
                    if (h) for (let e = 0; e < r.length; e++) t.bindFramebuffer(A.FRAMEBUFFER, u.__webglMultisampledFramebuffer), A.framebufferRenderbuffer(A.FRAMEBUFFER, A.COLOR_ATTACHMENT0 + e, A.RENDERBUFFER, null), t.bindFramebuffer(A.FRAMEBUFFER, u.__webglFramebuffer), A.framebufferTexture2D(A.DRAW_FRAMEBUFFER, A.COLOR_ATTACHMENT0 + e, A.TEXTURE_2D, null, 0);
                    t.bindFramebuffer(A.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer), t.bindFramebuffer(A.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                    for (let t = 0; t < r.length; t++) {
                        o.push(A.COLOR_ATTACHMENT0 + t), e.depthBuffer && o.push(c);
                        const d = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                        if (!1 === d && (e.depthBuffer && (s |= A.DEPTH_BUFFER_BIT), e.stencilBuffer && (s |= A.STENCIL_BUFFER_BIT)), h && A.framebufferRenderbuffer(A.READ_FRAMEBUFFER, A.COLOR_ATTACHMENT0, A.RENDERBUFFER, u.__webglColorRenderbuffer[t]), !0 === d && (A.invalidateFramebuffer(A.READ_FRAMEBUFFER, [c]), A.invalidateFramebuffer(A.DRAW_FRAMEBUFFER, [c])), h) {
                            const e = n.get(r[t]).__webglTexture;
                            A.framebufferTexture2D(A.DRAW_FRAMEBUFFER, A.COLOR_ATTACHMENT0, A.TEXTURE_2D, e, 0)
                        }
                        A.blitFramebuffer(0, 0, i, a, 0, 0, i, a, s, A.NEAREST), l && A.invalidateFramebuffer(A.READ_FRAMEBUFFER, o)
                    }
                    if (t.bindFramebuffer(A.READ_FRAMEBUFFER, null), t.bindFramebuffer(A.DRAW_FRAMEBUFFER, null), h) for (let e = 0; e < r.length; e++) {
                        t.bindFramebuffer(A.FRAMEBUFFER, u.__webglMultisampledFramebuffer), A.framebufferRenderbuffer(A.FRAMEBUFFER, A.COLOR_ATTACHMENT0 + e, A.RENDERBUFFER, u.__webglColorRenderbuffer[e]);
                        const i = n.get(r[e]).__webglTexture;
                        t.bindFramebuffer(A.FRAMEBUFFER, u.__webglFramebuffer), A.framebufferTexture2D(A.DRAW_FRAMEBUFFER, A.COLOR_ATTACHMENT0 + e, A.TEXTURE_2D, i, 0)
                    }
                    t.bindFramebuffer(A.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = H, this.setupFrameBufferTexture = L, this.useMultisampledRTT = eA
        }

        function ua(A, e, t) {
            const n = t.isWebGL2;
            return {
                convert: function (t, r = "") {
                    let i;
                    const a = YA.getTransfer(r);
                    if (t === W) return A.UNSIGNED_BYTE;
                    if (1017 === t) return A.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === t) return A.UNSIGNED_SHORT_5_5_5_1;
                    if (1010 === t) return A.BYTE;
                    if (1011 === t) return A.SHORT;
                    if (t === X) return A.UNSIGNED_SHORT;
                    if (1013 === t) return A.INT;
                    if (t === Y) return A.UNSIGNED_INT;
                    if (t === J) return A.FLOAT;
                    if (t === j) return n ? A.HALF_FLOAT : (i = e.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null);
                    if (1021 === t) return A.ALPHA;
                    if (t === q) return A.RGBA;
                    if (1024 === t) return A.LUMINANCE;
                    if (1025 === t) return A.LUMINANCE_ALPHA;
                    if (t === $) return A.DEPTH_COMPONENT;
                    if (t === AA) return A.DEPTH_STENCIL;
                    if (t === vA) return i = e.get("EXT_sRGB"), null !== i ? i.SRGB_ALPHA_EXT : null;
                    if (1028 === t) return A.RED;
                    if (1029 === t) return A.RED_INTEGER;
                    if (1030 === t) return A.RG;
                    if (1031 === t) return A.RG_INTEGER;
                    if (1033 === t) return A.RGBA_INTEGER;
                    if (t === eA || t === tA || t === nA || t === rA) if (a === fA) {
                        if (i = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === i) return null;
                        if (t === eA) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (t === tA) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (t === nA) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (t === rA) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    } else {
                        if (i = e.get("WEBGL_compressed_texture_s3tc"), null === i) return null;
                        if (t === eA) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (t === tA) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (t === nA) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (t === rA) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                        if (i = e.get("WEBGL_compressed_texture_pvrtc"), null === i) return null;
                        if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t) return i = e.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (37492 === t || 37496 === t) {
                        if (i = e.get("WEBGL_compressed_texture_etc"), null === i) return null;
                        if (37492 === t) return a === fA ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
                        if (37496 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) {
                        if (i = e.get("WEBGL_compressed_texture_astc"), null === i) return null;
                        if (37808 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (37812 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === t) return a === fA ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (t === iA || 36494 === t || 36495 === t) {
                        if (i = e.get("EXT_texture_compression_bptc"), null === i) return null;
                        if (t === iA) return a === fA ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (36494 === t) return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (36495 === t) return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (36283 === t || 36284 === t || 36285 === t || 36286 === t) {
                        if (i = e.get("EXT_texture_compression_rgtc"), null === i) return null;
                        if (t === iA) return i.COMPRESSED_RED_RGTC1_EXT;
                        if (36284 === t) return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (36285 === t) return i.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (36286 === t) return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return t === Z ? n ? A.UNSIGNED_INT_24_8 : (i = e.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== A[t] ? A[t] : null
                }
            }
        }

        class ha extends Un {
            constructor(A = []) {
                super(), this.isArrayCamera = !0, this.cameras = A
            }
        }

        class da extends dt {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }

        const pa = {type: "move"};

        class fa {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }

            getHandSpace() {
                return null === this._hand && (this._hand = new da, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {pinching: !1}), this._hand
            }

            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new da, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ce, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ce), this._targetRay
            }

            getGripSpace() {
                return null === this._grip && (this._grip = new da, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ce, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ce), this._grip
            }

            dispatchEvent(A) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(A), null !== this._grip && this._grip.dispatchEvent(A), null !== this._hand && this._hand.dispatchEvent(A), this
            }

            connect(A) {
                if (A && A.hand) {
                    const e = this._hand;
                    if (e) for (const t of A.hand.values()) this._getHandJoint(e, t)
                }
                return this.dispatchEvent({type: "connected", data: A}), this
            }

            disconnect(A) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: A
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }

            update(A, e, t) {
                let n = null, r = null, i = null;
                const a = this._targetRay, s = this._grip, o = this._hand;
                if (A && "visible-blurred" !== e.session.visibilityState) {
                    if (o && A.hand) {
                        i = !0;
                        for (const n of A.hand.values()) {
                            const A = e.getJointPose(n, t), r = this._getHandJoint(o, n);
                            null !== A && (r.matrix.fromArray(A.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = A.radius), r.visible = null !== A
                        }
                        const n = o.joints["index-finger-tip"], r = o.joints["thumb-tip"],
                            a = n.position.distanceTo(r.position), s = .02, l = .005;
                        o.inputState.pinching && a > s + l ? (o.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: A.handedness,
                            target: this
                        })) : !o.inputState.pinching && a <= s - l && (o.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: A.handedness,
                            target: this
                        }))
                    } else null !== s && A.gripSpace && (r = e.getPose(A.gripSpace, t), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = !1, r.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = !1));
                    null !== a && (n = e.getPose(A.targetRaySpace, t), null === n && null !== r && (n = r), null !== n && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(pa)))
                }
                return null !== a && (a.visible = null !== n), null !== s && (s.visible = null !== r), null !== o && (o.visible = null !== i), this
            }

            _getHandJoint(A, e) {
                if (void 0 === A.joints[e.jointName]) {
                    const t = new da;
                    t.matrixAutoUpdate = !1, t.visible = !1, A.joints[e.jointName] = t, A.add(t)
                }
                return A.joints[e.jointName]
            }
        }

        class ga {
            constructor() {
                this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
            }

            init(A, e, t) {
                if (null === this.texture) {
                    const n = new ne;
                    A.properties.get(n).__webglTexture = e.texture, e.depthNear == t.depthNear && e.depthFar == t.depthFar || (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = n
                }
            }

            render(A, e) {
                if (null !== this.texture) {
                    if (null === this.mesh) {
                        const A = e.cameras[0].viewport, t = new wn({
                            extensions: {fragDepth: !0},
                            vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                            fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                            uniforms: {
                                depthColor: {value: this.texture},
                                depthWidth: {value: A.z},
                                depthHeight: {value: A.w}
                            }
                        });
                        this.mesh = new hn(new Pn(20, 20), t)
                    }
                    A.render(this.mesh, e)
                }
            }

            reset() {
                this.texture = null, this.mesh = null
            }
        }

        class ma extends EA {
            constructor(A, e) {
                super();
                const t = this;
                let n = null, r = 1, i = null, a = "local-floor", s = 1, o = null, l = null, c = null, u = null,
                    h = null, d = null;
                const p = new ga, f = e.getContextAttributes();
                let g = null, m = null;
                const B = [], w = [], v = new DA;
                let _ = null;
                const C = new Un;
                C.layers.enable(1), C.viewport = new re;
                const E = new Un;
                E.layers.enable(2), E.viewport = new re;
                const U = [C, E], y = new ha;
                y.layers.enable(1), y.layers.enable(2);
                let x = null, M = null;

                function F(A) {
                    const e = w.indexOf(A.inputSource);
                    if (-1 === e) return;
                    const t = B[e];
                    void 0 !== t && (t.update(A.inputSource, A.frame, o || i), t.dispatchEvent({
                        type: A.type,
                        data: A.inputSource
                    }))
                }

                function S() {
                    n.removeEventListener("select", F), n.removeEventListener("selectstart", F), n.removeEventListener("selectend", F), n.removeEventListener("squeeze", F), n.removeEventListener("squeezestart", F), n.removeEventListener("squeezeend", F), n.removeEventListener("end", S), n.removeEventListener("inputsourceschange", b);
                    for (let A = 0; A < B.length; A++) {
                        const e = w[A];
                        null !== e && (w[A] = null, B[A].disconnect(e))
                    }
                    x = null, M = null, p.reset(), A.setRenderTarget(g), h = null, u = null, c = null, n = null, m = null, R.stop(), t.isPresenting = !1, A.setPixelRatio(_), A.setSize(v.width, v.height, !1), t.dispatchEvent({type: "sessionend"})
                }

                function b(A) {
                    for (let e = 0; e < A.removed.length; e++) {
                        const t = A.removed[e], n = w.indexOf(t);
                        n >= 0 && (w[n] = null, B[n].disconnect(t))
                    }
                    for (let e = 0; e < A.added.length; e++) {
                        const t = A.added[e];
                        let n = w.indexOf(t);
                        if (-1 === n) {
                            for (let A = 0; A < B.length; A++) {
                                if (A >= w.length) {
                                    w.push(t), n = A;
                                    break
                                }
                                if (null === w[A]) {
                                    w[A] = t, n = A;
                                    break
                                }
                            }
                            if (-1 === n) break
                        }
                        const r = B[n];
                        r && r.connect(t)
                    }
                }

                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (A) {
                    let e = B[A];
                    return void 0 === e && (e = new fa, B[A] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function (A) {
                    let e = B[A];
                    return void 0 === e && (e = new fa, B[A] = e), e.getGripSpace()
                }, this.getHand = function (A) {
                    let e = B[A];
                    return void 0 === e && (e = new fa, B[A] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function (A) {
                    r = A, !0 === t.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function (A) {
                    a = A, !0 === t.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function () {
                    return o || i
                }, this.setReferenceSpace = function (A) {
                    o = A
                }, this.getBaseLayer = function () {
                    return null !== u ? u : h
                }, this.getBinding = function () {
                    return c
                }, this.getFrame = function () {
                    return d
                }, this.getSession = function () {
                    return n
                }, this.setSession = async function (l) {
                    if (n = l, null !== n) {
                        if (g = A.getRenderTarget(), n.addEventListener("select", F), n.addEventListener("selectstart", F), n.addEventListener("selectend", F), n.addEventListener("squeeze", F), n.addEventListener("squeezestart", F), n.addEventListener("squeezeend", F), n.addEventListener("end", S), n.addEventListener("inputsourceschange", b), !0 !== f.xrCompatible && await e.makeXRCompatible(), _ = A.getPixelRatio(), A.getSize(v), void 0 === n.renderState.layers || !1 === A.capabilities.isWebGL2) {
                            const t = {
                                antialias: void 0 !== n.renderState.layers || f.antialias,
                                alpha: !0,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: r
                            };
                            h = new XRWebGLLayer(n, e, t), n.updateRenderState({baseLayer: h}), A.setPixelRatio(1), A.setSize(h.framebufferWidth, h.framebufferHeight, !1), m = new ae(h.framebufferWidth, h.framebufferHeight, {
                                format: q,
                                type: W,
                                colorSpace: A.outputColorSpace,
                                stencilBuffer: f.stencil
                            })
                        } else {
                            let t = null, i = null, a = null;
                            f.depth && (a = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, t = f.stencil ? AA : $, i = f.stencil ? Z : Y);
                            const s = {colorFormat: e.RGBA8, depthFormat: a, scaleFactor: r};
                            c = new XRWebGLBinding(n, e), u = c.createProjectionLayer(s), n.updateRenderState({layers: [u]}), A.setPixelRatio(1), A.setSize(u.textureWidth, u.textureHeight, !1), m = new ae(u.textureWidth, u.textureHeight, {
                                format: q,
                                type: W,
                                depthTexture: new _r(u.textureWidth, u.textureHeight, i, void 0, void 0, void 0, void 0, void 0, void 0, t),
                                stencilBuffer: f.stencil,
                                colorSpace: A.outputColorSpace,
                                samples: f.antialias ? 4 : 0
                            }), A.properties.get(m).__ignoreDepthValues = u.ignoreDepthValues
                        }
                        m.isXRRenderTarget = !0, this.setFoveation(s), o = null, i = await n.requestReferenceSpace(a), R.setContext(n), R.start(), t.isPresenting = !0, t.dispatchEvent({type: "sessionstart"})
                    }
                }, this.getEnvironmentBlendMode = function () {
                    if (null !== n) return n.environmentBlendMode
                };
                const Q = new ce, T = new ce;

                function I(A, e) {
                    null === e ? A.matrixWorld.copy(A.matrix) : A.matrixWorld.multiplyMatrices(e.matrixWorld, A.matrix), A.matrixWorldInverse.copy(A.matrixWorld).invert()
                }

                this.updateCamera = function (A) {
                    if (null === n) return;
                    null !== p.texture && (A.near = p.depthNear, A.far = p.depthFar), y.near = E.near = C.near = A.near, y.far = E.far = C.far = A.far, x === y.near && M === y.far || (n.updateRenderState({
                        depthNear: y.near,
                        depthFar: y.far
                    }), x = y.near, M = y.far, C.near = x, C.far = M, E.near = x, E.far = M, C.updateProjectionMatrix(), E.updateProjectionMatrix(), A.updateProjectionMatrix());
                    const e = A.parent, t = y.cameras;
                    I(y, e);
                    for (let A = 0; A < t.length; A++) I(t[A], e);
                    2 === t.length ? function (A, e, t) {
                        Q.setFromMatrixPosition(e.matrixWorld), T.setFromMatrixPosition(t.matrixWorld);
                        const n = Q.distanceTo(T), r = e.projectionMatrix.elements, i = t.projectionMatrix.elements,
                            a = r[14] / (r[10] - 1), s = r[14] / (r[10] + 1), o = (r[9] + 1) / r[5],
                            l = (r[9] - 1) / r[5], c = (r[8] - 1) / r[0], u = (i[8] + 1) / i[0], h = a * c, d = a * u,
                            p = n / (-c + u), f = p * -c;
                        e.matrixWorld.decompose(A.position, A.quaternion, A.scale), A.translateX(f), A.translateZ(p), A.matrixWorld.compose(A.position, A.quaternion, A.scale), A.matrixWorldInverse.copy(A.matrixWorld).invert();
                        const g = a + p, m = s + p, B = h - f, w = d + (n - f), v = o * s / m * g, _ = l * s / m * g;
                        A.projectionMatrix.makePerspective(B, w, v, _, g, m), A.projectionMatrixInverse.copy(A.projectionMatrix).invert()
                    }(y, C, E) : y.projectionMatrix.copy(C.projectionMatrix), function (A, e, t) {
                        null === t ? A.matrix.copy(e.matrixWorld) : (A.matrix.copy(t.matrixWorld), A.matrix.invert(), A.matrix.multiply(e.matrixWorld)), A.matrix.decompose(A.position, A.quaternion, A.scale), A.updateMatrixWorld(!0), A.projectionMatrix.copy(e.projectionMatrix), A.projectionMatrixInverse.copy(e.projectionMatrixInverse), A.isPerspectiveCamera && (A.fov = 2 * MA * Math.atan(1 / A.projectionMatrix.elements[5]), A.zoom = 1)
                    }(A, y, e)
                }, this.getCamera = function () {
                    return y
                }, this.getFoveation = function () {
                    if (null !== u || null !== h) return s
                }, this.setFoveation = function (A) {
                    s = A, null !== u && (u.fixedFoveation = A), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = A)
                }, this.hasDepthSensing = function () {
                    return null !== p.texture
                };
                let L = null;
                const R = new Hn;
                R.setAnimationLoop((function (e, r) {
                    if (l = r.getViewerPose(o || i), d = r, null !== l) {
                        const e = l.views;
                        null !== h && (A.setRenderTargetFramebuffer(m, h.framebuffer), A.setRenderTarget(m));
                        let t = !1;
                        e.length !== y.cameras.length && (y.cameras.length = 0, t = !0);
                        for (let n = 0; n < e.length; n++) {
                            const r = e[n];
                            let i = null;
                            if (null !== h) i = h.getViewport(r); else {
                                const e = c.getViewSubImage(u, r);
                                i = e.viewport, 0 === n && (A.setRenderTargetTextures(m, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), A.setRenderTarget(m))
                            }
                            let a = U[n];
                            void 0 === a && (a = new Un, a.layers.enable(n), a.viewport = new re, U[n] = a), a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.projectionMatrix.fromArray(r.projectionMatrix), a.projectionMatrixInverse.copy(a.projectionMatrix).invert(), a.viewport.set(i.x, i.y, i.width, i.height), 0 === n && (y.matrix.copy(a.matrix), y.matrix.decompose(y.position, y.quaternion, y.scale)), !0 === t && y.cameras.push(a)
                        }
                        const r = n.enabledFeatures;
                        if (r && r.includes("depth-sensing")) {
                            const t = c.getDepthInformation(e[0]);
                            t && t.isValid && t.texture && p.init(A, t, n.renderState)
                        }
                    }
                    for (let A = 0; A < B.length; A++) {
                        const e = w[A], t = B[A];
                        null !== e && void 0 !== t && t.update(e, r, o || i)
                    }
                    p.render(A, y), L && L(e, r), r.detectedPlanes && t.dispatchEvent({
                        type: "planesdetected",
                        data: r
                    }), d = null
                })), this.setAnimationLoop = function (A) {
                    L = A
                }, this.dispose = function () {
                }
            }
        }

        const Ba = new je, wa = new Oe;

        function va(A, e) {
            function t(A, e) {
                !0 === A.matrixAutoUpdate && A.updateMatrix(), e.value.copy(A.matrix)
            }

            function n(n, r) {
                n.opacity.value = r.opacity, r.color && n.diffuse.value.copy(r.color), r.emissive && n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (n.map.value = r.map, t(r.map, n.mapTransform)), r.alphaMap && (n.alphaMap.value = r.alphaMap, t(r.alphaMap, n.alphaMapTransform)), r.bumpMap && (n.bumpMap.value = r.bumpMap, t(r.bumpMap, n.bumpMapTransform), n.bumpScale.value = r.bumpScale, 1 === r.side && (n.bumpScale.value *= -1)), r.normalMap && (n.normalMap.value = r.normalMap, t(r.normalMap, n.normalMapTransform), n.normalScale.value.copy(r.normalScale), 1 === r.side && n.normalScale.value.negate()), r.displacementMap && (n.displacementMap.value = r.displacementMap, t(r.displacementMap, n.displacementMapTransform), n.displacementScale.value = r.displacementScale, n.displacementBias.value = r.displacementBias), r.emissiveMap && (n.emissiveMap.value = r.emissiveMap, t(r.emissiveMap, n.emissiveMapTransform)), r.specularMap && (n.specularMap.value = r.specularMap, t(r.specularMap, n.specularMapTransform)), r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
                const i = e.get(r), a = i.envMap, s = i.envMapRotation;
                if (a && (n.envMap.value = a, Ba.copy(s), Ba.x *= -1, Ba.y *= -1, Ba.z *= -1, a.isCubeTexture && !1 === a.isRenderTargetTexture && (Ba.y *= -1, Ba.z *= -1), n.envMapRotation.value.setFromMatrix4(wa.makeRotationFromEuler(Ba)), n.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = r.reflectivity, n.ior.value = r.ior, n.refractionRatio.value = r.refractionRatio), r.lightMap) {
                    n.lightMap.value = r.lightMap;
                    const e = !0 === A._useLegacyLights ? Math.PI : 1;
                    n.lightMapIntensity.value = r.lightMapIntensity * e, t(r.lightMap, n.lightMapTransform)
                }
                r.aoMap && (n.aoMap.value = r.aoMap, n.aoMapIntensity.value = r.aoMapIntensity, t(r.aoMap, n.aoMapTransform))
            }

            return {
                refreshFogUniforms: function (e, t) {
                    t.color.getRGB(e.fogColor.value, mn(A)), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                }, refreshMaterialUniforms: function (A, r, i, a, s) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(A, r) : r.isMeshToonMaterial ? (n(A, r), function (A, e) {
                        e.gradientMap && (A.gradientMap.value = e.gradientMap)
                    }(A, r)) : r.isMeshPhongMaterial ? (n(A, r), function (A, e) {
                        A.specular.value.copy(e.specular), A.shininess.value = Math.max(e.shininess, 1e-4)
                    }(A, r)) : r.isMeshStandardMaterial ? (n(A, r), function (A, n) {
                        A.metalness.value = n.metalness, n.metalnessMap && (A.metalnessMap.value = n.metalnessMap, t(n.metalnessMap, A.metalnessMapTransform)), A.roughness.value = n.roughness, n.roughnessMap && (A.roughnessMap.value = n.roughnessMap, t(n.roughnessMap, A.roughnessMapTransform));
                        e.get(n).envMap && (A.envMapIntensity.value = n.envMapIntensity)
                    }(A, r), r.isMeshPhysicalMaterial && function (A, e, n) {
                        A.ior.value = e.ior, e.sheen > 0 && (A.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), A.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (A.sheenColorMap.value = e.sheenColorMap, t(e.sheenColorMap, A.sheenColorMapTransform)), e.sheenRoughnessMap && (A.sheenRoughnessMap.value = e.sheenRoughnessMap, t(e.sheenRoughnessMap, A.sheenRoughnessMapTransform))), e.clearcoat > 0 && (A.clearcoat.value = e.clearcoat, A.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (A.clearcoatMap.value = e.clearcoatMap, t(e.clearcoatMap, A.clearcoatMapTransform)), e.clearcoatRoughnessMap && (A.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, t(e.clearcoatRoughnessMap, A.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (A.clearcoatNormalMap.value = e.clearcoatNormalMap, t(e.clearcoatNormalMap, A.clearcoatNormalMapTransform), A.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), 1 === e.side && A.clearcoatNormalScale.value.negate())), e.iridescence > 0 && (A.iridescence.value = e.iridescence, A.iridescenceIOR.value = e.iridescenceIOR, A.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], A.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (A.iridescenceMap.value = e.iridescenceMap, t(e.iridescenceMap, A.iridescenceMapTransform)), e.iridescenceThicknessMap && (A.iridescenceThicknessMap.value = e.iridescenceThicknessMap, t(e.iridescenceThicknessMap, A.iridescenceThicknessMapTransform))), e.transmission > 0 && (A.transmission.value = e.transmission, A.transmissionSamplerMap.value = n.texture, A.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (A.transmissionMap.value = e.transmissionMap, t(e.transmissionMap, A.transmissionMapTransform)), A.thickness.value = e.thickness, e.thicknessMap && (A.thicknessMap.value = e.thicknessMap, t(e.thicknessMap, A.thicknessMapTransform)), A.attenuationDistance.value = e.attenuationDistance, A.attenuationColor.value.copy(e.attenuationColor)), e.anisotropy > 0 && (A.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (A.anisotropyMap.value = e.anisotropyMap, t(e.anisotropyMap, A.anisotropyMapTransform))), A.specularIntensity.value = e.specularIntensity, A.specularColor.value.copy(e.specularColor), e.specularColorMap && (A.specularColorMap.value = e.specularColorMap, t(e.specularColorMap, A.specularColorMapTransform)), e.specularIntensityMap && (A.specularIntensityMap.value = e.specularIntensityMap, t(e.specularIntensityMap, A.specularIntensityMapTransform))
                    }(A, r, s)) : r.isMeshMatcapMaterial ? (n(A, r), function (A, e) {
                        e.matcap && (A.matcap.value = e.matcap)
                    }(A, r)) : r.isMeshDepthMaterial ? n(A, r) : r.isMeshDistanceMaterial ? (n(A, r), function (A, t) {
                        const n = e.get(t).light;
                        A.referencePosition.value.setFromMatrixPosition(n.matrixWorld), A.nearDistance.value = n.shadow.camera.near, A.farDistance.value = n.shadow.camera.far
                    }(A, r)) : r.isMeshNormalMaterial ? n(A, r) : r.isLineBasicMaterial ? (function (A, e) {
                        A.diffuse.value.copy(e.color), A.opacity.value = e.opacity, e.map && (A.map.value = e.map, t(e.map, A.mapTransform))
                    }(A, r), r.isLineDashedMaterial && function (A, e) {
                        A.dashSize.value = e.dashSize, A.totalSize.value = e.dashSize + e.gapSize, A.scale.value = e.scale
                    }(A, r)) : r.isPointsMaterial ? function (A, e, n, r) {
                        A.diffuse.value.copy(e.color), A.opacity.value = e.opacity, A.size.value = e.size * n, A.scale.value = .5 * r, e.map && (A.map.value = e.map, t(e.map, A.uvTransform)), e.alphaMap && (A.alphaMap.value = e.alphaMap, t(e.alphaMap, A.alphaMapTransform)), e.alphaTest > 0 && (A.alphaTest.value = e.alphaTest)
                    }(A, r, i, a) : r.isSpriteMaterial ? function (A, e) {
                        A.diffuse.value.copy(e.color), A.opacity.value = e.opacity, A.rotation.value = e.rotation, e.map && (A.map.value = e.map, t(e.map, A.mapTransform)), e.alphaMap && (A.alphaMap.value = e.alphaMap, t(e.alphaMap, A.alphaMapTransform)), e.alphaTest > 0 && (A.alphaTest.value = e.alphaTest)
                    }(A, r) : r.isShadowMaterial ? (A.color.value.copy(r.color), A.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }

        function _a(A, e, t, n) {
            let r = {}, i = {}, a = [];
            const s = t.isWebGL2 ? A.getParameter(A.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

            function o(A, e, t, n) {
                const r = A.value, i = e + "_" + t;
                if (void 0 === n[i]) return n[i] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0;
                {
                    const A = n[i];
                    if ("number" == typeof r || "boolean" == typeof r) {
                        if (A !== r) return n[i] = r, !0
                    } else if (!1 === A.equals(r)) return A.copy(r), !0
                }
                return !1
            }

            function l(A) {
                const e = {boundary: 0, storage: 0};
                return "number" == typeof A || "boolean" == typeof A ? (e.boundary = 4, e.storage = 4) : A.isVector2 ? (e.boundary = 8, e.storage = 8) : A.isVector3 || A.isColor ? (e.boundary = 16, e.storage = 12) : A.isVector4 ? (e.boundary = 16, e.storage = 16) : A.isMatrix3 ? (e.boundary = 48, e.storage = 48) : A.isMatrix4 ? (e.boundary = 64, e.storage = 64) : A.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", A), e
            }

            function c(e) {
                const t = e.target;
                t.removeEventListener("dispose", c);
                const n = a.indexOf(t.__bindingPointIndex);
                a.splice(n, 1), A.deleteBuffer(r[t.id]), delete r[t.id], delete i[t.id]
            }

            return {
                bind: function (A, e) {
                    const t = e.program;
                    n.uniformBlockBinding(A, t)
                }, update: function (t, u) {
                    let h = r[t.id];
                    void 0 === h && (function (A) {
                        const e = A.uniforms;
                        let t = 0;
                        for (let A = 0, n = e.length; A < n; A++) {
                            const n = Array.isArray(e[A]) ? e[A] : [e[A]];
                            for (let A = 0, e = n.length; A < e; A++) {
                                const e = n[A], r = Array.isArray(e.value) ? e.value : [e.value];
                                for (let A = 0, n = r.length; A < n; A++) {
                                    const n = l(r[A]), i = t % 16;
                                    0 !== i && 16 - i < n.boundary && (t += 16 - i), e.__data = new Float32Array(n.storage / Float32Array.BYTES_PER_ELEMENT), e.__offset = t, t += n.storage
                                }
                            }
                        }
                        const n = t % 16;
                        n > 0 && (t += 16 - n), A.__size = t, A.__cache = {}
                    }(t), h = function (e) {
                        const t = function () {
                            for (let A = 0; A < s; A++) if (-1 === a.indexOf(A)) return a.push(A), A;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }();
                        e.__bindingPointIndex = t;
                        const n = A.createBuffer(), r = e.__size, i = e.usage;
                        return A.bindBuffer(A.UNIFORM_BUFFER, n), A.bufferData(A.UNIFORM_BUFFER, r, i), A.bindBuffer(A.UNIFORM_BUFFER, null), A.bindBufferBase(A.UNIFORM_BUFFER, t, n), n
                    }(t), r[t.id] = h, t.addEventListener("dispose", c));
                    const d = u.program;
                    n.updateUBOMapping(t, d);
                    const p = e.render.frame;
                    i[t.id] !== p && (function (e) {
                        const t = r[e.id], n = e.uniforms, i = e.__cache;
                        A.bindBuffer(A.UNIFORM_BUFFER, t);
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = Array.isArray(n[e]) ? n[e] : [n[e]];
                            for (let n = 0, r = t.length; n < r; n++) {
                                const r = t[n];
                                if (!0 === o(r, e, n, i)) {
                                    const e = r.__offset, t = Array.isArray(r.value) ? r.value : [r.value];
                                    let n = 0;
                                    for (let i = 0; i < t.length; i++) {
                                        const a = t[i], s = l(a);
                                        "number" == typeof a || "boolean" == typeof a ? (r.__data[0] = a, A.bufferSubData(A.UNIFORM_BUFFER, e + n, r.__data)) : a.isMatrix3 ? (r.__data[0] = a.elements[0], r.__data[1] = a.elements[1], r.__data[2] = a.elements[2], r.__data[3] = 0, r.__data[4] = a.elements[3], r.__data[5] = a.elements[4], r.__data[6] = a.elements[5], r.__data[7] = 0, r.__data[8] = a.elements[6], r.__data[9] = a.elements[7], r.__data[10] = a.elements[8], r.__data[11] = 0) : (a.toArray(r.__data, n), n += s.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    A.bufferSubData(A.UNIFORM_BUFFER, e, r.__data)
                                }
                            }
                        }
                        A.bindBuffer(A.UNIFORM_BUFFER, null)
                    }(t), i[t.id] = p)
                }, dispose: function () {
                    for (const e in r) A.deleteBuffer(r[e]);
                    a = [], r = {}, i = {}
                }
            }
        }

        class Ca {
            constructor(A = {}) {
                const {
                    canvas: e = VA(),
                    context: t = null,
                    depth: n = !0,
                    stencil: r = !0,
                    alpha: i = !1,
                    antialias: a = !1,
                    premultipliedAlpha: s = !0,
                    preserveDrawingBuffer: o = !1,
                    powerPreference: l = "default",
                    failIfMajorPerformanceCaveat: c = !1
                } = A;
                let u;
                this.isWebGLRenderer = !0, u = null !== t ? t.getContextAttributes().alpha : i;
                const h = new Uint32Array(4), d = new Int32Array(4);
                let p = null, f = null;
                const g = [], m = [];
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = cA, this._useLegacyLights = !1, this.toneMapping = M, this.toneMappingExposure = 1;
                const B = this;
                let v = !1, _ = 0, C = 0, E = null, U = -1, y = null;
                const x = new re, F = new re;
                let S = null;
                const b = new St(0);
                let Q = 0, T = e.width, I = e.height, L = 1, R = null, H = null;
                const D = new re(0, 0, T, I), P = new re(0, 0, T, I);
                let N = !1;
                const O = new Rn;
                let G = !1, V = !1, K = null;
                const k = new Oe, $ = new DA, AA = new ce,
                    eA = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0};

                function tA() {
                    return null === E ? L : 1
                }

                let nA, rA, iA, aA, sA, oA, lA, hA, dA, pA, fA, gA, mA, BA, wA, vA, _A, CA, EA, UA, yA, xA, MA, FA,
                    SA = t;

                function bA(A, t) {
                    for (let n = 0; n < A.length; n++) {
                        const r = A[n], i = e.getContext(r, t);
                        if (null !== i) return i
                    }
                    return null
                }

                try {
                    const A = {
                        alpha: !0,
                        depth: n,
                        stencil: r,
                        antialias: a,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: o,
                        powerPreference: l,
                        failIfMajorPerformanceCaveat: c
                    };
                    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${w}`), e.addEventListener("webglcontextlost", LA, !1), e.addEventListener("webglcontextrestored", RA, !1), e.addEventListener("webglcontextcreationerror", HA, !1), null === SA) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === B.isWebGL1Renderer && e.shift(), SA = bA(e, A), null === SA) throw bA(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" != typeof WebGLRenderingContext && SA instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === SA.getShaderPrecisionFormat && (SA.getShaderPrecisionFormat = function () {
                        return {rangeMin: 1, rangeMax: 1, precision: 1}
                    })
                } catch (A) {
                    throw console.error("THREE.WebGLRenderer: " + A.message), A
                }

                function QA() {
                    nA = new dr(SA), rA = new Yn(SA, nA, A), nA.init(rA), xA = new ua(SA, nA, rA), iA = new la(SA, nA, rA), aA = new gr(SA), sA = new Ji, oA = new ca(SA, nA, iA, sA, rA, xA, aA), lA = new jn(B), hA = new hr(B), dA = new Dn(SA, rA), MA = new Wn(SA, nA, dA, rA), pA = new pr(SA, dA, aA, MA), fA = new vr(SA, pA, dA, aA), EA = new wr(SA, rA, oA), vA = new Jn(sA), gA = new Yi(B, lA, hA, nA, rA, MA, vA), mA = new va(B, sA), BA = new $i, wA = new ia(nA, rA), CA = new zn(B, lA, hA, iA, fA, u, s), _A = new oa(B, fA, rA), FA = new _a(SA, aA, rA, iA), UA = new Xn(SA, nA, aA, rA), yA = new fr(SA, nA, aA, rA), aA.programs = gA.programs, B.capabilities = rA, B.extensions = nA, B.properties = sA, B.renderLists = BA, B.shadowMap = _A, B.state = iA, B.info = aA
                }

                QA();
                const TA = new ma(B, SA);

                function LA(A) {
                    A.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0
                }

                function RA() {
                    console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
                    const A = aA.autoReset, e = _A.enabled, t = _A.autoUpdate, n = _A.needsUpdate, r = _A.type;
                    QA(), aA.autoReset = A, _A.enabled = e, _A.autoUpdate = t, _A.needsUpdate = n, _A.type = r
                }

                function HA(A) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", A.statusMessage)
                }

                function PA(A) {
                    const e = A.target;
                    e.removeEventListener("dispose", PA), function (A) {
                        (function (A) {
                            const e = sA.get(A).programs;
                            void 0 !== e && (e.forEach((function (A) {
                                gA.releaseProgram(A)
                            })), A.isShaderMaterial && gA.releaseShaderCache(A))
                        })(A), sA.remove(A)
                    }(e)
                }

                function NA(A, e, t) {
                    !0 === A.transparent && 2 === A.side && !1 === A.forceSinglePass ? (A.side = 1, A.needsUpdate = !0, JA(A, e, t), A.side = 0, A.needsUpdate = !0, JA(A, e, t), A.side = 2) : JA(A, e, t)
                }

                this.xr = TA, this.getContext = function () {
                    return SA
                }, this.getContextAttributes = function () {
                    return SA.getContextAttributes()
                }, this.forceContextLoss = function () {
                    const A = nA.get("WEBGL_lose_context");
                    A && A.loseContext()
                }, this.forceContextRestore = function () {
                    const A = nA.get("WEBGL_lose_context");
                    A && A.restoreContext()
                }, this.getPixelRatio = function () {
                    return L
                }, this.setPixelRatio = function (A) {
                    void 0 !== A && (L = A, this.setSize(T, I, !1))
                }, this.getSize = function (A) {
                    return A.set(T, I)
                }, this.setSize = function (A, t, n = !0) {
                    TA.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = A, I = t, e.width = Math.floor(A * L), e.height = Math.floor(t * L), !0 === n && (e.style.width = A + "px", e.style.height = t + "px"), this.setViewport(0, 0, A, t))
                }, this.getDrawingBufferSize = function (A) {
                    return A.set(T * L, I * L).floor()
                }, this.setDrawingBufferSize = function (A, t, n) {
                    T = A, I = t, L = n, e.width = Math.floor(A * n), e.height = Math.floor(t * n), this.setViewport(0, 0, A, t)
                }, this.getCurrentViewport = function (A) {
                    return A.copy(x)
                }, this.getViewport = function (A) {
                    return A.copy(D)
                }, this.setViewport = function (A, e, t, n) {
                    A.isVector4 ? D.set(A.x, A.y, A.z, A.w) : D.set(A, e, t, n), iA.viewport(x.copy(D).multiplyScalar(L).round())
                }, this.getScissor = function (A) {
                    return A.copy(P)
                }, this.setScissor = function (A, e, t, n) {
                    A.isVector4 ? P.set(A.x, A.y, A.z, A.w) : P.set(A, e, t, n), iA.scissor(F.copy(P).multiplyScalar(L).round())
                }, this.getScissorTest = function () {
                    return N
                }, this.setScissorTest = function (A) {
                    iA.setScissorTest(N = A)
                }, this.setOpaqueSort = function (A) {
                    R = A
                }, this.setTransparentSort = function (A) {
                    H = A
                }, this.getClearColor = function (A) {
                    return A.copy(CA.getClearColor())
                }, this.setClearColor = function () {
                    CA.setClearColor.apply(CA, arguments)
                }, this.getClearAlpha = function () {
                    return CA.getClearAlpha()
                }, this.setClearAlpha = function () {
                    CA.setClearAlpha.apply(CA, arguments)
                }, this.clear = function (A = !0, e = !0, t = !0) {
                    let n = 0;
                    if (A) {
                        let A = !1;
                        if (null !== E) {
                            const e = E.texture.format;
                            A = 1033 === e || 1031 === e || 1029 === e
                        }
                        if (A) {
                            const A = E.texture.type,
                                e = A === W || A === Y || A === X || A === Z || 1017 === A || 1018 === A,
                                t = CA.getClearColor(), n = CA.getClearAlpha(), r = t.r, i = t.g, a = t.b;
                            e ? (h[0] = r, h[1] = i, h[2] = a, h[3] = n, SA.clearBufferuiv(SA.COLOR, 0, h)) : (d[0] = r, d[1] = i, d[2] = a, d[3] = n, SA.clearBufferiv(SA.COLOR, 0, d))
                        } else n |= SA.COLOR_BUFFER_BIT
                    }
                    e && (n |= SA.DEPTH_BUFFER_BIT), t && (n |= SA.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), SA.clear(n)
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                }, this.dispose = function () {
                    e.removeEventListener("webglcontextlost", LA, !1), e.removeEventListener("webglcontextrestored", RA, !1), e.removeEventListener("webglcontextcreationerror", HA, !1), BA.dispose(), wA.dispose(), sA.dispose(), lA.dispose(), hA.dispose(), fA.dispose(), MA.dispose(), FA.dispose(), gA.dispose(), TA.dispose(), TA.removeEventListener("sessionstart", GA), TA.removeEventListener("sessionend", KA), K && (K.dispose(), K = null), kA.stop()
                }, this.renderBufferDirect = function (A, e, t, n, r, i) {
                    null === e && (e = eA);
                    const a = r.isMesh && r.matrixWorld.determinant() < 0, s = function (A, e, t, n, r) {
                        !0 !== e.isScene && (e = eA), oA.resetTextureUnits();
                        const i = e.fog, a = n.isMeshStandardMaterial ? e.environment : null,
                            s = null === E ? B.outputColorSpace : !0 === E.isXRRenderTarget ? E.texture.colorSpace : uA,
                            o = (n.isMeshStandardMaterial ? hA : lA).get(n.envMap || a),
                            l = !0 === n.vertexColors && !!t.attributes.color && 4 === t.attributes.color.itemSize,
                            c = !!t.attributes.tangent && (!!n.normalMap || n.anisotropy > 0),
                            u = !!t.morphAttributes.position, h = !!t.morphAttributes.normal,
                            d = !!t.morphAttributes.color;
                        let p = M;
                        n.toneMapped && (null !== E && !0 !== E.isXRRenderTarget || (p = B.toneMapping));
                        const g = t.morphAttributes.position || t.morphAttributes.normal || t.morphAttributes.color,
                            m = void 0 !== g ? g.length : 0, w = sA.get(n), v = f.state.lights;
                        if (!0 === G && (!0 === V || A !== y)) {
                            const e = A === y && n.id === U;
                            vA.setState(n, A, e)
                        }
                        let _ = !1;
                        n.version === w.__version ? w.needsLights && w.lightsStateVersion !== v.state.version || w.outputColorSpace !== s || r.isBatchedMesh && !1 === w.batching ? _ = !0 : r.isBatchedMesh || !0 !== w.batching ? r.isInstancedMesh && !1 === w.instancing ? _ = !0 : r.isInstancedMesh || !0 !== w.instancing ? r.isSkinnedMesh && !1 === w.skinning ? _ = !0 : r.isSkinnedMesh || !0 !== w.skinning ? r.isInstancedMesh && !0 === w.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === w.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === w.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === w.instancingMorph && null !== r.morphTexture || w.envMap !== o || !0 === n.fog && w.fog !== i ? _ = !0 : void 0 === w.numClippingPlanes || w.numClippingPlanes === vA.numPlanes && w.numIntersection === vA.numIntersection ? (w.vertexAlphas !== l || w.vertexTangents !== c || w.morphTargets !== u || w.morphNormals !== h || w.morphColors !== d || w.toneMapping !== p || !0 === rA.isWebGL2 && w.morphTargetsCount !== m) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : _ = !0 : (_ = !0, w.__version = n.version);
                        let C = w.currentProgram;
                        !0 === _ && (C = JA(n, e, r));
                        let x = !1, F = !1, S = !1;
                        const b = C.getUniforms(), Q = w.uniforms;
                        if (iA.useProgram(C.program) && (x = !0, F = !0, S = !0), n.id !== U && (U = n.id, F = !0), x || y !== A) {
                            b.setValue(SA, "projectionMatrix", A.projectionMatrix), b.setValue(SA, "viewMatrix", A.matrixWorldInverse);
                            const e = b.map.cameraPosition;
                            void 0 !== e && e.setValue(SA, AA.setFromMatrixPosition(A.matrixWorld)), rA.logarithmicDepthBuffer && b.setValue(SA, "logDepthBufFC", 2 / (Math.log(A.far + 1) / Math.LN2)), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && b.setValue(SA, "isOrthographic", !0 === A.isOrthographicCamera), y !== A && (y = A, F = !0, S = !0)
                        }
                        if (r.isSkinnedMesh) {
                            b.setOptional(SA, r, "bindMatrix"), b.setOptional(SA, r, "bindMatrixInverse");
                            const A = r.skeleton;
                            A && (rA.floatVertexTextures ? (null === A.boneTexture && A.computeBoneTexture(), b.setValue(SA, "boneTexture", A.boneTexture, oA)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        r.isBatchedMesh && (b.setOptional(SA, r, "batchingTexture"), b.setValue(SA, "batchingTexture", r._matricesTexture, oA));
                        const T = t.morphAttributes;
                        var R, H;
                        if ((void 0 !== T.position || void 0 !== T.normal || void 0 !== T.color && !0 === rA.isWebGL2) && EA.update(r, t, C), (F || w.receiveShadow !== r.receiveShadow) && (w.receiveShadow = r.receiveShadow, b.setValue(SA, "receiveShadow", r.receiveShadow)), n.isMeshGouraudMaterial && null !== n.envMap && (Q.envMap.value = o, Q.flipEnvMap.value = o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1), F && (b.setValue(SA, "toneMappingExposure", B.toneMappingExposure), w.needsLights && (H = S, (R = Q).ambientLightColor.needsUpdate = H, R.lightProbe.needsUpdate = H, R.directionalLights.needsUpdate = H, R.directionalLightShadows.needsUpdate = H, R.pointLights.needsUpdate = H, R.pointLightShadows.needsUpdate = H, R.spotLights.needsUpdate = H, R.spotLightShadows.needsUpdate = H, R.rectAreaLights.needsUpdate = H, R.hemisphereLights.needsUpdate = H), i && !0 === n.fog && mA.refreshFogUniforms(Q, i), mA.refreshMaterialUniforms(Q, n, L, I, K), xi.upload(SA, jA(w), Q, oA)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (xi.upload(SA, jA(w), Q, oA), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && b.setValue(SA, "center", r.center), b.setValue(SA, "modelViewMatrix", r.modelViewMatrix), b.setValue(SA, "normalMatrix", r.normalMatrix), b.setValue(SA, "modelMatrix", r.matrixWorld), n.isShaderMaterial || n.isRawShaderMaterial) {
                            const A = n.uniformsGroups;
                            for (let e = 0, t = A.length; e < t; e++) if (rA.isWebGL2) {
                                const t = A[e];
                                FA.update(t, C), FA.bind(t, C)
                            } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return C
                    }(A, e, t, n, r);
                    iA.setMaterial(n, a);
                    let o = t.index, l = 1;
                    if (!0 === n.wireframe) {
                        if (o = pA.getWireframeAttribute(t), void 0 === o) return;
                        l = 2
                    }
                    const c = t.drawRange, u = t.attributes.position;
                    let h = c.start * l, d = (c.start + c.count) * l;
                    null !== i && (h = Math.max(h, i.start * l), d = Math.min(d, (i.start + i.count) * l)), null !== o ? (h = Math.max(h, 0), d = Math.min(d, o.count)) : null != u && (h = Math.max(h, 0), d = Math.min(d, u.count));
                    const p = d - h;
                    if (p < 0 || p === 1 / 0) return;
                    let g;
                    MA.setup(r, n, s, t, o);
                    let m = UA;
                    if (null !== o && (g = dA.get(o), m = yA, m.setIndex(g)), r.isMesh) !0 === n.wireframe ? (iA.setLineWidth(n.wireframeLinewidth * tA()), m.setMode(SA.LINES)) : m.setMode(SA.TRIANGLES); else if (r.isLine) {
                        let A = n.linewidth;
                        void 0 === A && (A = 1), iA.setLineWidth(A * tA()), r.isLineSegments ? m.setMode(SA.LINES) : r.isLineLoop ? m.setMode(SA.LINE_LOOP) : m.setMode(SA.LINE_STRIP)
                    } else r.isPoints ? m.setMode(SA.POINTS) : r.isSprite && m.setMode(SA.TRIANGLES);
                    if (r.isBatchedMesh) m.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount); else if (r.isInstancedMesh) m.renderInstances(h, p, r.count); else if (t.isInstancedBufferGeometry) {
                        const A = void 0 !== t._maxInstanceCount ? t._maxInstanceCount : 1 / 0,
                            e = Math.min(t.instanceCount, A);
                        m.renderInstances(h, p, e)
                    } else m.render(h, p)
                }, this.compile = function (A, e, t = null) {
                    null === t && (t = A), f = wA.get(t), f.init(), m.push(f), t.traverseVisible((function (A) {
                        A.isLight && A.layers.test(e.layers) && (f.pushLight(A), A.castShadow && f.pushShadow(A))
                    })), A !== t && A.traverseVisible((function (A) {
                        A.isLight && A.layers.test(e.layers) && (f.pushLight(A), A.castShadow && f.pushShadow(A))
                    })), f.setupLights(B._useLegacyLights);
                    const n = new Set;
                    return A.traverse((function (A) {
                        const e = A.material;
                        if (e) if (Array.isArray(e)) for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            NA(i, t, A), n.add(i)
                        } else NA(e, t, A), n.add(e)
                    })), m.pop(), f = null, n
                }, this.compileAsync = function (A, e, t = null) {
                    const n = this.compile(A, e, t);
                    return new Promise((e => {
                        function t() {
                            n.forEach((function (A) {
                                sA.get(A).currentProgram.isReady() && n.delete(A)
                            })), 0 !== n.size ? setTimeout(t, 10) : e(A)
                        }

                        null !== nA.get("KHR_parallel_shader_compile") ? t() : setTimeout(t, 10)
                    }))
                };
                let OA = null;

                function GA() {
                    kA.stop()
                }

                function KA() {
                    kA.start()
                }

                const kA = new Hn;

                function zA(A, e, t, n) {
                    if (!1 === A.visible) return;
                    if (A.layers.test(e.layers)) if (A.isGroup) t = A.renderOrder; else if (A.isLOD) !0 === A.autoUpdate && A.update(e); else if (A.isLight) f.pushLight(A), A.castShadow && f.pushShadow(A); else if (A.isSprite) {
                        if (!A.frustumCulled || O.intersectsSprite(A)) {
                            n && AA.setFromMatrixPosition(A.matrixWorld).applyMatrix4(k);
                            const e = fA.update(A), r = A.material;
                            r.visible && p.push(A, e, r, t, AA.z, null)
                        }
                    } else if ((A.isMesh || A.isLine || A.isPoints) && (!A.frustumCulled || O.intersectsObject(A))) {
                        const e = fA.update(A), r = A.material;
                        if (n && (void 0 !== A.boundingSphere ? (null === A.boundingSphere && A.computeBoundingSphere(), AA.copy(A.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(), AA.copy(e.boundingSphere.center)), AA.applyMatrix4(A.matrixWorld).applyMatrix4(k)), Array.isArray(r)) {
                            const n = e.groups;
                            for (let i = 0, a = n.length; i < a; i++) {
                                const a = n[i], s = r[a.materialIndex];
                                s && s.visible && p.push(A, e, s, t, AA.z, a)
                            }
                        } else r.visible && p.push(A, e, r, t, AA.z, null)
                    }
                    const r = A.children;
                    for (let A = 0, i = r.length; A < i; A++) zA(r[A], e, t, n)
                }

                function WA(A, e, t, n) {
                    const r = A.opaque, i = A.transmissive, a = A.transparent;
                    f.setupLightsView(t), !0 === G && vA.setGlobalState(B.clippingPlanes, t), i.length > 0 && function (A, e, t, n) {
                        if (null !== (!0 === t.isScene ? t.overrideMaterial : null)) return;
                        const r = rA.isWebGL2;
                        null === K && (K = new ae(1, 1, {
                            generateMipmaps: !0,
                            type: nA.has("EXT_color_buffer_half_float") ? j : W,
                            minFilter: z,
                            samples: r ? 4 : 0
                        })), B.getDrawingBufferSize($), r ? K.setSize($.x, $.y) : K.setSize(IA($.x), IA($.y));
                        const i = B.getRenderTarget();
                        B.setRenderTarget(K), B.getClearColor(b), Q = B.getClearAlpha(), Q < 1 && B.setClearColor(16777215, .5), B.clear();
                        const a = B.toneMapping;
                        B.toneMapping = M, XA(A, t, n), oA.updateMultisampleRenderTarget(K), oA.updateRenderTargetMipmap(K);
                        let s = !1;
                        for (let A = 0, r = e.length; A < r; A++) {
                            const r = e[A], i = r.object, a = r.geometry, o = r.material, l = r.group;
                            if (2 === o.side && i.layers.test(n.layers)) {
                                const A = o.side;
                                o.side = 1, o.needsUpdate = !0, YA(i, t, n, a, o, l), o.side = A, o.needsUpdate = !0, s = !0
                            }
                        }
                        !0 === s && (oA.updateMultisampleRenderTarget(K), oA.updateRenderTargetMipmap(K)), B.setRenderTarget(i), B.setClearColor(b, Q), B.toneMapping = a
                    }(r, i, e, t), n && iA.viewport(x.copy(n)), r.length > 0 && XA(r, e, t), i.length > 0 && XA(i, e, t), a.length > 0 && XA(a, e, t), iA.buffers.depth.setTest(!0), iA.buffers.depth.setMask(!0), iA.buffers.color.setMask(!0), iA.setPolygonOffset(!1)
                }

                function XA(A, e, t) {
                    const n = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, i = A.length; r < i; r++) {
                        const i = A[r], a = i.object, s = i.geometry, o = null === n ? i.material : n, l = i.group;
                        a.layers.test(t.layers) && YA(a, e, t, s, o, l)
                    }
                }

                function YA(A, e, t, n, r, i) {
                    A.onBeforeRender(B, e, t, n, r, i), A.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, A.matrixWorld), A.normalMatrix.getNormalMatrix(A.modelViewMatrix), r.onBeforeRender(B, e, t, n, A, i), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1, r.needsUpdate = !0, B.renderBufferDirect(t, e, n, r, A, i), r.side = 0, r.needsUpdate = !0, B.renderBufferDirect(t, e, n, r, A, i), r.side = 2) : B.renderBufferDirect(t, e, n, r, A, i), A.onAfterRender(B, e, t, n, r, i)
                }

                function JA(A, e, t) {
                    !0 !== e.isScene && (e = eA);
                    const n = sA.get(A), r = f.state.lights, i = f.state.shadowsArray, a = r.state.version,
                        s = gA.getParameters(A, r.state, i, e, t), o = gA.getProgramCacheKey(s);
                    let l = n.programs;
                    n.environment = A.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = (A.isMeshStandardMaterial ? hA : lA).get(A.envMap || n.environment), n.envMapRotation = null !== n.environment && null === A.envMap ? e.environmentRotation : A.envMapRotation, void 0 === l && (A.addEventListener("dispose", PA), l = new Map, n.programs = l);
                    let c = l.get(o);
                    if (void 0 !== c) {
                        if (n.currentProgram === c && n.lightsStateVersion === a) return ZA(A, s), c
                    } else s.uniforms = gA.getUniforms(A), A.onBuild(t, s, B), A.onBeforeCompile(s, B), c = gA.acquireProgram(s, o), l.set(o, c), n.uniforms = s.uniforms;
                    const u = n.uniforms;
                    return (A.isShaderMaterial || A.isRawShaderMaterial) && !0 !== A.clipping || (u.clippingPlanes = vA.uniform), ZA(A, s), n.needsLights = function (A) {
                        return A.isMeshLambertMaterial || A.isMeshToonMaterial || A.isMeshPhongMaterial || A.isMeshStandardMaterial || A.isShadowMaterial || A.isShaderMaterial && !0 === A.lights
                    }(A), n.lightsStateVersion = a, n.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotLightMatrix.value = r.state.spotLightMatrix, u.spotLightMap.value = r.state.spotLightMap, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix), n.currentProgram = c, n.uniformsList = null, c
                }

                function jA(A) {
                    if (null === A.uniformsList) {
                        const e = A.currentProgram.getUniforms();
                        A.uniformsList = xi.seqWithValue(e.seq, A.uniforms)
                    }
                    return A.uniformsList
                }

                function ZA(A, e) {
                    const t = sA.get(A);
                    t.outputColorSpace = e.outputColorSpace, t.batching = e.batching, t.instancing = e.instancing, t.instancingColor = e.instancingColor, t.instancingMorph = e.instancingMorph, t.skinning = e.skinning, t.morphTargets = e.morphTargets, t.morphNormals = e.morphNormals, t.morphColors = e.morphColors, t.morphTargetsCount = e.morphTargetsCount, t.numClippingPlanes = e.numClippingPlanes, t.numIntersection = e.numClipIntersection, t.vertexAlphas = e.vertexAlphas, t.vertexTangents = e.vertexTangents, t.toneMapping = e.toneMapping
                }

                kA.setAnimationLoop((function (A) {
                    OA && OA(A)
                })), "undefined" != typeof self && kA.setContext(self), this.setAnimationLoop = function (A) {
                    OA = A, TA.setAnimationLoop(A), null === A ? kA.stop() : kA.start()
                }, TA.addEventListener("sessionstart", GA), TA.addEventListener("sessionend", KA), this.render = function (A, e) {
                    if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === v) return;
                    !0 === A.matrixWorldAutoUpdate && A.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === TA.enabled && !0 === TA.isPresenting && (!0 === TA.cameraAutoUpdate && TA.updateCamera(e), e = TA.getCamera()), !0 === A.isScene && A.onBeforeRender(B, A, e, E), f = wA.get(A, m.length), f.init(), m.push(f), k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), O.setFromProjectionMatrix(k), V = this.localClippingEnabled, G = vA.init(this.clippingPlanes, V), p = BA.get(A, g.length), p.init(), g.push(p), zA(A, e, 0, B.sortObjects), p.finish(), !0 === B.sortObjects && p.sort(R, H), this.info.render.frame++, !0 === G && vA.beginShadows();
                    const t = f.state.shadowsArray;
                    if (_A.render(t, A, e), !0 === G && vA.endShadows(), !0 === this.info.autoReset && this.info.reset(), !1 !== TA.enabled && !1 !== TA.isPresenting && !1 !== TA.hasDepthSensing() || CA.render(p, A), f.setupLights(B._useLegacyLights), e.isArrayCamera) {
                        const t = e.cameras;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            WA(p, A, n, n.viewport)
                        }
                    } else WA(p, A, e);
                    null !== E && (oA.updateMultisampleRenderTarget(E), oA.updateRenderTargetMipmap(E)), !0 === A.isScene && A.onAfterRender(B, A, e), MA.resetDefaultState(), U = -1, y = null, m.pop(), f = m.length > 0 ? m[m.length - 1] : null, g.pop(), p = g.length > 0 ? g[g.length - 1] : null
                }, this.getActiveCubeFace = function () {
                    return _
                }, this.getActiveMipmapLevel = function () {
                    return C
                }, this.getRenderTarget = function () {
                    return E
                }, this.setRenderTargetTextures = function (A, e, t) {
                    sA.get(A.texture).__webglTexture = e, sA.get(A.depthTexture).__webglTexture = t;
                    const n = sA.get(A);
                    n.__hasExternalTextures = !0, n.__autoAllocateDepthBuffer = void 0 === t, n.__autoAllocateDepthBuffer || !0 === nA.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n.__useRenderToTexture = !1)
                }, this.setRenderTargetFramebuffer = function (A, e) {
                    const t = sA.get(A);
                    t.__webglFramebuffer = e, t.__useDefaultFramebuffer = void 0 === e
                }, this.setRenderTarget = function (A, e = 0, t = 0) {
                    E = A, _ = e, C = t;
                    let n = !0, r = null, i = !1, a = !1;
                    if (A) {
                        const s = sA.get(A);
                        void 0 !== s.__useDefaultFramebuffer ? (iA.bindFramebuffer(SA.FRAMEBUFFER, null), n = !1) : void 0 === s.__webglFramebuffer ? oA.setupRenderTarget(A) : s.__hasExternalTextures && oA.rebindTextures(A, sA.get(A.texture).__webglTexture, sA.get(A.depthTexture).__webglTexture);
                        const o = A.texture;
                        (o.isData3DTexture || o.isDataArrayTexture || o.isCompressedArrayTexture) && (a = !0);
                        const l = sA.get(A).__webglFramebuffer;
                        A.isWebGLCubeRenderTarget ? (r = Array.isArray(l[e]) ? l[e][t] : l[e], i = !0) : r = rA.isWebGL2 && A.samples > 0 && !1 === oA.useMultisampledRTT(A) ? sA.get(A).__webglMultisampledFramebuffer : Array.isArray(l) ? l[t] : l, x.copy(A.viewport), F.copy(A.scissor), S = A.scissorTest
                    } else x.copy(D).multiplyScalar(L).floor(), F.copy(P).multiplyScalar(L).floor(), S = N;
                    if (iA.bindFramebuffer(SA.FRAMEBUFFER, r) && rA.drawBuffers && n && iA.drawBuffers(A, r), iA.viewport(x), iA.scissor(F), iA.setScissorTest(S), i) {
                        const n = sA.get(A.texture);
                        SA.framebufferTexture2D(SA.FRAMEBUFFER, SA.COLOR_ATTACHMENT0, SA.TEXTURE_CUBE_MAP_POSITIVE_X + e, n.__webglTexture, t)
                    } else if (a) {
                        const n = sA.get(A.texture), r = e || 0;
                        SA.framebufferTextureLayer(SA.FRAMEBUFFER, SA.COLOR_ATTACHMENT0, n.__webglTexture, t || 0, r)
                    }
                    U = -1
                }, this.readRenderTargetPixels = function (A, e, t, n, r, i, a) {
                    if (!A || !A.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let s = sA.get(A).__webglFramebuffer;
                    if (A.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s) {
                        iA.bindFramebuffer(SA.FRAMEBUFFER, s);
                        try {
                            const a = A.texture, s = a.format, o = a.type;
                            if (s !== q && xA.convert(s) !== SA.getParameter(SA.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const l = o === j && (nA.has("EXT_color_buffer_half_float") || rA.isWebGL2 && nA.has("EXT_color_buffer_float"));
                            if (!(o === W || xA.convert(o) === SA.getParameter(SA.IMPLEMENTATION_COLOR_READ_TYPE) || o === J && (rA.isWebGL2 || nA.has("OES_texture_float") || nA.has("WEBGL_color_buffer_float")) || l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            e >= 0 && e <= A.width - n && t >= 0 && t <= A.height - r && SA.readPixels(e, t, n, r, xA.convert(s), xA.convert(o), i)
                        } finally {
                            const A = null !== E ? sA.get(E).__webglFramebuffer : null;
                            iA.bindFramebuffer(SA.FRAMEBUFFER, A)
                        }
                    }
                }, this.copyFramebufferToTexture = function (A, e, t = 0) {
                    const n = Math.pow(2, -t), r = Math.floor(e.image.width * n), i = Math.floor(e.image.height * n);
                    oA.setTexture2D(e, 0), SA.copyTexSubImage2D(SA.TEXTURE_2D, t, 0, 0, A.x, A.y, r, i), iA.unbindTexture()
                }, this.copyTextureToTexture = function (A, e, t, n = 0) {
                    const r = e.image.width, i = e.image.height, a = xA.convert(t.format), s = xA.convert(t.type);
                    oA.setTexture2D(t, 0), SA.pixelStorei(SA.UNPACK_FLIP_Y_WEBGL, t.flipY), SA.pixelStorei(SA.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), SA.pixelStorei(SA.UNPACK_ALIGNMENT, t.unpackAlignment), e.isDataTexture ? SA.texSubImage2D(SA.TEXTURE_2D, n, A.x, A.y, r, i, a, s, e.image.data) : e.isCompressedTexture ? SA.compressedTexSubImage2D(SA.TEXTURE_2D, n, A.x, A.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : SA.texSubImage2D(SA.TEXTURE_2D, n, A.x, A.y, a, s, e.image), 0 === n && t.generateMipmaps && SA.generateMipmap(SA.TEXTURE_2D), iA.unbindTexture()
                }, this.copyTextureToTexture3D = function (A, e, t, n, r = 0) {
                    if (B.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const i = Math.round(A.max.x - A.min.x), a = Math.round(A.max.y - A.min.y),
                        s = A.max.z - A.min.z + 1, o = xA.convert(n.format), l = xA.convert(n.type);
                    let c;
                    if (n.isData3DTexture) oA.setTexture3D(n, 0), c = SA.TEXTURE_3D; else {
                        if (!n.isDataArrayTexture && !n.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        oA.setTexture2DArray(n, 0), c = SA.TEXTURE_2D_ARRAY
                    }
                    SA.pixelStorei(SA.UNPACK_FLIP_Y_WEBGL, n.flipY), SA.pixelStorei(SA.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), SA.pixelStorei(SA.UNPACK_ALIGNMENT, n.unpackAlignment);
                    const u = SA.getParameter(SA.UNPACK_ROW_LENGTH), h = SA.getParameter(SA.UNPACK_IMAGE_HEIGHT),
                        d = SA.getParameter(SA.UNPACK_SKIP_PIXELS), p = SA.getParameter(SA.UNPACK_SKIP_ROWS),
                        f = SA.getParameter(SA.UNPACK_SKIP_IMAGES), g = t.isCompressedTexture ? t.mipmaps[r] : t.image;
                    SA.pixelStorei(SA.UNPACK_ROW_LENGTH, g.width), SA.pixelStorei(SA.UNPACK_IMAGE_HEIGHT, g.height), SA.pixelStorei(SA.UNPACK_SKIP_PIXELS, A.min.x), SA.pixelStorei(SA.UNPACK_SKIP_ROWS, A.min.y), SA.pixelStorei(SA.UNPACK_SKIP_IMAGES, A.min.z), t.isDataTexture || t.isData3DTexture ? SA.texSubImage3D(c, r, e.x, e.y, e.z, i, a, s, o, l, g.data) : n.isCompressedArrayTexture ? SA.compressedTexSubImage3D(c, r, e.x, e.y, e.z, i, a, s, o, g.data) : SA.texSubImage3D(c, r, e.x, e.y, e.z, i, a, s, o, l, g), SA.pixelStorei(SA.UNPACK_ROW_LENGTH, u), SA.pixelStorei(SA.UNPACK_IMAGE_HEIGHT, h), SA.pixelStorei(SA.UNPACK_SKIP_PIXELS, d), SA.pixelStorei(SA.UNPACK_SKIP_ROWS, p), SA.pixelStorei(SA.UNPACK_SKIP_IMAGES, f), 0 === r && n.generateMipmaps && SA.generateMipmap(c), iA.unbindTexture()
                }, this.initTexture = function (A) {
                    A.isCubeTexture ? oA.setTextureCube(A, 0) : A.isData3DTexture ? oA.setTexture3D(A, 0) : A.isDataArrayTexture || A.isCompressedArrayTexture ? oA.setTexture2DArray(A, 0) : oA.setTexture2D(A, 0), iA.unbindTexture()
                }, this.resetState = function () {
                    _ = 0, C = 0, E = null, iA.reset(), MA.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
            }

            get coordinateSystem() {
                return _A
            }

            get outputColorSpace() {
                return this._outputColorSpace
            }

            set outputColorSpace(A) {
                this._outputColorSpace = A;
                const e = this.getContext();
                e.drawingBufferColorSpace = A === hA ? "display-p3" : "srgb", e.unpackColorSpace = YA.workingColorSpace === dA ? "display-p3" : "srgb"
            }

            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
            }

            set useLegacyLights(A) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = A
            }
        }

        (class extends Ca {
        }).prototype.isWebGL1Renderer = !0;

        class Ea extends dt {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new je, this.environmentRotation = new je, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
            }

            copy(A, e) {
                return super.copy(A, e), null !== A.background && (this.background = A.background.clone()), null !== A.environment && (this.environment = A.environment.clone()), null !== A.fog && (this.fog = A.fog.clone()), this.backgroundBlurriness = A.backgroundBlurriness, this.backgroundIntensity = A.backgroundIntensity, this.backgroundRotation.copy(A.backgroundRotation), this.environmentRotation.copy(A.environmentRotation), null !== A.overrideMaterial && (this.overrideMaterial = A.overrideMaterial.clone()), this.matrixAutoUpdate = A.matrixAutoUpdate, this
            }

            toJSON(A) {
                const e = super.toJSON(A);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), e.object.environmentRotation = this.environmentRotation.toArray(), e
            }
        }

        class Ua extends ne {
            constructor(A, e, t, n, r, i, a, s, o) {
                super(A, e, t, n, r, i, a, s, o), this.isCanvasTexture = !0, this.needsUpdate = !0
            }
        }

        function ya(A, e, t) {
            return !A || !t && A.constructor === e ? A : "number" == typeof e.BYTES_PER_ELEMENT ? new e(A) : Array.prototype.slice.call(A)
        }

        class xa {
            constructor(A, e, t, n) {
                this.parameterPositions = A, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(t), this.sampleValues = e, this.valueSize = t, this.settings = null, this.DefaultSettings_ = {}
            }

            evaluate(A) {
                const e = this.parameterPositions;
                let t = this._cachedIndex, n = e[t], r = e[t - 1];
                A:{
                    e:{
                        let i;
                        t:{
                            n:if (!(A < n)) {
                                for (let i = t + 2; ;) {
                                    if (void 0 === n) {
                                        if (A < r) break n;
                                        return t = e.length, this._cachedIndex = t, this.copySampleValue_(t - 1)
                                    }
                                    if (t === i) break;
                                    if (r = n, n = e[++t], A < n) break e
                                }
                                i = e.length;
                                break t
                            }
                            if (A >= r) break A;
                            {
                                const a = e[1];
                                A < a && (t = 2, r = a);
                                for (let i = t - 2; ;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (t === i) break;
                                    if (n = r, r = e[--t - 1], A >= r) break e
                                }
                                i = t, t = 0
                            }
                        }
                        for (; t < i;) {
                            const n = t + i >>> 1;
                            A < e[n] ? i = n : t = n + 1
                        }
                        if (n = e[t], r = e[t - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (void 0 === n) return t = e.length, this._cachedIndex = t, this.copySampleValue_(t - 1)
                    }
                    this._cachedIndex = t, this.intervalChanged_(t, r, n)
                }
                return this.interpolate_(t, r, A, n)
            }

            getSettings_() {
                return this.settings || this.DefaultSettings_
            }

            copySampleValue_(A) {
                const e = this.resultBuffer, t = this.sampleValues, n = this.valueSize, r = A * n;
                for (let A = 0; A !== n; ++A) e[A] = t[r + A];
                return e
            }

            interpolate_() {
                throw new Error("call to abstract method")
            }

            intervalChanged_() {
            }
        }

        class Ma extends xa {
            constructor(A, e, t, n) {
                super(A, e, t, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: 2400,
                    endingEnd: 2400
                }
            }

            intervalChanged_(A, e, t) {
                const n = this.parameterPositions;
                let r = A - 2, i = A + 1, a = n[r], s = n[i];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = A, a = 2 * e - t;
                        break;
                    case 2402:
                        r = n.length - 2, a = e + n[r] - n[r + 1];
                        break;
                    default:
                        r = A, a = t
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        i = A, s = 2 * t - e;
                        break;
                    case 2402:
                        i = 1, s = t + n[1] - n[0];
                        break;
                    default:
                        i = A - 1, s = e
                }
                const o = .5 * (t - e), l = this.valueSize;
                this._weightPrev = o / (e - a), this._weightNext = o / (s - t), this._offsetPrev = r * l, this._offsetNext = i * l
            }

            interpolate_(A, e, t, n) {
                const r = this.resultBuffer, i = this.sampleValues, a = this.valueSize, s = A * a, o = s - a,
                    l = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, h = this._weightNext,
                    d = (t - e) / (n - e), p = d * d, f = p * d, g = -u * f + 2 * u * p - u * d,
                    m = (1 + u) * f + (-1.5 - 2 * u) * p + (-.5 + u) * d + 1, B = (-1 - h) * f + (1.5 + h) * p + .5 * d,
                    w = h * f - h * p;
                for (let A = 0; A !== a; ++A) r[A] = g * i[l + A] + m * i[o + A] + B * i[s + A] + w * i[c + A];
                return r
            }
        }

        class Fa extends xa {
            constructor(A, e, t, n) {
                super(A, e, t, n)
            }

            interpolate_(A, e, t, n) {
                const r = this.resultBuffer, i = this.sampleValues, a = this.valueSize, s = A * a, o = s - a,
                    l = (t - e) / (n - e), c = 1 - l;
                for (let A = 0; A !== a; ++A) r[A] = i[o + A] * c + i[s + A] * l;
                return r
            }
        }

        class Sa extends xa {
            constructor(A, e, t, n) {
                super(A, e, t, n)
            }

            interpolate_(A) {
                return this.copySampleValue_(A - 1)
            }
        }

        class ba {
            constructor(A, e, t, n) {
                if (void 0 === A) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + A);
                this.name = A, this.times = ya(e, this.TimeBufferType), this.values = ya(t, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
            }

            static toJSON(A) {
                const e = A.constructor;
                let t;
                if (e.toJSON !== this.toJSON) t = e.toJSON(A); else {
                    t = {name: A.name, times: ya(A.times, Array), values: ya(A.values, Array)};
                    const e = A.getInterpolation();
                    e !== A.DefaultInterpolation && (t.interpolation = e)
                }
                return t.type = A.ValueTypeName, t
            }

            InterpolantFactoryMethodDiscrete(A) {
                return new Sa(this.times, this.values, this.getValueSize(), A)
            }

            InterpolantFactoryMethodLinear(A) {
                return new Fa(this.times, this.values, this.getValueSize(), A)
            }

            InterpolantFactoryMethodSmooth(A) {
                return new Ma(this.times, this.values, this.getValueSize(), A)
            }

            setInterpolation(A) {
                let e;
                switch (A) {
                    case aA:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case sA:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case oA:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (A === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            }

            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return aA;
                    case this.InterpolantFactoryMethodLinear:
                        return sA;
                    case this.InterpolantFactoryMethodSmooth:
                        return oA
                }
            }

            getValueSize() {
                return this.values.length / this.times.length
            }

            shift(A) {
                if (0 !== A) {
                    const e = this.times;
                    for (let t = 0, n = e.length; t !== n; ++t) e[t] += A
                }
                return this
            }

            scale(A) {
                if (1 !== A) {
                    const e = this.times;
                    for (let t = 0, n = e.length; t !== n; ++t) e[t] *= A
                }
                return this
            }

            trim(A, e) {
                const t = this.times, n = t.length;
                let r = 0, i = n - 1;
                for (; r !== n && t[r] < A;) ++r;
                for (; -1 !== i && t[i] > e;) --i;
                if (++i, 0 !== r || i !== n) {
                    r >= i && (i = Math.max(i, 1), r = i - 1);
                    const A = this.getValueSize();
                    this.times = t.slice(r, i), this.values = this.values.slice(r * A, i * A)
                }
                return this
            }

            validate() {
                let A = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), A = !1);
                const t = this.times, n = this.values, r = t.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), A = !1);
                let i = null;
                for (let e = 0; e !== r; e++) {
                    const n = t[e];
                    if ("number" == typeof n && isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), A = !1;
                        break
                    }
                    if (null !== i && i > n) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, i), A = !1;
                        break
                    }
                    i = n
                }
                if (void 0 !== n && (a = n, ArrayBuffer.isView(a) && !(a instanceof DataView))) for (let e = 0, t = n.length; e !== t; ++e) {
                    const t = n[e];
                    if (isNaN(t)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, t), A = !1;
                        break
                    }
                }
                var a;
                return A
            }

            optimize() {
                const A = this.times.slice(), e = this.values.slice(), t = this.getValueSize(),
                    n = this.getInterpolation() === oA, r = A.length - 1;
                let i = 1;
                for (let a = 1; a < r; ++a) {
                    let r = !1;
                    const s = A[a];
                    if (s !== A[a + 1] && (1 !== a || s !== A[0])) if (n) r = !0; else {
                        const A = a * t, n = A - t, i = A + t;
                        for (let a = 0; a !== t; ++a) {
                            const t = e[A + a];
                            if (t !== e[n + a] || t !== e[i + a]) {
                                r = !0;
                                break
                            }
                        }
                    }
                    if (r) {
                        if (a !== i) {
                            A[i] = A[a];
                            const n = a * t, r = i * t;
                            for (let A = 0; A !== t; ++A) e[r + A] = e[n + A]
                        }
                        ++i
                    }
                }
                if (r > 0) {
                    A[i] = A[r];
                    for (let A = r * t, n = i * t, a = 0; a !== t; ++a) e[n + a] = e[A + a];
                    ++i
                }
                return i !== A.length ? (this.times = A.slice(0, i), this.values = e.slice(0, i * t)) : (this.times = A, this.values = e), this
            }

            clone() {
                const A = this.times.slice(), e = this.values.slice(), t = new (0, this.constructor)(this.name, A, e);
                return t.createInterpolant = this.createInterpolant, t
            }
        }

        ba.prototype.TimeBufferType = Float32Array, ba.prototype.ValueBufferType = Float32Array, ba.prototype.DefaultInterpolation = sA;

        class Qa extends ba {
        }

        Qa.prototype.ValueTypeName = "bool", Qa.prototype.ValueBufferType = Array, Qa.prototype.DefaultInterpolation = aA, Qa.prototype.InterpolantFactoryMethodLinear = void 0, Qa.prototype.InterpolantFactoryMethodSmooth = void 0;
        (class extends ba {
        }).prototype.ValueTypeName = "color";
        (class extends ba {
        }).prototype.ValueTypeName = "number";

        class Ta extends xa {
            constructor(A, e, t, n) {
                super(A, e, t, n)
            }

            interpolate_(A, e, t, n) {
                const r = this.resultBuffer, i = this.sampleValues, a = this.valueSize, s = (t - e) / (n - e);
                let o = A * a;
                for (let A = o + a; o !== A; o += 4) le.slerpFlat(r, 0, i, o - a, i, o, s);
                return r
            }
        }

        class Ia extends ba {
            InterpolantFactoryMethodLinear(A) {
                return new Ta(this.times, this.values, this.getValueSize(), A)
            }
        }

        Ia.prototype.ValueTypeName = "quaternion", Ia.prototype.DefaultInterpolation = sA, Ia.prototype.InterpolantFactoryMethodSmooth = void 0;

        class La extends ba {
        }

        La.prototype.ValueTypeName = "string", La.prototype.ValueBufferType = Array, La.prototype.DefaultInterpolation = aA, La.prototype.InterpolantFactoryMethodLinear = void 0, La.prototype.InterpolantFactoryMethodSmooth = void 0;
        (class extends ba {
        }).prototype.ValueTypeName = "vector";
        Error;
        const Ra = "\\[\\]\\.:\\/", Ha = new RegExp("[" + Ra + "]", "g"), Da = "[^" + Ra + "]",
            Pa = "[^" + Ra.replace("\\.", "") + "]",
            Na = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Da) + /(WCOD+)?/.source.replace("WCOD", Pa) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Da) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Da) + "$"),
            Oa = ["material", "materials", "bones", "map"];

        class Ga {
            constructor(A, e, t) {
                this.path = e, this.parsedPath = t || Ga.parseTrackName(e), this.node = Ga.findNode(A, this.parsedPath.nodeName), this.rootNode = A, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }

            static create(A, e, t) {
                return A && A.isAnimationObjectGroup ? new Ga.Composite(A, e, t) : new Ga(A, e, t)
            }

            static sanitizeNodeName(A) {
                return A.replace(/\s/g, "_").replace(Ha, "")
            }

            static parseTrackName(A) {
                const e = Na.exec(A);
                if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + A);
                const t = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }, n = t.nodeName && t.nodeName.lastIndexOf(".");
                if (void 0 !== n && -1 !== n) {
                    const A = t.nodeName.substring(n + 1);
                    -1 !== Oa.indexOf(A) && (t.nodeName = t.nodeName.substring(0, n), t.objectName = A)
                }
                if (null === t.propertyName || 0 === t.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + A);
                return t
            }

            static findNode(A, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === A.name || e === A.uuid) return A;
                if (A.skeleton) {
                    const t = A.skeleton.getBoneByName(e);
                    if (void 0 !== t) return t
                }
                if (A.children) {
                    const t = function (A) {
                        for (let n = 0; n < A.length; n++) {
                            const r = A[n];
                            if (r.name === e || r.uuid === e) return r;
                            const i = t(r.children);
                            if (i) return i
                        }
                        return null
                    }, n = t(A.children);
                    if (n) return n
                }
                return null
            }

            _getValue_unavailable() {
            }

            _setValue_unavailable() {
            }

            _getValue_direct(A, e) {
                A[e] = this.targetObject[this.propertyName]
            }

            _getValue_array(A, e) {
                const t = this.resolvedProperty;
                for (let n = 0, r = t.length; n !== r; ++n) A[e++] = t[n]
            }

            _getValue_arrayElement(A, e) {
                A[e] = this.resolvedProperty[this.propertyIndex]
            }

            _getValue_toArray(A, e) {
                this.resolvedProperty.toArray(A, e)
            }

            _setValue_direct(A, e) {
                this.targetObject[this.propertyName] = A[e]
            }

            _setValue_direct_setNeedsUpdate(A, e) {
                this.targetObject[this.propertyName] = A[e], this.targetObject.needsUpdate = !0
            }

            _setValue_direct_setMatrixWorldNeedsUpdate(A, e) {
                this.targetObject[this.propertyName] = A[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _setValue_array(A, e) {
                const t = this.resolvedProperty;
                for (let n = 0, r = t.length; n !== r; ++n) t[n] = A[e++]
            }

            _setValue_array_setNeedsUpdate(A, e) {
                const t = this.resolvedProperty;
                for (let n = 0, r = t.length; n !== r; ++n) t[n] = A[e++];
                this.targetObject.needsUpdate = !0
            }

            _setValue_array_setMatrixWorldNeedsUpdate(A, e) {
                const t = this.resolvedProperty;
                for (let n = 0, r = t.length; n !== r; ++n) t[n] = A[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _setValue_arrayElement(A, e) {
                this.resolvedProperty[this.propertyIndex] = A[e]
            }

            _setValue_arrayElement_setNeedsUpdate(A, e) {
                this.resolvedProperty[this.propertyIndex] = A[e], this.targetObject.needsUpdate = !0
            }

            _setValue_arrayElement_setMatrixWorldNeedsUpdate(A, e) {
                this.resolvedProperty[this.propertyIndex] = A[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _setValue_fromArray(A, e) {
                this.resolvedProperty.fromArray(A, e)
            }

            _setValue_fromArray_setNeedsUpdate(A, e) {
                this.resolvedProperty.fromArray(A, e), this.targetObject.needsUpdate = !0
            }

            _setValue_fromArray_setMatrixWorldNeedsUpdate(A, e) {
                this.resolvedProperty.fromArray(A, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _getValue_unbound(A, e) {
                this.bind(), this.getValue(A, e)
            }

            _setValue_unbound(A, e) {
                this.bind(), this.setValue(A, e)
            }

            bind() {
                let A = this.node;
                const e = this.parsedPath, t = e.objectName, n = e.propertyName;
                let r = e.propertyIndex;
                if (A || (A = Ga.findNode(this.rootNode, e.nodeName), this.node = A), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !A) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (t) {
                    let n = e.objectIndex;
                    switch (t) {
                        case"materials":
                            if (!A.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!A.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            A = A.material.materials;
                            break;
                        case"bones":
                            if (!A.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            A = A.skeleton.bones;
                            for (let e = 0; e < A.length; e++) if (A[e].name === n) {
                                n = e;
                                break
                            }
                            break;
                        case"map":
                            if ("map" in A) {
                                A = A.map;
                                break
                            }
                            if (!A.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!A.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            A = A.material.map;
                            break;
                        default:
                            if (void 0 === A[t]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            A = A[t]
                    }
                    if (void 0 !== n) {
                        if (void 0 === A[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, A);
                        A = A[n]
                    }
                }
                const i = A[n];
                if (void 0 === i) {
                    const t = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + t + "." + n + " but it wasn't found.", A)
                }
                let a = this.Versioning.None;
                this.targetObject = A, void 0 !== A.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== A.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let s = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === n) {
                        if (!A.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!A.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== A.morphTargetDictionary[r] && (r = A.morphTargetDictionary[r])
                    }
                    s = this.BindingType.ArrayElement, this.resolvedProperty = i, this.propertyIndex = r
                } else void 0 !== i.fromArray && void 0 !== i.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = i) : Array.isArray(i) ? (s = this.BindingType.EntireArray, this.resolvedProperty = i) : this.propertyName = n;
                this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][a]
            }

            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }

        Ga.Composite = class {
            constructor(A, e, t) {
                const n = t || Ga.parseTrackName(e);
                this._targetGroup = A, this._bindings = A.subscribe_(e, n)
            }

            getValue(A, e) {
                this.bind();
                const t = this._targetGroup.nCachedObjects_, n = this._bindings[t];
                void 0 !== n && n.getValue(A, e)
            }

            setValue(A, e) {
                const t = this._bindings;
                for (let n = this._targetGroup.nCachedObjects_, r = t.length; n !== r; ++n) t[n].setValue(A, e)
            }

            bind() {
                const A = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, t = A.length; e !== t; ++e) A[e].bind()
            }

            unbind() {
                const A = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, t = A.length; e !== t; ++e) A[e].unbind()
            }
        }, Ga.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, Ga.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, Ga.prototype.GetterByBindingType = [Ga.prototype._getValue_direct, Ga.prototype._getValue_array, Ga.prototype._getValue_arrayElement, Ga.prototype._getValue_toArray], Ga.prototype.SetterByBindingTypeAndVersioning = [[Ga.prototype._setValue_direct, Ga.prototype._setValue_direct_setNeedsUpdate, Ga.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ga.prototype._setValue_array, Ga.prototype._setValue_array_setNeedsUpdate, Ga.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ga.prototype._setValue_arrayElement, Ga.prototype._setValue_arrayElement_setNeedsUpdate, Ga.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ga.prototype._setValue_fromArray, Ga.prototype._setValue_fromArray_setNeedsUpdate, Ga.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]], new Float32Array(1), "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: w}})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = w);
        var Va = t(354), Ka = t.n(Va);
        const ka = {type: "change"}, za = {type: "start"}, Wa = {type: "end"};

        class Xa extends EA {
            constructor(A, e) {
                super();
                const t = this, n = -1;
                this.object = A, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.screen = {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = .3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = .2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = ["KeyA", "KeyS", "KeyD"], this.mouseButtons = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                }, this.target = new ce;
                const r = 1e-6, i = new ce;
                let a = 1, s = n, o = n, l = 0, c = 0, u = 0;
                const h = new ce, d = new DA, p = new DA, f = new ce, g = new DA, m = new DA, B = new DA, w = new DA,
                    v = [], _ = {};
                this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.up0 = this.object.up.clone(), this.zoom0 = this.object.zoom, this.handleResize = function () {
                    const A = t.domElement.getBoundingClientRect(), e = t.domElement.ownerDocument.documentElement;
                    t.screen.left = A.left + window.pageXOffset - e.clientLeft, t.screen.top = A.top + window.pageYOffset - e.clientTop, t.screen.width = A.width, t.screen.height = A.height
                };
                const C = function () {
                    const A = new DA;
                    return function (e, n) {
                        return A.set((e - t.screen.left) / t.screen.width, (n - t.screen.top) / t.screen.height), A
                    }
                }(), E = function () {
                    const A = new DA;
                    return function (e, n) {
                        return A.set((e - .5 * t.screen.width - t.screen.left) / (.5 * t.screen.width), (t.screen.height + 2 * (t.screen.top - n)) / t.screen.width), A
                    }
                }();

                function U(A) {
                    !1 !== t.enabled && (0 === v.length && (t.domElement.setPointerCapture(A.pointerId), t.domElement.addEventListener("pointermove", y), t.domElement.addEventListener("pointerup", x)), function (A) {
                        v.push(A)
                    }(A), "touch" === A.pointerType ? function (A) {
                        if (1 === (I(A), v.length)) s = 3, p.copy(E(v[0].pageX, v[0].pageY)), d.copy(p); else {
                            s = 4;
                            const A = v[0].pageX - v[1].pageX, e = v[0].pageY - v[1].pageY;
                            c = l = Math.sqrt(A * A + e * e);
                            const t = (v[0].pageX + v[1].pageX) / 2, n = (v[0].pageY + v[1].pageY) / 2;
                            B.copy(C(t, n)), w.copy(B)
                        }
                        t.dispatchEvent(za)
                    }(A) : function (A) {
                        if (s === n) switch (A.button) {
                            case t.mouseButtons.LEFT:
                                s = 0;
                                break;
                            case t.mouseButtons.MIDDLE:
                                s = 1;
                                break;
                            case t.mouseButtons.RIGHT:
                                s = 2
                        }
                        const e = o !== n ? o : s;
                        0 !== e || t.noRotate ? 1 !== e || t.noZoom ? 2 !== e || t.noPan || (B.copy(C(A.pageX, A.pageY)), w.copy(B)) : (g.copy(C(A.pageX, A.pageY)), m.copy(g)) : (p.copy(E(A.pageX, A.pageY)), d.copy(p)), t.dispatchEvent(za)
                    }(A))
                }

                function y(A) {
                    !1 !== t.enabled && ("touch" === A.pointerType ? function (A) {
                        if (1 === (I(A), v.length)) d.copy(p), p.copy(E(A.pageX, A.pageY)); else {
                            const e = function (A) {
                                const e = A.pointerId === v[0].pointerId ? v[1] : v[0];
                                return _[e.pointerId]
                            }(A), t = A.pageX - e.x, n = A.pageY - e.y;
                            c = Math.sqrt(t * t + n * n);
                            const r = (A.pageX + e.x) / 2, i = (A.pageY + e.y) / 2;
                            w.copy(C(r, i))
                        }
                    }(A) : function (A) {
                        const e = o !== n ? o : s;
                        0 !== e || t.noRotate ? 1 !== e || t.noZoom ? 2 !== e || t.noPan || w.copy(C(A.pageX, A.pageY)) : m.copy(C(A.pageX, A.pageY)) : (d.copy(p), p.copy(E(A.pageX, A.pageY)))
                    }(A))
                }

                function x(A) {
                    !1 !== t.enabled && ("touch" === A.pointerType ? function (A) {
                        switch (v.length) {
                            case 0:
                                s = n;
                                break;
                            case 1:
                                s = 3, p.copy(E(A.pageX, A.pageY)), d.copy(p);
                                break;
                            case 2:
                                s = 4;
                                for (let e = 0; e < v.length; e++) if (v[e].pointerId !== A.pointerId) {
                                    const A = _[v[e].pointerId];
                                    p.copy(E(A.x, A.y)), d.copy(p);
                                    break
                                }
                        }
                        t.dispatchEvent(Wa)
                    }(A) : (s = n, t.dispatchEvent(Wa)), T(A), 0 === v.length && (t.domElement.releasePointerCapture(A.pointerId), t.domElement.removeEventListener("pointermove", y), t.domElement.removeEventListener("pointerup", x)))
                }

                function M(A) {
                    T(A)
                }

                function F(A) {
                    !1 !== t.enabled && (window.removeEventListener("keydown", F), o === n && (A.code !== t.keys[0] || t.noRotate ? A.code !== t.keys[1] || t.noZoom ? A.code !== t.keys[2] || t.noPan || (o = 2) : o = 1 : o = 0))
                }

                function S() {
                    !1 !== t.enabled && (o = n, window.addEventListener("keydown", F))
                }

                function b(A) {
                    if (!1 !== t.enabled && !0 !== t.noZoom) {
                        switch (A.preventDefault(), A.deltaMode) {
                            case 2:
                                g.y -= .025 * A.deltaY;
                                break;
                            case 1:
                                g.y -= .01 * A.deltaY;
                                break;
                            default:
                                g.y -= 25e-5 * A.deltaY
                        }
                        t.dispatchEvent(za), t.dispatchEvent(Wa)
                    }
                }

                function Q(A) {
                    !1 !== t.enabled && A.preventDefault()
                }

                function T(A) {
                    delete _[A.pointerId];
                    for (let e = 0; e < v.length; e++) if (v[e].pointerId == A.pointerId) return void v.splice(e, 1)
                }

                function I(A) {
                    let e = _[A.pointerId];
                    void 0 === e && (e = new DA, _[A.pointerId] = e), e.set(A.pageX, A.pageY)
                }

                this.rotateCamera = function () {
                    const A = new ce, e = new le, n = new ce, r = new ce, i = new ce, a = new ce;
                    return function () {
                        a.set(p.x - d.x, p.y - d.y, 0);
                        let s = a.length();
                        s ? (h.copy(t.object.position).sub(t.target), n.copy(h).normalize(), r.copy(t.object.up).normalize(), i.crossVectors(r, n).normalize(), r.setLength(p.y - d.y), i.setLength(p.x - d.x), a.copy(r.add(i)), A.crossVectors(a, h).normalize(), s *= t.rotateSpeed, e.setFromAxisAngle(A, s), h.applyQuaternion(e), t.object.up.applyQuaternion(e), f.copy(A), u = s) : !t.staticMoving && u && (u *= Math.sqrt(1 - t.dynamicDampingFactor), h.copy(t.object.position).sub(t.target), e.setFromAxisAngle(f, u), h.applyQuaternion(e), t.object.up.applyQuaternion(e)), d.copy(p)
                    }
                }(), this.zoomCamera = function () {
                    let A;
                    4 === s ? (A = l / c, l = c, t.object.isPerspectiveCamera ? h.multiplyScalar(A) : t.object.isOrthographicCamera ? (t.object.zoom = HA.clamp(t.object.zoom / A, t.minZoom, t.maxZoom), a !== t.object.zoom && t.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (A = 1 + (m.y - g.y) * t.zoomSpeed, 1 !== A && A > 0 && (t.object.isPerspectiveCamera ? h.multiplyScalar(A) : t.object.isOrthographicCamera ? (t.object.zoom = HA.clamp(t.object.zoom / A, t.minZoom, t.maxZoom), a !== t.object.zoom && t.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), t.staticMoving ? g.copy(m) : g.y += (m.y - g.y) * this.dynamicDampingFactor)
                }, this.panCamera = function () {
                    const A = new DA, e = new ce, n = new ce;
                    return function () {
                        if (A.copy(w).sub(B), A.lengthSq()) {
                            if (t.object.isOrthographicCamera) {
                                const e = (t.object.right - t.object.left) / t.object.zoom / t.domElement.clientWidth,
                                    n = (t.object.top - t.object.bottom) / t.object.zoom / t.domElement.clientWidth;
                                A.x *= e, A.y *= n
                            }
                            A.multiplyScalar(h.length() * t.panSpeed), n.copy(h).cross(t.object.up).setLength(A.x), n.add(e.copy(t.object.up).setLength(A.y)), t.object.position.add(n), t.target.add(n), t.staticMoving ? B.copy(w) : B.add(A.subVectors(w, B).multiplyScalar(t.dynamicDampingFactor))
                        }
                    }
                }(), this.checkDistances = function () {
                    t.noZoom && t.noPan || (h.lengthSq() > t.maxDistance * t.maxDistance && (t.object.position.addVectors(t.target, h.setLength(t.maxDistance)), g.copy(m)), h.lengthSq() < t.minDistance * t.minDistance && (t.object.position.addVectors(t.target, h.setLength(t.minDistance)), g.copy(m)))
                }, this.update = function () {
                    h.subVectors(t.object.position, t.target), t.noRotate || t.rotateCamera(), t.noZoom || t.zoomCamera(), t.noPan || t.panCamera(), t.object.position.addVectors(t.target, h), t.object.isPerspectiveCamera ? (t.checkDistances(), t.object.lookAt(t.target), i.distanceToSquared(t.object.position) > r && (t.dispatchEvent(ka), i.copy(t.object.position))) : t.object.isOrthographicCamera ? (t.object.lookAt(t.target), (i.distanceToSquared(t.object.position) > r || a !== t.object.zoom) && (t.dispatchEvent(ka), i.copy(t.object.position), a = t.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type")
                }, this.reset = function () {
                    s = n, o = n, t.target.copy(t.target0), t.object.position.copy(t.position0), t.object.up.copy(t.up0), t.object.zoom = t.zoom0, t.object.updateProjectionMatrix(), h.subVectors(t.object.position, t.target), t.object.lookAt(t.target), t.dispatchEvent(ka), i.copy(t.object.position), a = t.object.zoom
                }, this.dispose = function () {
                    t.domElement.removeEventListener("contextmenu", Q), t.domElement.removeEventListener("pointerdown", U), t.domElement.removeEventListener("pointercancel", M), t.domElement.removeEventListener("wheel", b), t.domElement.removeEventListener("pointermove", y), t.domElement.removeEventListener("pointerup", x), window.removeEventListener("keydown", F), window.removeEventListener("keyup", S)
                }, this.domElement.addEventListener("contextmenu", Q), this.domElement.addEventListener("pointerdown", U), this.domElement.addEventListener("pointercancel", M), this.domElement.addEventListener("wheel", b, {passive: !1}), window.addEventListener("keydown", F), window.addEventListener("keyup", S), this.handleResize(), this.update()
            }
        }

        const Ya = "a185ab65134b4049bb4204901240203", Ja = "Saint Petersburg",
            ja = `https://api.weatherapi.com/v1/forecast.json?key=${Ya}&q=${Ja}&days=7&hour=24&lang=ru`;

        function Za(A, e, t) {
            console.log(t);
            const n = (new Date).getTime();
            console.log(n);
            for (let r = 0; r < t; r++) {
                const t = new Date(n + 36e5 * r);
                console.log(t);
                const i = t.toLocaleDateString("ru-RU", {
                    weekday: "short",
                    year: "numeric",
                    month: "short",
                    day: "numeric"
                });
                let a = "";
                a = 0 === r ? "Сейчас" : `${t.getHours()}:00`;
                const s = A[r].temp_c, o = A[r].condition.text, l = document.createElement("li");
                l.classList.add("hourly__list-item");
                const c = A[r].condition.icon, u = A[r].condition.text;
                l.innerHTML = `\n            <p class="hourly__item-time">${a}</p>\n            <p class="hourly__item-text">${i}</p>\n            <img src="${c}" alt="${u}" class="hourly__item-image">\n            <p class="hourly__item-text">Погода: ${o}</p>\n            <p class="hourly__item-text">Температура: ${s}°C</p>\n        `, e.appendChild(l)
            }
        }

        window.onload = function () {
            !function () {
                const A = new Date, e = A.getHours();
                console.log(e);
                const t = new Date(A);
                t.setHours(23, 59, 59, 999);
                const n = t.toISOString().split("T")[0];
                fetch(`https://api.weatherapi.com/v1/history.json?key=${Ya}&q=${Ja}&dt=${n}&hour=${e}&lang=ru`).then((A => A.json())).then((t => {
                    console.log(t);
                    let n = 24 - e;
                    const r = document.getElementById("hourly__list");
                    r.innerHTML = "";
                    let i = t.forecast.forecastday[0].hour;
                    if (n < 25) {
                        const e = new Date(A);
                        e.setDate(e.getDate() + 1);
                        const t = e.toISOString().split("T")[0];
                        fetch(`https://api.weatherapi.com/v1/forecast.json?key=${Ya}&q=${Ja}&dt=${t}&days=1&lang=ru`).then((A => A.json())).then((A => {
                            console.log(A), i = i.concat(A.forecast.forecastday[0].hour), n = 24, Za(i, r, n)
                        })).catch((A => console.error("Ошибка при загрузке данных о погоде на следующий день:", A)))
                    } else Za(i, r, n)
                })).catch((A => console.error("Ошибка при загрузке данных о погоде:", A)))
            }(), fetch(ja).then((A => A.json())).then((A => {
                const e = document.getElementById("currentWeather"), t = A.current.condition.text;
                e.classList.add(`weather-gradient-${A.current.condition.code}`), e.innerHTML = `\n                <p>Текущая погода: ${t}, ${A.current.temp_c}°C</p>\n                <img src="${A.current.condition.icon}" alt="${A.current.condition.text}">\n            `, console.log(A.current.condition);
                const n = document.getElementById("daily__list");
                n.innerHTML = "", A.forecast.forecastday.forEach((A => {
                    const e = document.createElement("li");
                    e.classList.add("daily__list-item");
                    const t = A.day.condition.icon, r = t.split("//")[1], i = r.slice(r.indexOf("/"));
                    console.log(i);
                    const a = A.day.condition.text;
                    e.innerHTML = `\n                    <p class="daily__item-time">${A.date}: ${A.day.condition.text}</p>\n                    <p class="daily__item-text">Max: ${A.day.maxtemp_c}°C<br>Min: ${A.day.mintemp_c}°C</p>\n                    <img src="${t}" alt="${a}" class="daily__item-image">\n                `, n.appendChild(e)
                })), function () {
                    const A = document.querySelectorAll(".daily__list-item"), e = [];
                    let t = 0;
                    A.forEach(((n, r) => {
                        Ka()(n).then((function (n) {
                            const i = new Ua(n);
                            e[r] = i, t++, t === A.length && function (A) {
                                const e = new Ea, t = new Un(75, window.innerWidth / window.innerHeight, .1, 1e3);
                                t.position.z = 5;
                                const n = new Ca({alpha: !0});
                                n.setClearColor(0, .3);
                                const r = document.querySelector(".canvas-container"), i = r.offsetWidth,
                                    a = Math.min(r.offsetHeight, window.innerHeight);
                                n.setSize(i, a), r.appendChild(n.domElement);
                                const s = new Xa(t, n.domElement), o = A.map((A => new It({map: A}))),
                                    l = new pn(2, 2, 2), c = new hn(l, o), u = (new Date).getDay() - 1,
                                    h = -Math.PI / 2 * (u + 1);
                                c.rotation.y = h, e.add(c), function A() {
                                    requestAnimationFrame(A), s.update(), n.render(e, t)
                                }()
                            }(e)
                        }))
                    }))
                }()
            })).catch((A => console.error("Ошибка при загрузке данных о погоде:", A)))
        }
    })()
})();